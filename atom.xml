<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://c89757.gitee.io/colinstar/atom.xml" rel="self"/>
  
  <link href="http://c89757.gitee.io/colinstar/"/>
  <updated>2021-12-22T12:52:47.613Z</updated>
  <id>http://c89757.gitee.io/colinstar/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于count(*)</title>
    <link href="http://c89757.gitee.io/colinstar/2021/12/22/%E5%85%B3%E4%BA%8Ecount()/"/>
    <id>http://c89757.gitee.io/colinstar/2021/12/22/%E5%85%B3%E4%BA%8Ecount()/</id>
    <published>2021-12-22T12:09:37.000Z</published>
    <updated>2021-12-22T12:52:47.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="count-的不同实现方式"><a href="#count-的不同实现方式" class="headerlink" title="count(*)的不同实现方式"></a>count(*)的不同实现方式</h1><hr><p>在 msyql 引擎中，count（*）有不同的实现方式</p><hr><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上,因此执行count(*)的时候会直接返回这个数，效率很高</li><li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累计计数</li></ul><p>当然，这里说的是不加where条件的count(*)，如果加了条件，MyISAM表也不能返回这么快的。</p><p>为什么InnoDB不像MyISAM一样，也把数字存起来呢？</p><p>​    因为即使在同一个时刻的多个子查询，由于多版本并发控制（MVCC）的原因，而InnoDB表 应该返回多少行 也是不确定的。</p><p>比如现在某表中有1000条数据</p><p>会话A去执行select(*)</p><p>会话B开启事务，新增一条数据，再执行select * </p><p>会话A和会话B在同一时刻执行，那么他们返回的总行数是不一样的，A返回1000，而B返回1001</p><p>这和InnoDB的事务有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB会把数据一行一行的读出来依次判断，可见的行才能够计算“基于这个查询”的表的总行数</p><blockquote><p>​    MySQL在执行 count(*)操作的时候还是做了优化的。 InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是 主键值。所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树 得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。在保证逻辑 正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一</p></blockquote><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><hr><p>如果一个页面需要经常查询显示某表的总数，应该如何去做呢？</p><hr><p>我们应该自己去计数</p><h2 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h2><p>​    可以用Redis去记录这个表的总行数。每插入一行Redis计数就加1，每删除一行Redis计数就减1。</p><p>可能存在的问题：</p><p>1、Redis可能会丢失数据，如果我们刚在表里插入了一行数据，Redis中的值也进行了自增，然后Redis宕机了，还没来得及进行持久化，导致数据的丢失；</p><p>（我们可以在Redis宕机后，手动select(*)查询总行数写回Redis)</p><p>2、Redis和MySql存在分布式事务问题；</p><p>比如某个场景下，我们需要查询显示总数，并且还要显示最近操作的100条记录。那我们就需要先从Redis里面取出计数，再去表里取数据记录</p><p>可能存在的问题，查到的100行里面没有新增的数据，但Redis的计数已经加1</p><p>另一种是，查到的100行有新增的数，但是Redis的计数还没加1</p><p>产生的原因就是，无法保证提交数据库事务的同时写入Redis，</p><h2 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h2><p>​    用一张表去记录总数，可以避免上述问题，因此事务的可见性，我们插入数据和修改表中记录的行数都是在方法执行完后统一提交的事务，事务还未提交时，对其他线程是不可见的</p><ul><li>从并发系统性能的角度看，应该先插数据表，还是先更新计数表呢？</li></ul><p>更新计数表会涉及到行锁的竞争，先插入再更新能最大程度的减少了事务之间的锁等待，提高并发度（事务开启后，更新操作放到最后，减少锁等待时间的影响）</p><h1 id="不同count的用法"><a href="#不同count的用法" class="headerlink" title="不同count的用法"></a>不同count的用法</h1><p>count(*)、count(id)、count(字段)、count(1)的用法的性能，有哪些差别呢。</p><hr><p>基于InnoDB引擎</p><hr><p>count（）是一个聚合函数，对于返回的结果集，一行一行的判断，如果count函数的参数不是null,就会累计值加1，否则不加。</p><p>所以count(*),count(id),count(字段),count(1)都返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里，参数“字段”不为null的总个数</p><ul><li><p>对于count(id)来说。InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层，server层拿到id后，判断是不可能为空的，就按行累加</p></li><li><p>对于count(1)来说。InnoDB引擎遍历整张表，但是不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加</p></li></ul><p>count(*)执行的要比count(id)快，因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作</p><ul><li>对于count(字段)来说。 如果这个字段是定义为not null的话，一行行的从记录里面读取出这个字段，判断不能为null,按行累加； 如果这个字段允许为空，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加</li><li>对于count(*)来说。并不会把全部字段取出来，而是专门做了优化，不取值，count(*)肯定不是null,按行累加</li></ul><p>按照效率排序的话，count(字段) &lt; count(id) &lt; count(1) ≈ count(*)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;count-的不同实现方式&quot;&gt;&lt;a href=&quot;#count-的不同实现方式&quot; class=&quot;headerlink&quot; title=&quot;count(*)的不同实现方式&quot;&gt;&lt;/a&gt;count(*)的不同实现方式&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;在 msyql 引擎中，count</summary>
      
    
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Sychronized关键字-monitorenter与monitorexit</title>
    <link href="http://c89757.gitee.io/colinstar/2021/12/17/Sychronized%E5%85%B3%E9%94%AE%E5%AD%97-monitorenter%E4%B8%8Emonitorexit/"/>
    <id>http://c89757.gitee.io/colinstar/2021/12/17/Sychronized%E5%85%B3%E9%94%AE%E5%AD%97-monitorenter%E4%B8%8Emonitorexit/</id>
    <published>2021-12-17T11:19:25.000Z</published>
    <updated>2021-12-17T11:47:41.031Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每个对象都有一个Monitor与之关联，当Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>经过javap解析后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">   Code:</span><br><span class="line">      <span class="number">0</span>: aload_0</span><br><span class="line">      <span class="number">1</span>: dup</span><br><span class="line">      <span class="number">2</span>: astore_1</span><br><span class="line">      <span class="number">3</span>: monitorenter</span><br><span class="line">      <span class="number">4</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">7</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world</span></span><br><span class="line">      <span class="number">9</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">     <span class="number">12</span>: aload_1</span><br><span class="line">     <span class="number">13</span>: monitorexit</span><br><span class="line">     <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">     <span class="number">17</span>: astore_2</span><br><span class="line">     <span class="number">18</span>: aload_1</span><br><span class="line">     <span class="number">19</span>: monitorexit</span><br><span class="line">     <span class="number">20</span>: aload_2</span><br><span class="line">     <span class="number">21</span>: athrow</span><br><span class="line">     <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">   Exception table:</span><br><span class="line">      from    to  target type</span><br><span class="line">          <span class="number">4</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">         <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   any</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此处会发现有一个monitorenter，却有两个monitorexit；<br>这是JVM的补偿机制，保证你的同步代码块中出现异常，能正常释放锁</p><p>如字节码行号4-13可能会出现异常，则会走17进行异常处理，在此处进行锁的释放</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每个对象都有一个Monitor与之关联，当Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，都可以通过成对的MonitorEnter和MonitorE</summary>
      
    
    
    
    <category term="juc" scheme="http://c89757.gitee.io/colinstar/categories/juc/"/>
    
    
    <category term="JUC" scheme="http://c89757.gitee.io/colinstar/tags/JUC/"/>
    
    <category term="多线程" scheme="http://c89757.gitee.io/colinstar/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySql性能调优</title>
    <link href="http://c89757.gitee.io/colinstar/2021/12/16/MySql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://c89757.gitee.io/colinstar/2021/12/16/MySql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</id>
    <published>2021-12-16T15:08:30.000Z</published>
    <updated>2021-12-17T11:47:30.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="啥也没有，只是为了样式展示"><a href="#啥也没有，只是为了样式展示" class="headerlink" title="啥也没有，只是为了样式展示"></a>啥也没有，只是为了样式展示</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;啥也没有，只是为了样式展示&quot;&gt;&lt;a href=&quot;#啥也没有，只是为了样式展示&quot; class=&quot;headerlink&quot; title=&quot;啥也没有，只是为了样式展示&quot;&gt;&lt;/a&gt;啥也没有，只是为了样式展示&lt;/h1&gt;</summary>
      
    
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>gitee+hexo搭建个人博客</title>
    <link href="http://c89757.gitee.io/colinstar/2021/12/16/gitee+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://c89757.gitee.io/colinstar/2021/12/16/gitee+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-12-16T12:42:22.000Z</published>
    <updated>2021-12-17T11:49:04.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h1><p>事前准备：</p><p>先创建一个仓库，同时在仓库根目录下创建index.html (gitee官网这样说的,没试过缺少这个文件会怎样)</p><img src="/colinstar/2021/12/16/gitee+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.png" class title="This is an example image"><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><h2 id="所需环境"><a href="#所需环境" class="headerlink" title="所需环境"></a>所需环境</h2><ul><li><p>node.js</p></li><li><p>git</p><p>自行进行下载与安装</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装hexo</span></span><br><span class="line">npm install -g hexo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建文件夹,用来存储你博客内容</span></span><br><span class="line">hexo init test</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span>到创建的目录,执行</span></span><br><span class="line">npm install</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启hexo服务</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:4000；没有问题的话就会显示他的默认页面">http://localhost:4000；没有问题的话就会显示他的默认页面</a></p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>关联git仓库，在你创建的目录下找到 config.yml文件（例如此处我的是test/_config.yml）</p><p>打开添加如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://gitee.com/xxx/xxxx</span>   <span class="comment"># 你的仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span>   <span class="comment"># 你的仓库分支</span></span><br></pre></td></tr></table></figure><ul><li>生成静态页面</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g    #或者 hexo generate</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时若出现如下报错：</span></span><br><span class="line">ERROR Local hexo not found in ~/blog</span><br><span class="line">ERROR Try runing: &#x27;npm install hexo --save&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 则执行命令：</span></span><br><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><ul><li>将生成的页面提交到仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d  #或者hexo deploy</span><br></pre></td></tr></table></figure><p>若执行命令hexo deploy报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h1 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h1><p>进入到你创建的“text”目录，新建文章，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;blog&quot;</span><br></pre></td></tr></table></figure><p>此时在test/source/_posts下，会新建一个名为“blog.md”的文件，利用相关markdown编辑器就能编写你的博客啦!(我这里用的typore)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 生成静态页面</span><br><span class="line"></span><br><span class="line">hexo d # 部署到gitee</span><br></pre></td></tr></table></figure><p>hexo有许多主题，默认生成的主题都是landscape，你也可以去<a href="http://hexo.io/themes">主题官网</a>寻找自己喜欢的主题</p><p>例如主题pure</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/cofess/hexo-theme-pure.git themes/pure</span><br><span class="line"><span class="meta">#</span><span class="bash">修改<span class="built_in">test</span>目录下_config.yml里theme的名称,将landscape修改为pure即可</span> </span><br><span class="line"></span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta">#</span><span class="bash">清除缓存文件 (db.json) 和静态文件 (public)</span></span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta">#</span><span class="bash">生成缓存和静态文件</span></span><br><span class="line"></span><br><span class="line">hexo d             </span><br><span class="line"><span class="meta">#</span><span class="bash">重新部署到服务器</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;事前准备：&lt;/p&gt;
&lt;p&gt;先创建一个仓库，同时在仓库根目录下创建index.html (gitee官网这样</summary>
      
    
    
    
    <category term="others" scheme="http://c89757.gitee.io/colinstar/categories/others/"/>
    
    
    <category term="others" scheme="http://c89757.gitee.io/colinstar/tags/others/"/>
    
  </entry>
  
</feed>
