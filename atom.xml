<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://c89757.gitee.io/colinstar/atom.xml" rel="self"/>
  
  <link href="http://c89757.gitee.io/colinstar/"/>
  <updated>2023-02-19T14:50:19.194Z</updated>
  <id>http://c89757.gitee.io/colinstar/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>innodb数据页</title>
    <link href="http://c89757.gitee.io/colinstar/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/"/>
    <id>http://c89757.gitee.io/colinstar/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/</id>
    <published>2023-02-18T14:54:52.000Z</published>
    <updated>2023-02-19T14:50:19.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><br><p>innodb页目录结构大致如下</p><br><img src="/colinstar/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230218234003851.png" class><br><p>先说说行格式，compact行格式结构如下</p><p>（其中，记录的真实数据，除了用户真实的数据以外，还有一些隐藏列，</p><p>row_id - 行id，唯一标识一条记录，没有定义主键时，会添加此隐藏列；</p><p>事务id -  事务ID</p><p>roll_pointer：回滚指针）</p><br><img src="/colinstar/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230218233845956.png" class><br><p>记录头各属性及其解释如下</p><br><img src="/colinstar/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230218233857866.png" class><br><p>表中记录大致如下</p><br><img src="/colinstar/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230218235643636.png" class><br><br><h1 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h1><br><p>​    记录在页中是按照主键值由小到大的顺序串联成一个单项链表，如果要查找表中一条记录，最简单的方法就是遍历链表，但是当记录非常多时，是很耗费性能的，于是就有了page directory页目录。其实就是一个字典</p><br><p>1、将所有正常的记录（包括Infimum和Supremum记录，但是不包括已经移除到垃圾链表的记录）划分为几个组</p><p>2、每个组的最后一条记录（也就是组内最大的那条记录）相当于带头大哥，组内其余的记录相当于小弟，带头大哥记录的头信息中的n_owned属性表示该组内共有几条记录</p><p>3、将每个组中最后一条记录在页面中的地址偏移量（就是该记录的真实数据与页面中第0个字节之间的距离）单独提取出来，按顺序存储到靠近页尾部的地方，这个地方就是<code>Page Directory</code>.页目录中这些地址偏移量称为槽（Slot)，每个槽占用2字节，页目录就是由多个槽组成的</p><br><img src="/colinstar/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230219000408171.png" class><br><br><ul><li>Infimum记录中的n_owned值为1，表示以Infimum记录为最后一个节点的这个组中只有一条记录，也就是Infimum记录自身</li><li>Supremum记录的n_owned值为3，表示以Supremum记录为最后一个节点的这个分组中有3条记录，即除了Supremum记录自身外，还有两条记录</li></ul><br><br><p>分组的依据：</p><p>对于Infimum记录所在的分组只能有1条记录，Supremum记录所在的分组拥有的记录条数只能在1<del>8之间，剩下分组中的条数范围只能是4</del>8之间。</p><br><h1 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h1><br><p>页面头部</p><p>存储数据页中的记录的各种状态信息</p><br><img src="/colinstar/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230219224613055.png" class><br><br><h1 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h1><br><p>记录页面当前页号，以及上一页、下一页的页号（并不是所有类型的页都会记录上一页、下一页的页号）</p><br><img src="/colinstar/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230219001321572.png" class><br><ul><li>每一个<code>页</code>都有一个单独的页号，就跟你的身份证号码一样，<code>InnoDB</code>通过页号来可以唯一定位一个<code>页</code>。</li><li>FIL_PAGE_TYPE</li></ul><br><img src="/colinstar/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230219001549129.png" class><ul><li>我们存放记录的数据页的类型其实是<code>FIL_PAGE_INDEX</code>，也就是所谓的<code>索引页</code></li></ul><br><h1 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h1><br><p>文件尾部，用于检验一个页是否完整（刷盘时，不可预知的情况可能导致刷盘只刷新了一部分)</p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;br&gt;

&lt;p&gt;innodb页目录结构大致如下&lt;/p&gt;
&lt;br&gt;

&lt;img src=&quot;/colinstar/2023/02/18/innodb</summary>
      
    
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>G1 GC</title>
    <link href="http://c89757.gitee.io/colinstar/2023/02/05/G1-GC/"/>
    <id>http://c89757.gitee.io/colinstar/2023/02/05/G1-GC/</id>
    <published>2023-02-05T07:13:35.000Z</published>
    <updated>2023-02-05T07:13:35.782Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>记-并发情况下mysql死锁问题</title>
    <link href="http://c89757.gitee.io/colinstar/2023/01/28/%E8%AE%B0-%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8Bmysql%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <id>http://c89757.gitee.io/colinstar/2023/01/28/%E8%AE%B0-%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8Bmysql%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</id>
    <published>2023-01-28T15:30:14.000Z</published>
    <updated>2023-01-28T15:59:34.017Z</updated>
    
    <content type="html"><![CDATA[<p>背景：业务中采用先删除后插入的逻辑，开启了事务。</p><p>表结构大概如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `table_test`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `key1` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `column1` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `column2` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_key1`(`key1`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB  <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先根据二级索引key1删除表中数据（相同的key1），再批量插入数据，在并发情况下，频繁出现死锁问题。</p><p>利用</p><blockquote><p>set GLOBAL innodb_status_output_locks = on;</p><p>show  engine innodb status;</p></blockquote><p>可以查看mysql最后一次发生死锁的情况</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">------------------------</span></span><br><span class="line"><span class="attr">LATEST</span> <span class="string">DETECTED DEADLOCK</span></span><br><span class="line"><span class="attr">------------------------</span></span><br><span class="line"><span class="meta">2023-01-28</span> <span class="string">23:25:46 0x14e90</span></span><br><span class="line"><span class="meta">***</span> <span class="string">(1) TRANSACTION:</span></span><br><span class="line"><span class="attr">TRANSACTION</span> <span class="string">62092, ACTIVE 0 sec starting index read</span></span><br><span class="line"><span class="attr">mysql</span> <span class="string">tables in use 1, locked 1</span></span><br><span class="line"><span class="attr">LOCK</span> <span class="string">WAIT 6 lock struct(s), heap size 1136, 6 row lock(s)</span></span><br><span class="line"><span class="attr">MySQL</span> <span class="string">thread id 239, OS thread handle 20368, query id 105887 localhost 127.0.0.1 root updating</span></span><br><span class="line"><span class="attr">delete</span> <span class="string">from table_test where key1 = &#x27;aaa&#x27;</span></span><br><span class="line"><span class="meta">***</span> <span class="string">(1) WAITING FOR THIS LOCK TO BE GRANTED:</span></span><br><span class="line"><span class="attr">RECORD</span> <span class="string">LOCKS space id 308 page no 3 n bits 152 index PRIMARY of table `db`.`table_test` trx id 62092 lock_mode X locks rec but not gap waiting</span></span><br><span class="line"><span class="attr">Record</span> <span class="string">lock, heap no 56 PHYSICAL RECORD: n_fields 6; compact format; info bits 32</span></span><br><span class="line"> <span class="attr">0</span>: <span class="string">len 4; hex 80001e9c; asc     ;;</span></span><br><span class="line"> <span class="attr">1</span>: <span class="string">len 6; hex 00000000f28e; asc       ;;</span></span><br><span class="line"> <span class="attr">2</span>: <span class="string">len 7; hex 79000001ff139a; asc y      ;;</span></span><br><span class="line"> <span class="attr">3</span>: <span class="string">len 3; hex 616161; asc aaa;;</span></span><br><span class="line"> <span class="attr">4</span>: <span class="string">len 1; hex 31; asc 1;;</span></span><br><span class="line"> <span class="attr">5</span>: <span class="string">len 1; hex 32; asc 2;;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">***</span> <span class="string">(2) TRANSACTION:</span></span><br><span class="line"><span class="attr">TRANSACTION</span> <span class="string">62094, ACTIVE 0 sec updating or deleting, thread declared inside InnoDB 0</span></span><br><span class="line"><span class="attr">mysql</span> <span class="string">tables in use 1, locked 1</span></span><br><span class="line"><span class="attr">5</span> <span class="string">lock struct(s), heap size 1136, 6 row lock(s), undo log entries 1</span></span><br><span class="line"><span class="attr">MySQL</span> <span class="string">thread id 242, OS thread handle 85648, query id 105894 localhost 127.0.0.1 root updating</span></span><br><span class="line"><span class="attr">delete</span> <span class="string">from table_test where key1 = &#x27;aaa&#x27;</span></span><br><span class="line"><span class="meta">***</span> <span class="string">(2) HOLDS THE LOCK(S):</span></span><br><span class="line"><span class="attr">RECORD</span> <span class="string">LOCKS space id 308 page no 3 n bits 152 index PRIMARY of table `db`.`table_test` trx id 62094 lock_mode X</span></span><br><span class="line"><span class="attr">Record</span> <span class="string">lock, heap no 56 PHYSICAL RECORD: n_fields 6; compact format; info bits 32</span></span><br><span class="line"> <span class="attr">0</span>: <span class="string">len 4; hex 80001e9c; asc     ;;</span></span><br><span class="line"> <span class="attr">1</span>: <span class="string">len 6; hex 00000000f28e; asc       ;;</span></span><br><span class="line"> <span class="attr">2</span>: <span class="string">len 7; hex 79000001ff139a; asc y      ;;</span></span><br><span class="line"> <span class="attr">3</span>: <span class="string">len 3; hex 616161; asc aaa;;</span></span><br><span class="line"> <span class="attr">4</span>: <span class="string">len 1; hex 31; asc 1;;</span></span><br><span class="line"> <span class="attr">5</span>: <span class="string">len 1; hex 32; asc 2;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Record</span> <span class="string">lock, heap no 71 PHYSICAL RECORD: n_fields 6; compact format; info bits 32</span></span><br><span class="line"> <span class="attr">0</span>: <span class="string">len 4; hex 80001e9b; asc     ;;</span></span><br><span class="line"> <span class="attr">1</span>: <span class="string">len 6; hex 00000000f282; asc       ;;</span></span><br><span class="line"> <span class="attr">2</span>: <span class="string">len 7; hex 72000001ba2356; asc r    #V;;</span></span><br><span class="line"> <span class="attr">3</span>: <span class="string">len 3; hex 616161; asc aaa;;</span></span><br><span class="line"> <span class="attr">4</span>: <span class="string">len 1; hex 31; asc 1;;</span></span><br><span class="line"> <span class="attr">5</span>: <span class="string">len 1; hex 32; asc 2;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Record</span> <span class="string">lock, heap no 80 PHYSICAL RECORD: n_fields 6; compact format; info bits 32</span></span><br><span class="line"> <span class="attr">0</span>: <span class="string">len 4; hex 80001e9a; asc     ;;</span></span><br><span class="line"> <span class="attr">1</span>: <span class="string">len 6; hex 00000000f288; asc       ;;</span></span><br><span class="line"> <span class="attr">2</span>: <span class="string">len 7; hex 75000001e919c8; asc u      ;;</span></span><br><span class="line"> <span class="attr">3</span>: <span class="string">len 3; hex 616161; asc aaa;;</span></span><br><span class="line"> <span class="attr">4</span>: <span class="string">len 1; hex 31; asc 1;;</span></span><br><span class="line"> <span class="attr">5</span>: <span class="string">len 1; hex 32; asc 2;;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">***</span> <span class="string">(2) WAITING FOR THIS LOCK TO BE GRANTED:</span></span><br><span class="line"><span class="attr">RECORD</span> <span class="string">LOCKS space id 308 page no 4 n bits 152 index idx_key1 of table `db`.`table_test` trx id 62094 lock_mode X locks rec but not gap waiting</span></span><br><span class="line"><span class="attr">Record</span> <span class="string">lock, heap no 39 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span></span><br><span class="line"> <span class="attr">0</span>: <span class="string">len 3; hex 616161; asc aaa;;</span></span><br><span class="line"> <span class="attr">1</span>: <span class="string">len 4; hex 80001e9c; asc     ;;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">***</span> <span class="string">WE ROLL BACK TRANSACTION (2)</span></span><br></pre></td></tr></table></figure><p>可以看到，两个事务，分别持有了聚簇索引的锁与二级索引key1上的锁，导致死锁。</p><p>解决方案：可以先根据key1查询出主键，再根据主键去操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;背景：业务中采用先删除后插入的逻辑，开启了事务。&lt;/p&gt;
&lt;p&gt;表结构大概如下：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</summary>
      
    
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>JUC</title>
    <link href="http://c89757.gitee.io/colinstar/2022/12/04/JUC/"/>
    <id>http://c89757.gitee.io/colinstar/2022/12/04/JUC/</id>
    <published>2022-12-04T14:47:30.000Z</published>
    <updated>2022-12-04T15:15:03.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冯诺依曼计算机"><a href="#冯诺依曼计算机" class="headerlink" title="冯诺依曼计算机"></a>冯诺依曼计算机</h1><h2 id="计算机五大核心组成部分"><a href="#计算机五大核心组成部分" class="headerlink" title="计算机五大核心组成部分"></a>计算机五大核心组成部分</h2><ol><li>控制器(Control)：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。</li><li>运算器(Datapath)：运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进行加工处理。</li><li>存储器(Memory)：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。</li><li>输入(Input system)：输入设备是计算机的重要组成部分，输入设备与输出设备合你为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。</li><li>输出(Output system)：输出设备与输入设备同样是计算机的重要组成部分，它把外算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来。</li><li>微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。</li></ol><p>下图——冯诺依曼计算机模型图</p><p>上面的模型是一个理论的抽象简化模型，它的具体应用就是现代计算机当中的硬件结构设计：</p><p>在上图硬件结构中，最核心的两部分：CPU、内存</p><p>CPU内部结构</p><ul><li>控制单元</li><li>运算单元</li><li>数据单元</li></ul><p><strong>控制单元</strong></p><p>控制单元是整个CPU的指挥控制中心，由指令寄存器IR（Instructio Register)、指令译码器ID（Instruction Decoder)和操作控制器OD(Operation Controller)等组成。</p><p><strong>CPU缓存结构</strong></p><p>现在CPU为了提升执行效率， 减少CPU与内存的交互（交互影响CPU效率），一般在CPU上集成了多级缓存架构，常见的三级缓存结构</p><p>L1 Cache，分为数据缓存和指令缓存，逻辑核独占</p><p>L2 Cache，物理核独占，逻辑核共享</p><p>L3 Cache，所有物理核共享</p><img src="/colinstar/2022/12/04/JUC/image-20220315205009112.png" class><br><br><p>存储器存储空间大小：内存 &gt; L3 &gt; L2 &gt; L1 &gt; 寄存器</p><p>存储器速度快慢排序：寄存器 &gt; L1 &gt; L2 &gt; L3 &gt; 内存</p><p>还有一点值得注意的是：缓存是由最小的存储区块——缓存行（cacheline）组成，缓存行大小通常为64byte</p><br><p><strong>什么是缓存行？</strong></p><pre><code>比如你的L1缓存大小为512kb，而cacheline = 64byte，那么L1里有512 * 1024 / 64 个cacheline</code></pre><br><p><strong>CPU读取存储器数据过程：</strong></p><blockquote><p>1、CPU要取寄存器X的值，只需要一步：直接读取</p><p>2、CPU要取L1 Cache的某个值，需要 1 - 3步（或者更多）: 把cache行锁住，把某个数据拿来，解锁</p><p>3、CPU要读取L2 Cache的某个值，先要到L1 Cache里取，L1当中不存在，在L2里，L2开始加锁，加锁以后，把</p><p>L2里的数据复制到L1，在执行读L1的过程，上面的三步再解锁</p><p>4、CPU取L3 Cache的也是一样，只不过先由L3复制到L2，L2复制到L1，从L1到CPU</p><p>5、CPU取内存则最复杂：通知内存控制器占用总线带宽，通知内存加锁，发起内存读请求，等待回应，回应数据保存在L3（如果没有就到L2），再从L3/L2到L1，再从L1到CPU，之后解除总线锁定</p></blockquote><br><p><strong>CPU为何要有高速缓存？</strong></p><pre><code>CPU在摩尔定律的指导下以每18月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU，这就造成了高性能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题。CPU厂商在CPU中内置了少量的高速缓存以解决I\O速度和CPU运算之间的不匹配问题</code></pre><br><pre><code>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理**时间局部性（Temporal Localit）**：如果一个信息项正在被访问，那么在近期它很有可能还会被再次访问。比如循环、递归、方法的反复调用等**空间局部性（Spatial Locality）**：如果一个存储器的位置被引用，那么将来它附近的位置也会被引用。比如顺序执行的代码，连续创建的两个对象，数组等。</code></pre><br><p>空间局部性——&gt; 并不仅仅取主内存访问x = 0 ,会把x = 0 的附近的位置也拿到L3 Cache中</p><br><p><strong>带有高速缓存的CPU执行计算的流程</strong></p><ol><li>程序以及数据被加载到主内存</li><li>指令和数据被加载到CPU的高速缓存</li><li>CPU执行指令，把结果写到高速缓存</li><li>高速缓存中的数据写回主内存</li></ol><h2 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h2><br><p><strong>执行空间保护</strong></p><p>操作系统有用户空间和内核空间两个概念，目的也是为了做到程序运行安全隔离与稳定</p><br><p>以32位操作系统4G大小内存空间为例</p><br><br><pre><code>Linux为内核代码和数据结构预留了几个页框，这些页永远不会被转出到磁盘上。从0x00000000到0xc000000(PAGE_OFFSET)的线性地址可由用户代码和内核代码进行引用（即用户空间）。从0xc0000000（PAGE_OFFSET）到 0xFFFFFFFFF的线性地址只能由内核代码进行访问（即内核空间）。内核代码及其数据结构都必须位于这1GB的地址空间中，但是对于此地址空间而言，更大的消费者是物理地址的虚拟应用这意味着在4GB的内存空间中，只有3GB可以用于用户应用程序。进程与线程只能运行在用户方式（usermode）或内核方式（kernelmode）下。用户程序运行在用户方式下，而系统调用运行在内核方式下。这两种方式下所用的堆栈不一样：用户方式下用的是一般的堆栈（用户空间的堆栈），而内核方式下用的是固定大小的堆栈（内核空间的堆栈，一般为一个内存页的大小），即每个进程与线程其实有两个堆栈，分别运行在用户态与内核态</code></pre><br><p>CPU调度的基本单位线程，也可以划分为：</p><p>1、内核线程模型（KLT)</p><p>2、用户线程模型（ULT）</p><p><strong>内核线程模型</strong></p><br><pre><code>**内核线程（KLT）**：系统内核管理线程（KLT），内核保存线程的状态和上下文信息，线程阻塞不会引起进程阻塞。在多处理器系统上，多线程在多处理器上并行运行。线程的创建、调度和管理由内核完成，效率比ULT更慢，比进程操作快</code></pre><br><p><strong>用户线程模型</strong></p><br><pre><code>    **用户线程（ULT）**：用户程序实现，不依赖操作系统核心，应用提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态/内核态切换，速度快。内核对ULT无感知，线程阻塞则进程（包括它的所有线程）阻塞。</code></pre><br><p><strong>虚拟机指令集架构</strong></p><p>虚拟机指令集架构主要分为两种：</p><p>1、栈指令集架构</p><p>2、寄存器指令集架构</p><br><p><strong>栈指令集架构：</strong></p><ol><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题，使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令,其执行过程依赖与操作栈,指令集更小,编译器容易实现;</li><li>不需要硬件支持,可移植性更好,更好实现跨平台</li></ol><br><p><strong>寄存器指令架构</strong></p><ol><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作</li><li>大部分情况下,基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主,而基于栈式架构的指令集却是以零地址指令为主</li></ol><br><h1 id="JMM模型"><a href="#JMM模型" class="headerlink" title="JMM模型"></a>JMM模型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><pre><code>    Java内存模型（Java Memory Model简称JMM）是一种抽象的概念，并不真实存在，它描述的是一组规则或规范；通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式            JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行；首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</code></pre></blockquote><br><p><strong>JMM不同于JVM内存区域模型</strong></p><pre><code>JMM与JVM内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，==JMM是围绕原子性、有序性、可见性展开==。JMM与JVM内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲应该包括程序计数器、虚拟机栈以及本地方法栈</code></pre><br><p>线程、工作内存、主内存工作交互图（基于JMM规范）:</p><br><br><p><strong>主内存</strong>：主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量（也称局部变量），当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发生线程安全问题</p><p><strong>工作内存</strong>：主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意：由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题</p><br><p>根据JVM虚拟机规范，主内存与工作内存的数据存储类型以及操作方式，对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double)，将直接存储在工作内存的栈帧结构中，但堂托本地变量是引用类型，那么该变量的引用会存储在工作内存的栈帧中，而对象实例将存储在主内存（共享数据区域，堆）中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型（Integer、Double等）还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中实例对象可以被多个线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存模型如下图所示</p><br><br><h2 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h2><pre><code>通过对前面的硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响。因为JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。(注意对于Java内存区域划分也是同样的道理)</code></pre><br><p><strong>JMM存在的必要性</strong></p><pre><code>假设主内存中存在一个共享变量x，现在有A和B两条线程分别对该变量x=1进行操作， A/B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程却想要读取x的值，那么B线程读取到的值是A线程更新后的值2还是更新前的值1呢？答案是，不确定，即B线程有可能读取到A线程更新前的值1，也有可能读取到A线程更新后的值 2，这是因为工作内存是每个线程私有的数据区域，而线程A变量x时，首先是将变量从主内存拷贝到A线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内，而对于B线程的也是类似的，这样就有可能造成主内存与工作内存间数据存在一致性问题，假如A线程修改完后正在将数据写回主内存，而B线程此时正在读取主内存，即将x=1拷贝到自己的工作内存中，这样B线程读取到的值就是x=1，但如果A线程已将x=2写回主内存后，B线程才开始读取的话，那么此时B线程读取到的就是x=2，但到底是哪种情况先发生呢？</code></pre><pre><code>以上关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成</code></pre><br><p><strong>数据同步八大原子操作</strong></p><ol><li>lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态</li><li>unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li><li>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量</li><li>store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</li><li>write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</li></ol><br><pre><code>如果要把一个变量从主内存复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行</code></pre><br><p><br><br></p><br><p>同步规则分析</p><ol><li>不允许一个线程无原因的（没有发生过任何assign操作）把数据从工作内存同步回主内存中</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign)的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用变量之前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作)</li></ol><br><h2 id="并发编程的可见性、原子性与有序性问题"><a href="#并发编程的可见性、原子性与有序性问题" class="headerlink" title="并发编程的可见性、原子性与有序性问题"></a>并发编程的可见性、原子性与有序性问题</h2><p><strong>原子性</strong>指的是一个操作是不可中断的，即使在多线程环境下，一个操作一旦开始就不会被其他线程影响</p><blockquote><p>在java中，对基本数据类型的变量的读取和赋值操作是原子性操作有点要注意的是，对于32位系统的来说，long类型数据和double类型数据(对于基本数据类型， byte,short,int,float,boolean,char读写是原子操作)，它们的读写并非原子性的，也就是说如果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的，因为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取到了后32位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值，即64位数据被两个线程分成了两次读取。但也不必太担心，因为读取到“半个变量”的情况比较少见，至少在目前的商用的虚拟机中，几乎都把64位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道这么回事即可。</p></blockquote><br><p><strong>可见性</strong>：</p><pre><code>可见性指的是当一个线程修改了某个共享变量的值，其他线程能否马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取到这个变量值，并且是修改过的新值但在多线程环境中可就不一定了，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量x的值，还未写回到主内存时，另外一个线程B又对主内存中同一个共享变量x进行操作，但此时A线程工作内存中变量x对线程B来说并不可见，这种工作内存与主内存同步延迟线现象就造成了可见性问题。另外指令重排及编译器优化也可能导致可见性问题</code></pre><br><p><strong>有序性</strong>：</p><pre><code>有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此。但对于多线程环境下，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排，重排后的指令与原指令的顺序未必一致</code></pre><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">while</span> (!flag) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot;的当前线程flag的状态改变&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;ThreadA&quot;</span>);</span><br><span class="line">threadA.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot;refresh data...&quot;</span>);</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot;refresh data success&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;ThreadB&quot;</span>);</span><br><span class="line">threadB.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// threadA嗅探不到threadB对共享变量的修改，因为这里是空的死循环，空循环的优先级特别高，几乎不会让出CPU资源；如果在循环里执行一点操作，如打印一句话什么的，那么threadA是有可能嗅探到值的变化的，只是什么时候会感知到，这个不确定，而volatile能保证立马感知到</span></span><br></pre></td></tr></table></figure><br><p><strong>voloatile禁止重排优化</strong></p><pre><code>volatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象，voloatile禁止重排的关键在于内存屏障（Memory Barrier)</code></pre><br><p>硬件层的内存屏障</p><p>Intel硬件提供了一系列的内存屏障，主要有：</p><ol><li>Ifence,是一种Load Barrier读屏障</li><li>sfence，是一种Store Barrier写屏障</li><li>mfence，是一种全能型的屏障，具备lfence和sfence的能力</li><li>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁，它后面可以跟ADD,ADC,AND,BTC等指令</li></ol><br><p>不同硬件实现内存屏障的方式不同，Java内存模型屏蔽了这种底层硬件平台的差异，由JVM来为不同的平台生成相应的机器码.JVM中提供了四类内存屏障指令：</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1；LoadLoad；Load2</td><td>保证Load1的读取操作在Load2及后续读取操作之前执行</td></tr><tr><td>StoreStore</td><td>Store1；StoreStore；Store2</td><td>在store2及其后的写操作执行前，保证store1的写操作</td></tr><tr><td>LoadStore</td><td>Load1；LoadStore；Store2</td><td>在Store2及其后的写操作执行前，保证load1的读操作已执行</td></tr><tr><td>StoreLoad</td><td>Stroe1；StoreLoad；Load2</td><td>保证Store1的写操作已刷新到主内存之后，Load2及其后</td></tr></tbody></table><br><blockquote><p>内存屏障，又叫内存栅栏，是一个CPU指令，它的作用有两个，==一个是保证特定操作的执行顺序，二是保证某些变量的内存可见性==（利用该特性实现volatile的内存可见性）</p></blockquote><br><p>由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用：是强制刷出各种CPU的缓存数据，因此任何CPU上的线程读取到这些数据的最新版本;总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化</p><br><h2 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h2><br><pre><code>前面提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型下图是JMM针对编译器制定的volatile重排序规则表</code></pre><br><table><thead><tr><th>第一个操作</th><th>第二个操作：普通读写</th><th>第二个操作：volatile读</th><th>第二个操作：volatile写</th></tr></thead><tbody><tr><td>普通读写</td><td>可以重排</td><td>可以重排</td><td>不可以重排</td></tr><tr><td>volatile读</td><td>不可以重排</td><td>不可以重排</td><td>不可以重排</td></tr><tr><td>volatile写</td><td>可以重排</td><td>不可以重排</td><td>不可以重排</td></tr></tbody></table><br><ol><li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后</li><li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前</li><li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序</li></ol><br><pre><code>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略</code></pre><ul><li><p>在每个volatile写操作的<strong>前面</strong>插入一个StoreStore屏障</p></li><li><p>在每个volatile写操作的<strong>后面</strong>插入一个StoreLoad屏障</p></li><li><p>在每个volatile读操作的<strong>后面</strong>插入一个LoadLoad屏障</p></li><li><p>在每个volatile读操作的<strong>后面</strong>插入一个LoadStore屏障</p></li></ul><p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p><p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图</p><br><h2 id="缓存一致性协议MESI"><a href="#缓存一致性协议MESI" class="headerlink" title="缓存一致性协议MESI"></a>缓存一致性协议MESI</h2><pre><code>多个CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致，不让系统数据混乱，就引出了个一致性的协议MESI</code></pre><br><p><strong>MESI协议缓存状态</strong></p><p>MESI是指4种状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：</p><br><table><thead><tr><th>状态</th><th>描述</th><th>监听任务</th></tr></thead><tbody><tr><td>M修改（Modified）</td><td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中</td><td>缓存行必须时刻监听所有试图读该缓存行写回主存 并将状态变为S(共享）</td></tr><tr><td>E独享、互斥 （Exclusive）</td><td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中</td><td>缓存行也必须监听其它缓存读主存中变成S（共享）状态</td></tr><tr><td>S共享 （Shared）</td><td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中</td><td>缓存行也必须监听其它缓存使该缓存成无效（Invalid）</td></tr><tr><td>I 无效 （Invalid）</td><td>该Cache line无效</td><td>无</td></tr></tbody></table><br><p>==注意==：对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的。如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其他缓存不会广播他们作废掉该缓存行的通知，同样由于该缓存并没有保存该缓存行的copy数量，因此（即使有这样的通知）也没有办法确定自己是否已经独享了该缓存行。</p><pre><code>如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务</code></pre><br><p><strong>缓存行伪共享</strong></p><p>Cpu缓存系统中是以缓存行（cache line）为单位存储的。目前主流的CPU Cache的Cache Line大小都是64bytes.在多线程情况下，如果需要修改“共享在同一个缓存行的变量”，就会无意中影响彼此的性能，这就是伪共享</p><p>例如：现在有2个long型变量a,b ,</p><p>如果有t1在访问a, t2在访问b, 而a与b刚好在同一个cache line中，此时t1先修改a,将导致b被刷新</p><p>Java8中新增了一个注解：@sun.misc.Contended.加上这个注解的类会自动补齐缓存行，需要注意的是此注解默认是无效的，需要在jvm启动时设置-XX:RestrictContended才会生效</p><br><h2 id="MESI优化和他们引入的问题"><a href="#MESI优化和他们引入的问题" class="headerlink" title="MESI优化和他们引入的问题"></a><strong>MESI优化和他们引入的问题</strong></h2><br><pre><code>缓存的一致性消息传递是要时间的，这就使其切换时会产生延迟。当一个缓存被切换状态时，其他缓存收到消息完成各自的切换并且发出回应消息，这么一长串的时间中CPU都会等待所有缓存响应完成。可能出现的的阻塞都会导致各种各样的性能问题和稳定性问题</code></pre><br><p><strong>切换状态阻塞解决——CPU存储缓存（Store Bufferes）</strong></p><pre><code>比如你需要修改本地缓存的一条消息，那么你必须将I（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认，等待确认的过程会阻塞处理器，这会降低处理器性能。因为这个等待远远比上一个指令的执行时间长的多</code></pre><br><p><strong>Store Bufferes</strong></p><pre><code>为了避免这种CPU运算能力的浪费，Store Bufferes（存储缓存）被引入使用。处理器把它想要写入到主存的值，先写到存储缓存，然后继续去处理其他事情。当所有失效确认（Invalidate Acknowledge)都接收到时，数据才会最终被提交</code></pre><p>这样做有两个风险</p><br><p><strong>Store Bufferes的风险</strong></p><p>第一：就是处理器会尝试从存储缓存（Store buffer)中读取值，但它还没有进行提交。这个的解决方案称为Store Foewarding，它使得加载的时候，如果存储缓存中存在，则进行返回。</p><p>第二：保存什么时候会完成，这个并没有任何保证</p><br><p><strong>硬件内存模型</strong></p><p>执行失效也不是一个简单的操作，它需要处理器去处理。另外，存储缓存（Store Buffers）并不是无穷大的，所以处理器有时需要等待失效确认的返回。这两个操作都会使得性能大幅降低。为了应付这种情况，引入了失效队列。他们的约定如下：</p><ul><li> 对于所有的收到的Invalidate请求，Invalidate Acknowlege消息必须立刻发送</li><li> Invalidate并不真正执行，而是被放在一个特殊的队列中，在方便的时候才会去执行</li><li> 处理器不会发送任何消息给所处理的缓存条目，直到它处理Invalidate。即便是这样处理器已经不知道什么时候优化是允许的，而什么时候并不允许，干脆处理器将这个任务丢给了写代码的人。这就是内存屏障</li><li> 写屏障 Store Memory Barrier(a.k.a. ST, SMB, smp_wmb)是一条告诉处理器在执行这之后的指令之前，先执行所有已经在存储缓存（store buffer）中的保存的指令。</li><li> 读屏障Load Memory Barrier (a.k.a. LD, RMB, smp_rmb)是一条告诉处理器在执行任何的加载前，先执行所有已经在失效队列中的失效操作的指令。</li></ul><br><h1 id="Synchronized详解"><a href="#Synchronized详解" class="headerlink" title="Synchronized详解"></a>Synchronized详解</h1><br><h2 id="设计同步器的意义"><a href="#设计同步器的意义" class="headerlink" title="设计同步器的意义"></a>设计同步器的意义</h2><p>多线程编程中，有可能会出现多个线程同时访问同一个共享，可变资源的情况下，这个资源我么称之为临界资源；这种资源可能是：对象、变量、文件等</p><p>共享：资源可以由多个线程同时访问</p><p>可变：资源可以在其生命周期内被修改</p><p>由于线程执行的过程是不可控的，所以需要采用同步机制来协同对对象可变状态的访问</p><br><p>如何解决线程并发安全问题？</p><p>实际上，所有的并发模式在执行线程安全问题时，采用的方案都是序列化访问临界资源。即在同一时刻，只能有一个线程访问临界资源，也称作同步互斥访问</p><p>Java中，提供了两种方式来实现同步互斥访问：synchronized和lock同步器的本质就是加锁目的：序列化访问临界资源，即同一时刻只能有一个线程访问临界资源（同步互斥访问）不过有一点需要区别的是：当多个线程执行一个方法时，该方法内部的局部变量并不是临界资源，因为这些局部变量是在每个线程的私有栈中，因此不具有共享性，不会导致线程安全问题</p><br><h2 id="Synchronized原理详解"><a href="#Synchronized原理详解" class="headerlink" title="Synchronized原理详解"></a>Synchronized原理详解</h2><pre><code>synchronized内置锁是一种对象锁（锁的是对象而非引用），作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的</code></pre><br><p>加锁的方式：</p><p>同步实例方法，锁的是当前实例对象</p><p>同步类方法，锁的是当前类对象（class)</p><p>同步代码块，锁的是括号里面的对象</p><br><h2 id="Synchronized底层原理"><a href="#Synchronized底层原理" class="headerlink" title="Synchronized底层原理"></a>Synchronized底层原理</h2><pre><code>synchronized是基于JVM内置锁实现，通过内部对象Monitor(监视器锁）实现，基于进入与退出Monitor对象实现方法与代码块同步，监视器锁的实现依赖底层操作系统的Mutex lock(互斥锁）实现，它是一个重量级锁，性能较低。当然，JVM内置锁在1.5之后版本做了重大的优化，如锁粗化(Lock Coarsening),锁消除（Lock Elimination）,轻量级锁（Lightweight Locking)、偏向锁（Biased Locking)、适应性自旋（Adaptive Spinning)等技术来减少锁操作的开销，内置锁的并发性能已经基本与Lock持平。Synchronized关键字被编译成字节码后会被翻译成 monitorenter 和monitorexit 两条指令分别在同步块逻辑代码的起始位置与结束位置</code></pre><br><br><p>每个对象都有一个自己的Monitor（监视器锁）</p><br><p><strong>Monitor监视器锁</strong></p><pre><code>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的Monitorenter和Monitorexit指令来实现。</code></pre><p><strong>monitorenter</strong>：每个对象都是一个监视器锁（Monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><ul><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者</li><li>如果该线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1</li><li>如果其他线程占有该monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权</li></ul><br><p><strong>monitorexit</strong>：<br>执行monitorexit的线程必须是object ref对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor,步再是这个monitor的所有者，其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权</p><br><p>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p><br><p>看一个同步方法，例如：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>javap解析后</p><br><img src="/colinstar/colinstar/2022/12/04/JUC/typora-user-images\JMM并发编程\image-20220316144412780.png" alt="image-20220316144412780" style="zoom:150%;"><br><pre><code>从编译的结果来看，方法的同步 并没有 通过指令 monitorenter 和 monitorexit 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED 标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个 monitor对象。两种不同方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间的来回切换，对性能有较大性能</code></pre><br><p><strong>什么是monitor？</strong></p><pre><code>可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的java对象是天生的Monitor，每一个Java对象都有称为Monitor的潜质，因为在java的设计中，每一个Java对象自打娘胎里出来就带了把看不见的锁，它叫做内置锁或者Monitor锁；也就是通常说的Synchronized的对象锁，MarkWord锁标识位为**10**，其中指针指向的是Monitor对象的起始位置；在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor()&#123;</span><br><span class="line">_header = <span class="literal">NULL</span>;</span><br><span class="line">_count = <span class="number">0</span>; <span class="comment">// 记录个数</span></span><br><span class="line">_waiters = <span class="number">0</span>,</span><br><span class="line">_recursions = <span class="number">0</span>;</span><br><span class="line">_object = <span class="literal">NULL</span>;</span><br><span class="line">_owner = <span class="literal">NULL</span>;</span><br><span class="line">_WaitSet = <span class="literal">NULL</span>; <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">_WaitSetLock = <span class="number">0</span> ;</span><br><span class="line">_Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">_succ = <span class="literal">NULL</span> ;</span><br><span class="line">_cxq = <span class="literal">NULL</span> ;</span><br><span class="line">FreeNext = <span class="literal">NULL</span> ;</span><br><span class="line">_EntryList = <span class="literal">NULL</span> ; <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">_SpinFreq = <span class="number">0</span> ;</span><br><span class="line">_SpinClock = <span class="number">0</span> ;</span><br><span class="line">OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code> ObjectMonitor中有两个队列，\_WaitSet 和 \_EntryList，用来保存ObjectWaiter对象列表（每个等待锁的线程都会被封装成ObjectWaiter对象）_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时</code></pre><ol><li>首先会进入_EntryList集合，当线程获取到对象的Monitor后，进入_Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1</li><li>若线程调用wait方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入WaitSet集合中等待被唤醒</li><li>若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁）；同时，Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向),synchronized锁便是通过这种方式获取锁的， 也是为什么java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。</li></ol><p>监视器Monitor有两种同步方式：互斥与协作</p><p>多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问。那么有个问题来了，我们知道synchronized加锁加在对象上，对象是如何记录锁状态的呢？答案是==锁状态是被记录在每个对象的对象头==（Mark Word）中，下面我们一起认识一下对象的内存布局</p><br><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><pre><code>HotSpot虚拟机中，对象在内存中存储的布局分为三块区域：对象头（Header)、示例数据（Instance Data）和对齐填充（Padding）</code></pre><br><br><p><strong>对象头</strong>：比如Hash码，对象GC存活年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象）等。Java对象头一般占有2个机器码（ 在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit ）； 但是如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确定数组的大小，所以用一块来记录数组的长度</p><p><strong>实例数据：</strong>存放类的属性数据信息，包括父类的属性信息</p><p><strong>对齐填充：</strong>由于虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐</p><br><pre><code>HotSpot虚拟机的对象头包括两部分信息，第一部分是&quot;Mark Word&quot;，用于存储对象自身的运行时数据，如哈希码（HashCode），GC分代年龄、锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等等，它是实现轻量级锁和偏向锁的关键。这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别位32个和64个Bits，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示：</code></pre><br><p><strong>32位虚拟机</strong></p><br><br><p><strong>64位虚拟机</strong></p><br><p>现在的虚拟机基本上是64位的，而64位的对象头有点浪费空间，JVM默认会开启指针压缩，所以基本上也是按32位的形式记录对象头的。</p><p>手动设置: -XX:+UseCompressedOops</p><p>哪些信息会被压缩？</p><ol><li>对象的全局静态变量(即类属性)</li><li>对象头信息：64位平台下，原生对象头大小为16字节，压缩后为12字节</li><li>对象的引用类型：64位平台下，引用类型本身大小为8字节，压缩后为4字节</li><li>对象数组类型：64位平台下，数组类型本身大小为24字节，压缩后16字节</li></ol><br><p><strong>对象头分析工具</strong></p><br><p>分析工具JOL，它是OpenJDK开源工具包，maven坐标如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 打印markword</span></span><br><span class="line">System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>打印出来的对象内存信息如下：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line"><span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)  # 此处是Mark Word</span><br><span class="line"><span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"><span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line"><span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure><br><p>第一行为Mark Word    00000001 00000000 00000000 00000000</p><p>会发现与上面的图对比，发现是轻量级锁状态，原因：</p><p><strong>大端模式和小端模式：</strong></p><p>所谓的【大端模式】，是指数据的【低位】保存在内存的【高地址】中，而数据的高位，保存在内存的低地址中；</p><p>所谓的【小端模式】，是指数据的【低位】保存在内存的【低地址】中，而数据的高位保存在内存的高地址中。（大部分的操作系统都是小端，而通讯协议是大端）</p><br><p>因为是小端模式，所以真正的bit位是——&gt;00000000  00000000 00000000  00000001，是无锁状态</p><br><p>然是无锁状态，前25位表示hashcode值，为什么hashcode是0？</p><blockquote><p>因为这个hashcode是jvm内置函数，类似于懒加载，此时还没有计算</p></blockquote><br><p>此时将代码修改为如下：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"><span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>打印的Mark Word为  00011000 11110111 00000010 00000010</p><p>即    00000010 00000010 11110111 00011000</p><p>发现对象头从无锁——&gt;轻量级锁</p><br><p>为什么不是偏向锁？</p><blockquote><p>因为JVM会延迟去启动偏向锁，JVM启动时依赖大量的hashMap class对象等，这些对象里面也存在大量的同步快，JVM启动时内部也会去启动十几个线程，这些线程内部也会存在竞争，JVM为了避免造成 偏向锁 到 轻量级锁 到重量级锁 这种锁升级过程，减少锁升级的开销，所以把偏向锁推迟启动</p></blockquote><br><p>把代码睡眠几秒钟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"><span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line"><span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line"><span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"><span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line"><span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line"><span class="number">0</span>     <span class="number">4</span>        (object header)                           a8 f7 <span class="number">06</span> <span class="number">03</span> (<span class="number">10101000</span> <span class="number">11110111</span> <span class="number">00000110</span> <span class="number">00000011</span>) (<span class="number">50788264</span>)</span><br><span class="line"><span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"><span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line"><span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><p>第一次打印的：00000101 00000000 00000000 00000000  就已经是偏向锁状态了，但是偏向锁的前23bit位会记录线程ID，此处并没有，这种 称之为匿名偏向，可偏向状态</p><br><p>如果一直处于偏向状态，无法重偏向的话，那么MarkWord会一直记录最后一个偏向线程的状态</p><br><h2 id="锁的膨胀升级过程"><a href="#锁的膨胀升级过程" class="headerlink" title="锁的膨胀升级过程"></a>锁的膨胀升级过程</h2><br><pre><code>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁，但是锁的升级是单向的，也就是只能从低到高升级，不会出现锁的降级。从JDK1.6中默认是开启偏向锁和轻量级的，可以通过-XX:-UseBiasedLocking来禁用偏向锁</code></pre><br><p><strong>偏向锁</strong>：</p><pre><code>偏向锁是Java6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁（会涉及到一些CAS操作，耗时）的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提高了程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</code></pre><p>默认开启偏向锁</p><p>开启偏向锁：-XX:+UseBiasedLocking  -XX:BiasedLockingStartupDelay=0</p><p>关闭偏向锁：-XX:-UseBiasedLocking</p><br><p><strong>轻量级锁：</strong></p><pre><code>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时，Mark Word的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</code></pre><br><p><strong>自旋锁：</strong></p><pre><code>    轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程就可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环（这也是称为自旋的原因），一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。后没办法也就只能升级为重量级锁</code></pre><br><p><strong>锁消除：</strong></p><pre><code>    消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。锁消除的依据是逃逸分析的数据支持锁消除，前提是Java必须运行在server模式，（server模式会比client模式作更多的优化），同时必须开启逃逸分析</code></pre><p>-XX:+DoEscapeAnalysis 开启逃逸分析</p><p>-XX:+EliminateLocks  表示开启锁消除</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ol><li>同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li><li>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li><li>分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中</li></ol><br><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><pre><code>Java并发编程核心在于java.concurrent.util包，而juc当中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这个行为的抽象就是基于AbstractQueuedSychronizer简称AQS，AQS定义了一套多线程访问共享资源的同步器框架，是一个依赖状态（state）的同步器。</code></pre><br><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><pre><code>ReentrantLock是一种基于AQS框架的应用实现，是JDK中的一种线程并发访问的同步手段，它的功能类似于synchronized，是一种互斥锁，可以保证线程安全，而且它具有比sychronized更多的特性，比如它支持手动加锁与解锁，支持加锁的公平性</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>); <span class="comment">// false为非公平锁；true为公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>ReentrantLock如何实现sychronized不具备的公平与非公平性呢？</p><p>在ReentranLock内部定义了一个Sync的内部类，该类继承AbstractQueuedSynchronized，对该抽象类的部分方法做了实现；并且还定义了两个子类</p><p>1、FairSync公平锁的实现</p><p>2、NonfairSync非公平锁的实现</p><p>这两个类都继承自Sync，也就是间接继承了AbstractQueuedSynchronized，所以这一个ReentrantLock同时具备公平与非公平特性</p><p>上面设涉及的主要设计模式：模板模式-子类根据需要做具体业务实现</p><br><p>ReentrantLock默认是非公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>AQS具备特性</strong></p><p>阻塞等待队列共享/独占公平/非公平可重入</p><p>允许中断</p><p>除了Lock外，Java.concurrent.util当中同步器的实现Lock,Barrier,BlockingQueue等，都是基于AQS框架实现，一般通过定义内部类Sync继承AQS</p><p>将同步器所有调用都映射到Sync对应的方法</p><ul><li><p>ASQ内部维护属性volatile int state(32位)</p><p>  state表示资源的可用状态</p></li><li><p>State三种访问方式</p><p>  getState()、setState()、compareAndSetState()</p></li><li><p>AQS定义两种资源共享方式</p><p>  Exclusive-独占，只有一个线程能执行，如ReentrantLock</p><p>  Share-共享，多个线程可以同时执行，如Semaphore/CountDownLatch</p></li><li><p>AQS定义两种队列</p></li></ul><p>同步等待队列</p><p>条件等待队列</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源，只有用到condition才需要去实现它</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true,失败则返回false</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false</li><li>tryAcquireShare：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true,否则返回false</li></ul><br><p>AQS类中的内部类Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记结点为独占模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 后继结点的线程处于等待状态，而当前的结点如果释放了同步状态或者被取消，将会通知后继结点，使后继节点的线程得以运行</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 节点在等待队列中，节点的线程等待在Condition上，当其他线程对Condition调用了signal()方法后，</span></span><br><span class="line"><span class="comment">// 该节点会从等待等待中转移到同步队列中，加入到同步状态的获取中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">// 表示下一次共享式同步状态获取将会被无条件地传播下去</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 标记当前代结点的信号量状态（1，0，-1，-2，-3）</span></span><br><span class="line"><span class="comment">* 使用CAS更改状态，volatile保证线程可见性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>acquire方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// arg = 1</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">//  这里如果线程是中断被唤醒的，会返回true，就会走下面的自我中断</span></span><br><span class="line">selfInterrupt();  <span class="comment">// 自我中断 为什么要自我中断呢？因为上面的acquireQueued（）方法返回true代表线程因为中断而唤醒的，但是我们不能直接杀死这个线程；在java以前的版本中，有个Thread.stop方法（现在已经过时）</span></span><br><span class="line"><span class="comment">// 当我们不需要这个线程继续工作时，进行调用，但是这个线程可能正工作一半，这样立即停止可能会出问题，所以就引出来了中断信号，我们可以在后面的代码中，去判断线程是否被中断，来采取措施，例如下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>我们可以自己在代码里进行判断中断信号，而进行优雅的线程退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="keyword">if</span>(Thread.interrupted())&#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// 线程如果是被中断唤醒的话，不走下面的业务逻辑代码( 如果是中断唤醒，selfInterrupt()方法会打上中断标记)</span></span><br><span class="line"><span class="comment">// ps:Thread.interrupted()调用会擦除中断信号，所以需要在selfInterrupt()方法里重新打上标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 业务逻辑代码</span></span><br><span class="line">&#125;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>tryAcquire 方法</strong>：尝试获取资源；如果此时hasQueuedPredecessors()中已经有线程等待，则返回false;上一步就会走 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法。</p><p>addWaiter(Node.EXCLUSIVE) EXCLUSIVE表示独占模式</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123; <span class="comment">// acquires = 1</span></span><br><span class="line"><span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line"><span class="keyword">int</span> c = getState(); <span class="comment">// state状态，没被占用时状态为0</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 判断同步队列中是否有人等待</span></span><br><span class="line">compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//CAS 将state 修改为1</span></span><br><span class="line">setExclusiveOwnerThread(current); <span class="comment">// 设置当前线程为锁的拥有者</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前是锁的拥有者是自己</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>addWaiter方法</strong></p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); <span class="comment">// new 一个Node节点，将模式设为独占模式，里面的thread属性设置为当前线程</span></span><br><span class="line"><span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">Node pred = tail; <span class="comment">// tail标记同步队列尾部节点</span></span><br><span class="line"><span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node); <span class="comment">// 自旋</span></span><br><span class="line"><span class="keyword">return</span> node; <span class="comment">//返回当前节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>enp(node)方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">Node t = tail;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 作者思想是，先初始化队列，头节点和尾节点指向一个 空Node,以免后续出现空指针，方便后续操作</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">tail = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果尾部节点不为空，</span></span><br><span class="line">node.prev = t;   <span class="comment">// 将当前节点的前节点指向 尾部t所指向的节点（也就是最后一个节点）；（当前节点要变成尾节点）</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;  <span class="comment">// 然后cas将tail尾部指针 指向当前节点</span></span><br><span class="line">t.next = node;  <span class="comment">// 将之前旧的尾节点（变化之后现在是倒数第二个节点）的next属性指向当前node</span></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>**acquireQueued(addWaiter(Node.EXCLUSIVE), arg)**方法，尝试加入队列，addWaiter(Node.EXCLUSIVE)方法返回的是当前节点，</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 这一步获取当前的节点的前驱节点</span></span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果前驱节点是head,不会立马加入队列，会让你再次尝试去获取资源，避免阻塞影响性能</span></span><br><span class="line"><span class="comment">// 获取资源成功后</span></span><br><span class="line">setHead(node);   <span class="comment">// head = node;node.thread = null;node.prev = null; 将head头节点指向当前节点，并将当前节点变为空</span></span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">//  原先的头节点 指向断掉，下次GC回收 具体参考下图</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不能获取资源，阻塞等待唤醒</span></span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">parkAndCheckInterrupt())</span><br><span class="line">interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>shouldParkAfterFailedAcquire()方法</strong></p><p>1、第一次循环时会去修改前驱节点的waitStatus= -1， 返回false;</p><p>2、第二次循环，前驱节点已经修改为-1，返回true时，才会走上面的parkAndCheckInterrupt()方法</p><blockquote><p> if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</p></blockquote><br><p>waitStatus控制的是下一个节点</p><p>用前驱节点记录有什么好处？</p><blockquote><p> 当前节点唤醒获取资源后，head指针指向当前Node节点（此时Node节点里thread记录的线程为空）waitState也是0，不需要判断waitState状态,每次都会去修改waitState状态为-1，保证可以唤醒，因为waitState信号量可能为会变（-3）</p></blockquote><br><p>waitState节点的生命状态：信号量</p><blockquote><p>SIGNAL = -1 //可被唤醒</p><p>CANCELLED = 1 // 代表出现异常，中断引起的，需要废弃结束</p><p>CONDITION = -2 // 条件等待</p><p>PROPAGATE = -3 // 传播</p><p>0 — 初始状态Init状态</p></blockquote><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">// 判断前驱节点的waitStatus； waitStatus初始状态都是0</span></span><br><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// Node.SIGNAL = -1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">node.prev = pred = pred.prev;</span><br><span class="line">&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">pred.next = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">// waitStatus=0；所以会走这里，将前驱节点的waitStatus状态改为SIGNAL -1；-1代表可被唤醒</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>waitStatus=0 –&gt; -1 , head节点为什么改到-1，因为持有锁的线程T0在释放锁的时候，会判断head节点的waitStatus是否 !=0 ,如果不等于0，会将head节点的waitStatus改成0；要想唤醒正在排队的第一个线程T1，T1被唤醒后再走acquireQueued（）方法中的循环，再去判断前驱节点是否是头节点，再去拿锁（如果是非公平锁，抢锁是可能失败的）</p><p>if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</p><pre><code>     parkAndCheckInterrupt())            interrupted = true;</code></pre><p>的parkAndCheckInterrupt（）方法</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LockSupport.park(<span class="keyword">this</span>) <span class="comment">// 调用LockSupport的park方法阻塞线程</span></span><br><span class="line"><span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 线程是否被中断，如果线程走到这里是因为中断唤醒的，会返回true,也就是返回线程里的中断信号； 注意： Thread.interrupted()调用会擦除中断信号，所以需要在外面acquires方法里调用selfInterrupt()重新打上中断信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>LockSupport.park阻塞线程(会进入waiting等待状态)。唤醒有两种方式，一种是ReentrantLock里的unlock方法里面，会调用LockSupport.unpark方法唤醒</p><p>另一种就是线程被中断唤醒</p><br><p>Reentrantlock还有一个lockInterruptibly（）方法，跟lock一样能起到同样的效果，只是会抛出编译性异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) <span class="comment">// 一样的尝试获取资源</span></span><br><span class="line">doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>doAcquireInterruptibly(arg)方法</p><p>跟lock里面的逻辑几乎一模一样。只是再parkAndCheckInterrupt()方法里如果是被中断唤醒的，会抛出异常;</p><p>最后走finally的时候呢，failed为true，会走cancelAcquire(node)方法，会在此方法里面将Node节点</p><p>waitStatus改成CANCELLED（也就是1）</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">setHead(node);</span><br><span class="line">p.next = <span class="keyword">null</span>;</span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">parkAndCheckInterrupt())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><br><br></p><h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a><strong>阻塞队列BlockingQueue</strong></h2><pre><code>blockQueue的特性是任意时刻只有一个线程可以进行take或者put操作，并且BlockQueue提供了超时return null的机制，在许多生产场景里都可以看到这个这个工具的身影线程通信的一个工具，在任意时刻，不管并发有多高，在单JVM上，同一时间永远都只有都只有一个线程能够对队列进行入队或者出队操作</code></pre><br><p><strong>队列类型</strong></p><p>1、无限队列（unbounded queue）- 几乎可以无限增长</p><p>2、有限队列（bounded queue）- 定义了最大容量</p><br><p><strong>队列数据结构</strong></p><p>队列实质就是一种存储数据的结构，通常用链表或者数组实现</p><p>一般而言队列具备FIFO先进先出的特性，当然也有双端队列（Deque）优先级队列</p><p>主要操作：入队（EnQueue）与出队（Dequeue)</p><br><br><p>常见的四种阻塞队列</p><ul><li>ArrayBlockingQueue 由数组支持的有界队列</li><li>LinkedBlockingQueue由链接节点支持的可选有界队列</li><li>PriorityBlockingQueue由优先级堆支持的无界优先级队列</li><li>DelayQueue由优先级堆支持的，基于时间的调度队列</li></ul><br><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><strong>ArrayBlockingQueue</strong></h2><br><p>new ArrayBlockingQueue&lt;&gt;(10);</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">lock = <span class="keyword">new</span> ReentrantLock(fair); <span class="comment">// 创建一把锁</span></span><br><span class="line">notEmpty = lock.newCondition(); <span class="comment">// 条件对象</span></span><br><span class="line">notFull =  lock.newCondition(); <span class="comment">// 条件对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">checkNotNull(e);</span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">lock.lockInterruptibly();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (count == items.length) <span class="comment">// 队列满了</span></span><br><span class="line">notFull.await();       <span class="comment">// 释放锁</span></span><br><span class="line">enqueue(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>notFull.await()方法</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Thread.interrupted())  <span class="comment">// 线程被中断,直接抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">Node node = addConditionWaiter(); <span class="comment">// 加入条件等待队列</span></span><br><span class="line"><span class="keyword">int</span> savedState = fullyRelease(node); <span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">interruptMode = REINTERRUPT;</span><br><span class="line"><span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">unlinkCancelledWaiters();</span><br><span class="line"><span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><p>addConditionWaiter()方法</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node t = lastWaiter;</span><br><span class="line"><span class="comment">// If lastWaiter is cancelled, clean out.  判断是不是无效的队列</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">unlinkCancelledWaiters();</span><br><span class="line">t = lastWaiter;</span><br><span class="line">&#125;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">firstWaiter = node;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">t.nextWaiter = node;</span><br><span class="line">lastWaiter = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>fullyRelease(node)方法</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> savedState = getState();  <span class="comment">// 获取锁的信号量</span></span><br><span class="line"><span class="keyword">if</span> (release(savedState)) &#123;<span class="comment">// 释放锁</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> savedState;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">node.waitStatus = Node.CANCELLED;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><pre><code>从字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目，底层依赖AQS的状态state</code></pre><br><h3 id="怎么使用Semaphore"><a href="#怎么使用Semaphore" class="headerlink" title="怎么使用Semaphore"></a>怎么使用Semaphore</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">// state会初始化为5，相当于总的容量池子</span></span><br><span class="line">....</span><br><span class="line">semaphore.acquire(<span class="number">1</span>); <span class="comment">// 从总的池子里拿出一个凭据 state - 1</span></span><br><span class="line">....</span><br><span class="line">semaphore.release(<span class="number">1</span>); <span class="comment">// 将凭据还回总的池子 state  + 1</span></span><br><span class="line"></span><br><span class="line">semaphore.acquire(<span class="number">1</span>);  支持中断式的，如果线程被中断，会抛出异常；semaphore.acquireUninterruptibly()就不会</span><br><span class="line">如果获取信号量之后的逻辑代码执行时间过长，导致其他线程长时间阻塞，消耗资源</span><br><span class="line"></span><br><span class="line">semaphore.tryAcquire(<span class="number">500</span>,TimeUnit.SECONDS);  <span class="comment">// 尝试获取资源并且允许的最大等待时间</span></span><br><span class="line"><span class="keyword">if</span> (semaphore.tryAcquire(<span class="number">500</span>, TimeUnit.MILLISECONDS)) &#123;<span class="comment">// 尝试去获取信号量 ，最长等待500ms</span></span><br><span class="line">System.out.println(Thread.currentThread().getContextClassLoader() + <span class="string">&quot; acquire() at time : &quot;</span> + System.currentTimeMillis());</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">semaphore.release();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 或者返回托底数据</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;获取资源超时&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>源码剖析</strong></p><br><p>Semaphore类中结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>调用new Semaphore(2)时；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">sync = <span class="keyword">new</span> NonfairSync(permits); <span class="comment">// 默认非公平锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  boolean fair 为 true时为公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终会将AQS中的state设置为2</p><br><p>前景：假设两个信号量都被人取完，此时state = 0</p><br><p>再然后我们调用**semaphore.acquire()**时 （ps:以下基于公平锁）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>); <span class="comment">// 默认传1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(); <span class="comment">// 线程如果中断，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)  <span class="comment">// 尝试获取信号量</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg); <span class="comment">// 如果tryAcquireShared返回-1， 会走到下面的2、doAcquireSharedInterruptibly(int arg)方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>1、tryAcquireShared(arg)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123; <span class="comment">// acquires = 1</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors()) <span class="comment">// 判断CLH队列中是否有元素</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果已经有人在排队了，直接返回false</span></span><br><span class="line">        <span class="keyword">int</span> available = getState(); <span class="comment">// 获取AQS中的state</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> || <span class="comment">// 基于上面的场景的话，这里为true,返回-1</span></span><br><span class="line">            compareAndSetState(available, remaining)) <span class="comment">// CAS操作修改state的值，修改失败会自旋</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>2、doAcquireSharedInterruptibly(int arg)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">// 加入CLH队列，共享模式的节点</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">// failed初始值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123; <span class="comment">// 如果当前节点的前驱节点是头节点</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">// 会再次尝试下获取资源</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 如果获取到资源了</span></span><br><span class="line">                        setHeadAndPropagate(node, r); <span class="comment">// 设置头节点，即下面的 setHeadAndPropagate方法</span></span><br><span class="line">                        p.next = <span class="keyword">null</span>;  <span class="comment">// 原先p指向的头节点的指针，可以断开GC了</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 如果当前节点的前驱节点 不是头节点，那么会去修改前驱节点的waitState = -1</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><p>那么此时有两种情况</p><p>第一，当前节点加入队列时，是头节点，并且获取资源成功</p><p>第二，当前节点加入队列时，前面已经有人入队了，或者获取资源失败，那么会尝试阻塞自己</p><p>我们先看第二种情况，节点入队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">parkAndCheckInterrupt())</span><br></pre></td></tr></table></figure><ul><li>shouldParkAfterFailedAcquire()方法</li></ul><p>总的来说，此方法是为了修改前驱节点的waitStatus为SIGNAL， 如果前驱节点的waitStatus已经是Signal,返回true;</p><p>值得注意的是，如果要加入队列，那么上面的doAcquireSharedInterruptibly方法的自旋会走两遍，第一遍循环执行完此方法后，修改前驱节点状态，第二次循环才返回true,然后才会走parkAndCheckInterrupt()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">// ！！！调用 LockSupport.park方法将自己阻塞在这里</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123; <span class="comment">// pred 当前节点的前驱节点，node为当前节点</span></span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">// 获取前驱节点的waitStatus （节点创建时waitStatus默认都为0）</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">// cas去修改前驱节点的waitStatus为SINGAL，即-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么接下来我们看第一种情况，线程发现自己的前驱节点就是头节点，并且尝试获取资源成功了（比如此时有线程归还了信号量，AQS中state由0 ——&gt; 1）</p><p>那么就会走下面的setHeadAndPropagate方法</p><blockquote><p>final Node p = node.predecessor();<br>if (p == head) {<br>int r = tryAcquireShared(arg);<br>if (r &gt;= 0) {<br>    setHeadAndPropagate(node, r);<br>     p.next = null;<br>     failed = false;<br>     return;<br>}<br>}</p></blockquote><ul><li> setHeadAndPropagate方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123; <span class="comment">// node为当前节点，propagate &gt; 1;此处场景下为1</span></span><br><span class="line">    Node h = head; <span class="comment">// h指向旧的头节点</span></span><br><span class="line">    setHead(node); <span class="comment">// 设置当前节点为新的头节点</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> || <span class="comment">// propagate=  1 &gt; 0 ,走下面的逻辑</span></span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next; <span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared()) <span class="comment">// 如果此时后面有新的节点加进来了，走doReleaseShared</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head; <span class="comment">// 获取头节点（此种情况下，头节点就是当前节点，因为上面已经修改过了)</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus; <span class="comment">// 获取头节点waitStatus</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// 如果waitStatus状态是SIGNAL即-1</span></span><br><span class="line">                <span class="comment">// (注意！！新加进来的节点都会去修改前节点的waitStatus为SIGNAL，即上面说的第二种情况的shouldParkAfterFailedAcquire方法)</span></span><br><span class="line">                <span class="comment">// 所以这里的情况ws == Node.SIGNAL为真</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) <span class="comment">// CAS去修改h指向的头节点的waitStatus为0</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 如果修改成功了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)  <span class="comment">// 在某一个线程执行上面方法时，可能会有别的线程加进来，导致头节点变更</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;  <span class="comment">// node 即为上面h所指向的头节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus; <span class="comment">// 此时waitStatus被CAS修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next; <span class="comment">// 获取当前节点的下一节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) <span class="comment">// 如果下一节点不为空，唤醒它</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">// ！！！如果下一节点阻塞在这里，会被唤醒接着进行自旋</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li> <strong>semaphore.release()</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>); <span class="comment">// 默认释放1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// arg = 1</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">// 成功释放返回true</span></span><br><span class="line">        doReleaseShared(); <span class="comment">// 走下面的doReleaseShared()方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> tryReleaseShared(arg)方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState(); <span class="comment">// 获取AQS中的state</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// CAS将信号量还回去</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>doReleaseShared()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">就是上面semaphore.acquire()里面setHeadAndPropagate设置头节点所调用的方法</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeeDoctorTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeeDoctorTask</span><span class="params">(CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;开始看医生&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            log.info(<span class="string">&quot;看医生结束，准备离开病房&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (countDownLatch != <span class="keyword">null</span>)&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SeeDoctorTask(countDownLatch));</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SeeDoctorTask(countDownLatch));</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    log.info(<span class="string">&quot;等待countDownLatch归0&quot;</span>);</span><br><span class="line">    countDownLatch.await(); <span class="comment">// 主线程会阻塞等待，直到上面线程执行完</span></span><br><span class="line">    log.info(<span class="string">&quot;结束.....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier-栅栏"><a href="#CyclicBarrier-栅栏" class="headerlink" title="CyclicBarrier 栅栏"></a>CyclicBarrier 栅栏</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrierRunner</span><span class="params">(CyclicBarrier cyclicBarrier, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;index - &quot;</span> + index);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e)  &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;所有线程执行完毕....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicBarrierRunner(cyclicBarrier,i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ===========上面十个线程冲破栅栏后，会打印&lt;所有线程执行完毕&gt;===========</span></span><br><span class="line">        cyclicBarrier.await(); <span class="comment">// 主线程也算一个</span></span><br><span class="line">        <span class="comment">// ====  如果没有下面的九个线程，那么会一直阻塞，cyclicBarrier可以反复使用==== </span></span><br><span class="line">        System.out.println(<span class="string">&quot;全部到达栅栏&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicBarrierRunner(cyclicBarrier,i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Atomic-amp-Unsafe魔法类详解"><a href="#Atomic-amp-Unsafe魔法类详解" class="headerlink" title="Atomic&amp;Unsafe魔法类详解"></a>Atomic&amp;Unsafe魔法类详解</h2><ul><li><strong>原子操作</strong></li></ul><p>原子（atom)本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation)意为“不可被中断的一个或一系列操作”。</p><p>相关术语</p><table><thead><tr><th>术语名称</th><th>英文</th><th>解释</th></tr></thead><tbody><tr><td>缓存行</td><td>Cache line</td><td>缓存的最小操作单位</td></tr><tr><td>比较并交换</td><td>Compare and Swap</td><td>CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较是否发生变化，如果没有发生变化，才交换成新值，发生</td></tr><tr><td>CPU流水线</td><td>CPU   pipeline</td><td>CPU流水线的工作方式就象工业生产上的装配流水线，在CPU中由5<del>6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5</del>6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期 完成一条指令，因此提高CPU的运算速度。</td></tr><tr><td>内存顺序冲突</td><td>Memory order violation</td><td>内存顺序冲突一般是由假共享引起，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效</td></tr></tbody></table><p><strong>处理器如何实现原子操作</strong></p><p>32位处理器使用<strong>基于对缓存加锁或总线加锁</strong>的方式来实现多处理器之间的原子操作。</p><p><strong>处理器自动保证基本内存操作的原子性</strong></p><p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p><p><strong>使用总线锁保证原子性</strong></p><p>第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写（i++就是经典的读改写操作）操作，那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致</p><p>例子：如果i=1,我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2。如下图</p><p>原因是有可能多个处理器同时从各自的缓存行中读取变量i,分别进行加1操作，然后分别写入系统内存当中。那么想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存</p><p>处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求要求将被阻塞住,那么该处理器可以独占使用共享内存</p><p><strong>使用缓存锁保证原子性</strong></p><pre><code>第二个机制就是通过缓存锁定保证原子性。在同一时刻我们只需保证对某个内存地址的操作是原子性的即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。频繁使用的内存会缓存在处理器的L1,L2和L3高速缓存里，那么原子操作就可以直接在处理器内存缓存中进行，并不需要声明总线锁。在奔腾6和最近的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效，在上述例子中，当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。但是有两种情况下处理器不会使用缓存锁定。第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行，则处理器会调用总线锁定。第二种情况是：有些处理器不支持缓存锁定。</code></pre><p>以上两个机制我们可以通过Inter处理器提供了很多Lock前缀的指令来实现。比如位测试和修改指令BTS，BTR，BTC，交换指令XADD，CMPXCHG和其他一些操作数和逻辑指令，比如ADD(加），OR(或）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问他</p><p><strong>Java当中如何实现原子操作</strong></p><p>在Java中可以通过锁和循环CAS的方式来实现原子操作</p><p>JVM中的CAS操作正式利用了上文中提到的处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环CAS操作直到操作成功为止。</p><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><pre><code>在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新数组，原子更新引用和原子更新字段。Atomic包里的类基本都是使用Unsafe实现的包装类</code></pre><p>基本类：AtomicInteger，AtomicLong，AtomicBoolean;</p><p>引用类型：AtomicReferernce、AtomicReference的ABA实例、AtomicStampedRerence、AtomicMarkableReference；</p><p>数组类型：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><p>属性原子修改器（Updater）：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</p><p>atomic底层实现是基于Unsafe提供的三大cas-api完成；而Unsafe基于硬件原语-CMPXCHG实现原子操作cas</p><ul><li>compareAndSwapObject</li><li>compareAndSwapInt</li><li>compareAndSwapLong</li></ul><p>AtomicInteger的getAndIncrement()方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2); <span class="comment">// 读取AtomicInteger里的value值（AtomicInteger有个value属性）</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="comment">// var1 -- AtomicInteger</span></span><br><span class="line">    <span class="comment">// var2 -- valueOffset  value属性在对象内存当中的偏移量</span></span><br><span class="line">    <span class="comment">// var3 -- oldValue</span></span><br><span class="line">    <span class="comment">// var5 + var4 -- oldValue + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CAS的ABA问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestABA</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line"><span class="keyword">int</span> a = atomicInteger.get();</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot;操作前的数值&quot;</span>+a);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> res = atomicInteger.compareAndSet(a, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (res)&#123;</span><br><span class="line">log.info(Thread.currentThread().getName()+ <span class="string">&quot; cas操作后的数值 &quot;</span>+atomicInteger.get());</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">log.info(<span class="string">&quot;修改失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line">atomicInteger.incrementAndGet();</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot; increase后的值 &quot;</span>+ atomicInteger.get());</span><br><span class="line"><span class="keyword">int</span> j = atomicInteger.decrementAndGet();</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot; decrease后的值 &quot;</span>+ atomicInteger.get());</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">countDownLatch.await();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么解决ABA问题？</p><p>加上版本号 。A（0）- B（1）- A（2）</p><p>如果关注过程，就可以用AtomicStampedReference，AtomicStampedReference接口有一个版本号参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABASloution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference =</span><br><span class="line"><span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">int</span> stamp = atomicStampedReference.getStamp(); <span class="comment">// 获取当前标识</span></span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot; stamp = &quot;</span> + stamp + <span class="string">&quot; 初始值 = &quot;</span> + atomicStampedReference.getReference() );</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> b = atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">2</span>,stamp,++stamp);</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot; stamp = &quot;</span> + stamp + <span class="string">&quot; cas操作结果: &quot;</span> + b);</span><br><span class="line"></span><br><span class="line">&#125;,<span class="string">&quot;t0&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread( () -&gt; &#123;</span><br><span class="line"><span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">atomicStampedReference.compareAndSet(<span class="number">1</span>,<span class="number">2</span>,stamp,++stamp);</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot; stamp = &quot;</span> + atomicStampedReference.getStamp() +</span><br><span class="line"><span class="string">&quot; increment 值: &quot;</span> + atomicStampedReference.getReference());</span><br><span class="line">stamp = atomicStampedReference.getStamp();</span><br><span class="line">atomicStampedReference.compareAndSet(<span class="number">2</span>,<span class="number">1</span>,stamp,++stamp);</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot; stamp = &quot;</span> + atomicStampedReference.getStamp() +</span><br><span class="line"><span class="string">&quot; decrease 值: &quot;</span> + atomicStampedReference.getReference());</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">System.in.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unsafe应用解析"><a href="#Unsafe应用解析" class="headerlink" title="Unsafe应用解析"></a>Unsafe应用解析</h3><pre><code>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。Unsafe类为一单例实现，提供静态方法getUnsafge获取Unsaefe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常</code></pre><p><strong>如何获取Unsafe实例？</strong></p><p>1、从getUnsafe方法的使用限制条件出发，通过Java命令 -Xbootclasspath/a 把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得该类A被 引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例</p><blockquote><p>java ­Xbootclasspath/a:${path}         // 其中path为调用Unsafe相关方法的类所在jar包路径</p></blockquote><p>2、通过反射获取单例对象theUnsafe</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">reflectGetUnsafe</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Class&lt;Unsafe&gt; unsafeClass = Unsafe.class;</span><br><span class="line">Field theUnsafe = unsafeClass.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span> (Unsafe)theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Unsafe功能介绍</strong></p><pre><code>unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类</code></pre><br><br><h4 id="1、内存操作"><a href="#1、内存操作" class="headerlink" title="1、内存操作"></a>1、内存操作</h4><p>这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法</p><ul><li>分配内存, 相当于C++的malloc函数 public native long allocateMemory(long bytes);</li><li>扩充内存 public native long reallocateMemory(long address, long bytes);</li><li>释放内存 public native void freeMemory(long address);</li><li>在给定的内存块中设置值 public native void setMemory(Object o, long offset, long bytes, byte value);</li><li>内存拷贝 public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);</li><li>获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等 public native Object getObject(Object o, long offset);</li><li>为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有:putInt,putDouble，putLong，putChar等 public native void putObject(Object o, long offset, Object x); public native byte getByte(long address);</li><li>为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配 时，此方法结果才是确定的） public native void putByte(long address, byte x);</li></ul><br><p>通常我们在Java中创建的对象都处于堆内内存（heap)中，堆内内存是由JVM所掌控的Java进程内存，并且他遵循JVM的内存管理机制，JVM采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法</p><br><p><strong>使用堆外内存的原因</strong></p><ol><li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在GC时减少回收停顿对于应用的影响</li><li>提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存</li></ol><br><p><strong>典型应用</strong></p><pre><code>DirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty,MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外，使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。DirectByteBuffer构造函数、创建DirectBuffer的时候，通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放</code></pre><img src="/colinstar/colinstar/2022/12/04/JUC/typora-user-images\JMM并发编程\image-20220316164537308.png" alt="image-20220316164537308" style="zoom:150%;"><br><h4 id="2、线程调度"><a href="#2、线程调度" class="headerlink" title="2、线程调度"></a><strong>2、线程调度</strong></h4><p>包括线程挂起、恢复、锁机制等方法</p><p>// 取消阻塞线程</p><p>public native void unpark(Object thread);</p><p>// 阻塞线程</p><p>public native void park(boolean isAbsolute,long time);</p><p>//获得对象锁（可重入）</p><p>@Deprecated</p><p>public native void monitorEnter(Object o);</p><p>//释放对象锁</p><p>@Deprecated</p><p>public native void monitorExit(Object o);</p><p>//尝试获取对象锁</p><p>@Deprecated</p><p>public native boolean tryMonitorEnter(Object o);</p><p>方法park，unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现；</p><p>unpark可以终止一个挂起的线程，使其恢复正常</p><br><h4 id="3、内存屏障"><a href="#3、内存屏障" class="headerlink" title="3、内存屏障"></a>3、内存屏障</h4><p>在Java 8中引入，用于定义内存屏障（也叫内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才开始执行此点之后的操作），避免代码重排序</p><br><p>// 内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</p><p>public native void loadFence();</p><br><p>// 内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</p><p>public native void storeFence();</p><br><p>//内存屏障，禁止load，store操作重排序</p><p>public  void fullFence();</p><br><p><strong>典型应用</strong></p><pre><code>在Java8中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程”饥饿“现象由于StampedLock提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存load到线程工作内存时，会存在数据不一致问题，所以当使用StampedLock的乐观读锁时，需要遵从如下图用例中使用的模式来确保数据的一致性</code></pre><br><p>如上图用例所示计算坐标点Point对象，包含点移动方法move及计算此点到原点的距离的方法distanceFromOrigin。在方法distanceFromOrigin中，首先，通过 tryOptimisticRead方法获取乐观读标记；然后从主内存中加载点的坐标值 (x,y)；而后通过</p><p>StampedLock的validate方法校验锁状态，判断坐标点(x,y)从主内存加载到线程工作内存过程中，主内存的值是否已被其他线程通过move方法修改，如果validate返回值为true，证明(x, y)的值未被修改，可参与后续计算；否则，需加悲观读锁，再次从主内存加载(x,y)</p><p>的  新值，然后再进行距离计算。其中，校验锁状态这步操作至关重要，需要判断锁状态是否发生改变，从而判断之前copy到线程工作内存中的值是否与主内存的值存在不一致。</p><br><h2 id="Collections之Map-amp-List-amp-Set"><a href="#Collections之Map-amp-List-amp-Set" class="headerlink" title="Collections之Map&amp;List&amp;Set"></a>Collections之Map&amp;List&amp;Set</h2><br><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>数据结构</p><p>数组+链表（红黑树JDK&gt;=8)</p><p><strong>源码分析</strong></p><p>重要成员变量</p><ul><li>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // hash表默认初始容量</li><li>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // hash表</li><li>static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认的加载因子</li><li>static final int TREEIFY_THRESHOLD = 8; // 链表转红黑树阈值</li><li>static final int UNTREEIFY_THRESHOLD = 6; // 红黑树转链表阈值</li><li>static final int MIN_TREEIFY_CAPACITY = 64; // 链表转红黑树时hash表最小容量阈值，达不到优先扩容</li></ul><p>HashMap时线程不安全的，不安全的具体原因就是在高并发场景下，扩容可能产生死锁（jdk1.7存在）以及get操作可能带来的数据丢失</p><br><h4 id="Jdk7——扩容死锁分析"><a href="#Jdk7——扩容死锁分析" class="headerlink" title="Jdk7——扩容死锁分析"></a><strong>Jdk7——扩容死锁分析</strong></h4><p>死锁问题核心在于下面代码，多线程扩容导致形成的链表环</p><br><p>key,hashCode通过位运算 获取数组下标，会产生hash碰撞，采用头插法 插入链表</p><br><p>针对以下代码分析源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Object, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">hashMap.put(<span class="string">&quot;2021&quot;</span>, <span class="string">&quot;colin&quot;</span>);</span><br></pre></td></tr></table></figure><br><ul><li> new HashMap&lt;&gt;(11)时</li></ul><p>构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123; <span class="comment">// 此处initialCapacity= 11 ,loadFactor =  DEFAULT_LOAD_FACTOR = 0.75f</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) <span class="comment">// 如果初始值大小大于最大容量，将他赋值为最大值</span></span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor; <span class="comment">// 加载因子赋值</span></span><br><span class="line">    threshold = initialCapacity; <span class="comment">//  threshold = 11</span></span><br><span class="line">    init(); <span class="comment">// 空方法，什么都没有，java.util.LinkedHashMap对此方法进行了重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li> hashMap.put方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123; <span class="comment">// 如果数组为空，则进行初始化</span></span><br><span class="line">        inflateTable(threshold); <span class="comment">// threshold = 11（构造函数里赋值）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key); <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length); <span class="comment">// 计算索引</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">// 遍历数组索引处所在的链表</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; <span class="comment">// 如果当前节点的key等于put的key,将其替换</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">// 加入节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.1 inflateTable(threshold) 初始化数组 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123; <span class="comment">// toSize = 11</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize); <span class="comment">// 计算出toSize的最小2次幂(即&gt;=size，并且使2的指数倍)。计算出来的就是hashMap数组的容量</span></span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>); <span class="comment">// threshold阈值 = 当前容量 * 加载因子 / MAXIMUM_CAPACITY + 1 取最小的</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity]; <span class="comment">//</span></span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.1.1 roundUpToPowerOf2方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123; <span class="comment">// number == 11</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line"></span><br><span class="line">        ? MAXIMUM_CAPACITY</span><br><span class="line"></span><br><span class="line">        : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.1.1.1 highestOneBit方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// i = 11 &lt;&lt; 1 = 26</span></span><br><span class="line">i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">i |= (i &gt;&gt; <span class="number">16</span>);  <span class="comment">// 以上操作都是把二进制的低位变成1</span></span><br><span class="line"><span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i |= (i &gt;&gt; 1)</p><p>i = 0001 1010 向右移1位 变成 0000 1101，然后二者进行或运算</p><p>0001 1010</p><pre><code>     或运算               ——&gt; 0001 1111</code></pre><p>0000 1101</p><p>后面的同理，目的是把低位全变成1，最后的 i就等于 0001 1111，即31 然后 return i - (i &gt;&gt;&gt; 1)</p><p>i &gt;&gt;&gt; 1 , 无符号右移1位，忽略符号位，空位都以0补齐。变成 0000 1111，即等于7，最后return 31 -15 = 16</p><ul><li>1.2 indexFor 计算索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123; <span class="comment">// hash, table.length</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要length -1，因为table.length是2的指数次幂，所以length的二进制只会是2的整数倍，如0000 1000，0010 0000 这样子的</p><p>而hash值是随机的，所以，如果不减1，那么进行与运算的结果就只有两种，一个就是lenth本身，一个是0；那么元素放置在数组的位置就只有两个了，还会越界</p><p>length 减去1，那么length低位全变成1，与hash进行与运算得到的结果只会是0-length-1范围里面</p><ul><li>1.3 addEntry节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123; <span class="comment">// hash - 计算出来的hash值  bucketIndex -- 计算出来的索引</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;  <span class="comment">// 如果当前大小 大于等于 阈值  并且 当前数组索引处不为空，则进行扩容</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);   <span class="comment">// 扩容为当前数组长度的两倍，因为长度需要是2的指数次幂 </span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.3.1 resize扩容方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123; <span class="comment">// newCapacity = 2 * table.length</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity)); <span class="comment">// 将旧数据转移到新hashTable</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.3.1.1 transfer——转移数据</li></ul><p>多线程情况下会产生环形链表，死锁</p><p><a href="https://www.processon.com/diagraming/5eda27f7e0b34d4139010c23">https://www.processon.com/diagraming/5eda27f7e0b34d4139010c23</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<span class="comment">// 外层循环是数组</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;    <span class="comment">// 内层循环的是数组节点的上链表 </span></span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">// 重新计算hash</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么加载因子loadfactor是0.75？</strong></p><p>HashMap类上面的源码注释已经给出了答案；</p><p>一般来说，默认负载系数（0.75）在时间和空间成本之间 提供了一个很好的折中方案。较高的值会减少空间开销，但会增加查找成本，反映在HashMap类，包括get和put。这个应采用映射中的预期条目数及其加载系数 在设置其初始容量时应予以考虑，以尽量减少再灰化操作的数量。如果初始容量更大大于最大条目数除以负载系数，再灰化作业将永远不会发生。</p><p>基于牛顿二项式，算出来折中考虑</p><p>HashMap8的扩容方法，完全绕开了rehash重新计算hash的方法，采用高低位指针</p><h4 id="JDK8中的HashMap"><a href="#JDK8中的HashMap" class="headerlink" title="JDK8中的HashMap"></a>JDK8中的HashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造，只是赋予了默认了加载因子0.75f</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hash（）计算hash值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 刚开始put时，成员属性table为null</span></span><br><span class="line">        n = (tab = resize()).length; <span class="comment">// resize()方法初始化hashMap， n = 16</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// i = (n - 1) &amp; hash 计算索引，n=table.length，长度-1跟jdk7一样保证索引落在0-15以内</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// new 一个 Node节点，并放在数组索引处</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 如果索引处已经有元素了，添加到链表上</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 如果key相等。p为数组索引处第一个节点</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// TreeNode是Node的子类</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">// 如果p下一个节点为null (p为数组索引处第一个节点)</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 【尾插法】插入链表</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// TREEIFY_THRESHOLD = 8. 如果长度大于8</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">// 转红黑树或者扩容</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 如果key相同，break</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 将旧值替换并返回</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>resize()初始化，下面只贴出初始化会走的逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// oldCap = 0</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold; <span class="comment">// oldThr = 0</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ....<span class="comment">// 初始化不会走这里</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)  <span class="comment">// false</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">// 默认初始容量16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// 默认加载因子0.75 * 16 = 12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">// false</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// threshold = 12</span></span><br><span class="line">    Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node[newCap]; <span class="comment">// new Node[16]</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123; <span class="comment">// false</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab; <span class="comment">// 返回初始化的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>treeifyBin()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="comment">// 如果table.length &lt; MIN_TREEIFY_CAPACITY = 64,则进行扩容</span></span><br><span class="line">        resize(); <span class="comment">// 扩容方法（也就是初始化时调的方法）我们下面回过头看扩容的逻辑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">// 否则将链表转为红黑树</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>resize()扩容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CountcurrentHashMap"><a href="#CountcurrentHashMap" class="headerlink" title="CountcurrentHashMap"></a>CountcurrentHashMap</h3><ul><li>数据结构</li></ul><p>ConcurrentHashMap的数据结构与HashMap基本类似，区别在于：</p><p>1、内部在数据写入时加入了同步机制（分段锁）保证线程安全，读操作是无锁操作；</p><p>2、扩容时老数据的转移是并发执行的，这样扩容的效率更高。</p><ul><li>并发安全控制</li></ul><p>Java7ConcurrentHashMap基于ReentrantLock实现分段锁</p><blockquote><p>Java8中ConcurrentHashMap基于分段锁+CAS保证线程安全，分段锁基于synchronized关键字实现</p></blockquote><ul><li>源码分析</li></ul><p><strong>重要成员变量</strong></p><ul><li><p>LOAD_FACTOR：负载因子，默认0.75，当table使用率达到75%时，为了减少table的hash碰撞，table长度将扩容一倍。</p></li><li><p>TREEIFY_THRESHOLD:  默认为8，当链表长度大于8时，将链表转变成红黑树</p></li><li><p>UNTREEIFY_THRESHOLD：默认为6，红黑树转变为链表的阈值</p></li><li><p>MIN_TRANSFER_STRIDE：默认为16，table扩容时，每个线程最少迁移table的槽位个数</p></li><li><p>MOVED：值为-1，当Node.hash为MOVED时，代表着table正在扩容</p></li><li><p>THEEBINl：值为-2,代表此元素后接红黑树</p></li><li><p>nextTable：table迁移过程临时变量，在迁移过程中将元素全部迁移到nextTable上。</p></li><li><p>sizeCtl：用来标志table初始化和扩容的，不同的取值代表着不同的含义</p></li></ul><p>0：table还没有初始化</p><p>-1：table正在初始化</p><p>小于-1：实际值为 resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT + 2，表明table正在扩容</p><p>大于0：初始化完成后，代表table最大存放元素的个数，默认为0.75*n （代码中写法为：sc = n - (n &gt;&gt;&gt; 2);sizeCtl = sc）</p><ul><li><p>transferIndex：table容量从n扩到2n时，是从索引n-1的元素开始迁移，transferIndex代表当前已经迁移的元素下标</p></li><li><p>ForwardingNode：一个特殊的Node节点，其hashCode=MOVED，代表着此时table正在做扩容操作。扩容期间，若table某个元素为null，那么该元素设置为ForwardingNode，当下个线程向这个元素插入数据时，检查hashcode=MOVED，就会帮着扩容</p></li></ul><p>ConcurrentHashMap由三部分构成，table+链表+红黑树，其中table是一个数组，既然是数组，必须要在使用时确定数组的大小，当table存放的元素过多时，就需要扩容，以减少碰撞发生次数</p><p><strong>源码分析</strong></p><ul><li>无参构造</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参构造</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">MAXIMUM_CAPACITY :</span><br><span class="line">tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>put方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>putVal方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode()); <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;  <span class="comment">// 循环时为了考虑并发情况，如：多个线程去初始化时只能有一个初始化</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable(); <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// 如果此时正在扩容。ps:扩容的时候会将链表首节点包装成ForwardingNode，并用nextTable指向原table</span></span><br><span class="line">            tab = helpTransfer(tab, f); <span class="comment">// 帮忙迁移扩容</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> initTable初始化方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123; <span class="comment">// cas去修改sizeCtl的值为-1，多个线程去修改的话，会出现失败情况，失败的继续走循环</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;  <span class="comment">// 为什么还要判断一次？因为失败的第二次循环去修改时，也会可能成功</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY; <span class="comment">// SC在有参构造时会赋值，不然默认为0；DEFAULT_CAPACITY = 16</span></span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 即0.75*n， 代表table最大存放元素的个数，</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>helpTransfer帮助扩容方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length); <span class="comment">// 根据length得到一个标识符号</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123; <span class="comment">// 说明还在扩容</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                <span class="comment">// 达到最大的帮助线程 || 判断扩容转移下标是否在调整（扩容结束）</span></span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// cas修改sizectl + 1, 表示增加了一个线程帮助其扩容</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>transfer扩容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range 每个线程最小迁移16个槽位 </span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p><strong>CopyOnWrite机制</strong></p><p>核心思想：读写分离，空间换时间，避免为保证并发安全而导致的激烈的锁竞争</p><ul><li>CopyOnWrite适用于读多写少的情况，最大程度的提高读的效率</li><li>CopyOnWrite是最终一致性，在写的过程中，原有读的数据是不会发生更新的，只有新的读才能读到最新数据</li><li>如何使其他线程能过够及时读到新的数据，需要使用volatile修饰</li><li>写的时候不能并发写，需要对写操作进行加锁</li></ul><p><strong>源码分析</strong></p><p>add（）方法，写时复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">// 复制一个array副本,并且长度为原先的加1</span></span><br><span class="line">        newElements[len] = e; <span class="comment">// 往副本里写入新元素</span></span><br><span class="line">        setArray(newElements); <span class="comment">// 副本替换原本，成为新的原本</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> get(getArray(), index); <span class="comment">// 无锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Executor线程池原理"><a href="#Executor线程池原理" class="headerlink" title="Executor线程池原理"></a>Executor线程池原理</h1><p>线程是调度CPU资源的最小单位，线程模型分为KLT模型与ULT模型，JVM使用的KLT模型，Java线程与OS线程保持1：1的映射关系，也就是说有一个Java线程也会在操作系统里有一个对应的线程，Java线程有多种生命状态，被定义在java.lang.Thread.State</p><ul><li>NEW：新建</li><li>RUNNABLE：运行</li><li>BLOCKED：阻塞</li><li>WAITING：等待</li><li>TIMED_WAITING：超时等待</li><li>TERMINATED：终结</li></ul><p><strong>协程</strong></p><pre><code>协程（纤程，用户级线程），目的是为了追求最大力度的发挥硬件性能和提升软件的速度，协程基本原理是：在某个点挂起当前的任务，并且保存栈信息，去执行另一个任务；等完成或达到某个条件时，再还原原来的栈信息并继续执行（整个过程线程不需要上下文切换）</code></pre><p>Java原生不支持协程，在纯java代码里需要使用协程的话需要引入第三方包，如：quasar</p><p><strong>线程池</strong></p><p>线程是稀缺资源，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此Java中提供线程池对线程进行统一分配、调优和监控线程池</p><p>在web开发中，服务器需要接收并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都创建一个线程的话实现起来非常简便，但是存在一个问题，如果并发请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的资源要比处理实际的用户的时间和资源更多</p><p>线程池的目的就是执行完一个任务，线程并不被销毁，而是可以继续执行其他的任务。</p><p>什么时候使用线程池?</p><ol><li>单个任务处理时间比较长</li><li>需要处理的任务数量很大</li></ol><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>Executor接口是线程池框架中最基础的部分，定义了一个用于执行Runnable的execute方法</p><p>Executor有一个重要子接口ExecutorService，其中定义了线程池的具体行为</p><p>1、execute（Runnable command）：履行Runnable类型的任务</p><p>2、submit（task）：可以来提交Callable或Runnable任务，并返回代表此任务的Future对象</p><p>3、shutdown（）：在完成已提交的任务后封闭办事，不再接管新任务</p><p>4、shutdownNow（）：停止所有正在履行的任务并封闭办事</p><p>5、isTerminated（）：测试是否所有任务都履行完毕了</p><p>6、isShutdown（）：测试是否该ExecutorService已被关闭</p><h2 id="线程池的五种状态"><a href="#线程池的五种状态" class="headerlink" title="线程池的五种状态"></a>线程池的五种状态</h2><ul><li><p>private static final int COUNT_BITS = Integer.SIZE - 3; // 29</p></li><li><p>private static final int CAPACITY  = (1 &lt;&lt; COUNT_BITS) - 1; // 1 &lt;&lt; 29 - 1 = 2 ^ 29 - 1 即 0000 1111 … 1111</p></li></ul><p>// 位图，高三位记录线程池状态，后29位记录线程数量</p><ul><li><p>private static final int RUNNING  = -1 &lt;&lt; COUNT_BITS; // 101 0 0000 …. 0000</p></li><li><p>private static final int SHUTDOWN  = 0 &lt;&lt; COUNT_BITS; // 000 0 0000 …. 0000</p></li><li><p>private static final int STOP    = 1 &lt;&lt; COUNT_BITS; // 001 0 0000 …. 0000</p></li><li><p>private static final int TIDYING  = 2 &lt;&lt; COUNT_BITS; // 010 0 0000 …. 0000</p></li><li><p>private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // 011 0 0000 …. 0000</p></li></ul><p><strong>RUNNING</strong></p><p>状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务处理</p><p>状态切换：线程池的初始化状态是RUNNING。换句话说，线程池一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0；</p><p><strong>SHUTDOWN</strong></p><p>状态说明：线程池处在SHUTDOWN状态时，不接受新任务，但能处理已添加的任务。</p><p>状态切换：调用线程池的shutdown（）接口时，线程池由RUNNING ——&gt; SHUTDOWN</p><p><strong>STOP</strong></p><p>状态说明：线程池处在STOP状态时，不接受新任务，不处理已添加的任务，并且会中断正在处理的任务</p><p>状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN) ——&gt; STOP</p><p><strong>TIDYING</strong></p><p>tidying 英 [ˈtaɪdiɪŋ]  美 [ˈtaɪdiɪŋ] v.使整洁;使整齐 ;使有条理;整理</p><p>状态说明：当所有的任务已终止，ctl记录的“任务数量”为0，线程池会变为tidying状态。当线程池变为tidying状态时，会执行钩子函数terminated()。</p><blockquote><p>terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现</p></blockquote><p>状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由SHUTDOWN ——&gt; TIDYING。当线程池在STOP状态下，线程池中执行任务为空时，就会由STOP ——&gt; TIDYING</p><p><strong>TERMINATED</strong></p><p>状态说明：线程池彻底终止，就变成TERMINATED状态</p><p>状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由TIDYING ——&gt; TERMINATED</p><p>进入TERMINATED的条件如下：</p><ul><li>线程池不是RUNNING状态</li><li>线程池状态不是TIDYING状态或TERMINATED</li><li>如果线程池状态是SHUTDOWN并且workerQuere为空</li><li>workerCount为0</li><li>设置TIDYING状态成功</li></ul><p>构造函数（全参），入参如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maximumPoolSize, <span class="comment">// 最大线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> keepAliveTime, <span class="comment">// 最大允许线程不干活的时间</span></span><br><span class="line"></span><br><span class="line">TimeUnit unit, <span class="comment">// 时间单位</span></span><br><span class="line"></span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">// 存放未来得及执行的任务</span></span><br><span class="line"></span><br><span class="line">ThreadFactory threadFactory, <span class="comment">// 创建线程的工厂</span></span><br><span class="line"></span><br><span class="line">RejectedExecutionHandler handler <span class="comment">// 拒绝策略</span></span><br></pre></td></tr></table></figure><ul><li>corePoolSize</li></ul><p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；继续提交的任务将被保存在阻 塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程</p><ul><li>maxinumPoolSize</li></ul><p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maxinumPoolSize</p><ul><li>keepAliveTime</li></ul><p>线程池维护线程所允许的空闲时间，当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime</p><ul><li>unit</li></ul><p>指定keepAliveTime的时间单位</p><ul><li>workQueue</li></ul><p>用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</p><p>1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务</p><p>2、LinkedBlockingQueue：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue</p><p>3、SychronousQueue：一个不存储元素的阻塞队列，每个插入操作一直处于阻塞队列，吞吐量通常要高于LinkedBlockingQueue</p><p>4、priorityBlockingQueue：具有优先级的无界阻塞队列；</p><ul><li>threadFactory</li></ul><p>它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory()来创建新线程</p><p>使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称</p><ul><li>handler</li></ul><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种拒绝策略</p><ul><li>AbortPolicy：默认的策略，直接抛出异常；</li><li>CallerRunsPolicy：用调用者所在的线程自己来执行任务</li><li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务</li><li>DiscardPolicy：直接丢弃任务；</li></ul><p>上面的四种策略都是ThreadPoolExecutor的内部类,也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务</p><img src="/colinstar/2022/12/04/JUC/image-20220316173838924.png" class>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;冯诺依曼计算机&quot;&gt;&lt;a href=&quot;#冯诺依曼计算机&quot; class=&quot;headerlink&quot; title=&quot;冯诺依曼计算机&quot;&gt;&lt;/a&gt;冯诺依曼计算机&lt;/h1&gt;&lt;h2 id=&quot;计算机五大核心组成部分&quot;&gt;&lt;a href=&quot;#计算机五大核心组成部分&quot; class=&quot;he</summary>
      
    
    
    
    <category term="JUC" scheme="http://c89757.gitee.io/colinstar/categories/JUC/"/>
    
    
    <category term="JUC" scheme="http://c89757.gitee.io/colinstar/tags/JUC/"/>
    
    <category term="多线程" scheme="http://c89757.gitee.io/colinstar/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://c89757.gitee.io/colinstar/2022/12/04/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://c89757.gitee.io/colinstar/2022/12/04/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-12-04T14:30:07.000Z</published>
    <updated>2022-12-04T15:52:29.612Z</updated>
    
    <content type="html"><![CDATA[<p>​    volatile比synchroized的执行成本更低，因为他不会引起线程上下文的切换和调度。</p><p>​    在对volatile变量进行写操作时，JIT编译器生成的汇编指令处，会有一个lock指令。Lock前缀的指令在多核处理器下会引发两件事：</p><ol><li>将当前处理缓存行的数据写回系统内存</li><li>这个写回内存的操作会使其他CPU里缓存了该内存地址的数据无效</li></ol><blockquote><p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1、L2或其他）后，再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回内存，其他处理器缓存的值还是旧值，就会有问题。所以，在多处理器下，为了保证各个处理器的缓存时一致的，就会实现缓存一致性协议，每个处理通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p></blockquote><p><strong>LOCK前缀指令会引起处理器缓存回写主存</strong>：LOCK前缀指令会确保当前处理器可以独占共享内存（会锁住总线，导致其他cpu不能访问总线，不能访问总线就意味着不能访问系统内存）。但是，在最近的处理器里，一般不锁总线，锁总线开销大，而是锁缓存行。</p><p><strong>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</strong>：处理器会使用MESI控制协议去维护内存缓存和其他处理器缓存的一致性。通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    volatile比synchroized的执行成本更低，因为他不会引起线程上下文的切换和调度。&lt;/p&gt;
&lt;p&gt;​    在对volatile变量进行写操作时，JIT编译器生成的汇编指令处，会有一个lock指令。Lock前缀的指令在多核处理器下会引发两件事：&lt;/p&gt;</summary>
      
    
    
    
    <category term="JUC" scheme="http://c89757.gitee.io/colinstar/categories/JUC/"/>
    
    
    <category term="JUC" scheme="http://c89757.gitee.io/colinstar/tags/JUC/"/>
    
    <category term="多线程" scheme="http://c89757.gitee.io/colinstar/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>mysql查看事务加锁情况</title>
    <link href="http://c89757.gitee.io/colinstar/2022/11/30/mysql%E6%9F%A5%E7%9C%8B%E4%BA%8B%E5%8A%A1%E5%8A%A0%E9%94%81%E6%83%85%E5%86%B5/"/>
    <id>http://c89757.gitee.io/colinstar/2022/11/30/mysql%E6%9F%A5%E7%9C%8B%E4%BA%8B%E5%8A%A1%E5%8A%A0%E9%94%81%E6%83%85%E5%86%B5/</id>
    <published>2022-11-30T14:28:17.000Z</published>
    <updated>2022-11-30T15:34:33.540Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>information_schema</code>数据库中，有几个与事务和锁紧密相关的表。</p><h1 id="INNODB-TRX"><a href="#INNODB-TRX" class="headerlink" title="INNODB_TRX"></a>INNODB_TRX</h1><p>该表存储了InnoDB存储引擎当前正在执行的事务信息，包括事务id（如果没有为该事务分配唯一的事务id，则会输出该事务对应的内存结构的指针）、事务状态（事务是正在运行还是等待获取某个锁、事务正在执行的语句等）。</p><p>例如：</p><p>在一个会话中，开启事务T1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span>id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure><p>然后在另一个会话中查询INNODB_TRX表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span><span class="operator">*</span> <span class="keyword">FROM</span>information_schema.INNODB_TRX;</span><br></pre></td></tr></table></figure><br><img src="/colinstar/2022/11/30/mysql%E6%9F%A5%E7%9C%8B%E4%BA%8B%E5%8A%A1%E5%8A%A0%E9%94%81%E6%83%85%E5%86%B5/image-20221130223756826.png" class><p><br><br></p><p>trx_id：事务id</p><p>trx_state：事务状态</p><br><p>trx_tables_locked：表示当前事务目前加了多少个表级锁；</p><p>trx_rows_locked：表示该事务目前加了多少个行级锁（不包括隐式锁）；</p><p>trx_lock_structs：表示当前该事务生成了多少个内存中的锁结构；</p><h1 id="INNODB-LOCKS"><a href="#INNODB-LOCKS" class="headerlink" title="INNODB_LOCKS"></a>INNODB_LOCKS</h1><br><p>该表记录一些锁信息，主要包括以下两个方面。</p><p>如果一个事务想要获取某个锁但未获取到，则记录该锁信息</p><p>如果一个事务获取到了某个锁，但是这个锁阻塞了别的事务，则记录该锁信息</p><hr><p>tips：只有当系统中发生了某个事务因为获取不到锁而被阻塞的情况时，该表中才会有记录</p><hr><br><p>例如：</p><p>会话1，开启事务T1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span>id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure><br><p>会话2，开启事务T2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span>id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure><br><p>此时查询INNODB_LOCKS表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span><span class="operator">*</span> <span class="keyword">FROM</span>information_schema.INNODB_LOCKS;</span><br></pre></td></tr></table></figure><br><img src="/colinstar/2022/11/30/mysql%E6%9F%A5%E7%9C%8B%E4%BA%8B%E5%8A%A1%E5%8A%A0%E9%94%81%E6%83%85%E5%86%B5/image-20221130225406885.png" class><p>可以看到trx_id为44849和44848的两个事务被显现出来。但是无法凭借上述内容区分到底谁占用了其他事务需要的锁。</p><p>我们可以通过INNODB_LOCK_WAITS表来查看更多信息</p><h1 id="INNODB-LOCK-WAITS"><a href="#INNODB-LOCK-WAITS" class="headerlink" title="INNODB_LOCK_WAITS"></a>INNODB_LOCK_WAITS</h1><p>该表中，表明了每个阻塞的事务是一位内获取不到哪个事务持有的锁而阻塞。接着上面的例子，查询一下该表</p><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span><span class="operator">*</span> <span class="keyword">FROM</span>information_schema.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure><br><img src="/colinstar/2022/11/30/mysql%E6%9F%A5%E7%9C%8B%E4%BA%8B%E5%8A%A1%E5%8A%A0%E9%94%81%E6%83%85%E5%86%B5/image-20221130225848532.png" class><br><p>其中，requesting_trx_id表示因为获取不到锁而被阻塞的事务id;</p><p>blocking_trx_id表示因为获取到别的事务的锁而导致其被阻塞的事务的事务id;</p><hr><p>tips：INNODB_LOCKS和INNODB_LOCK_WAITS这两个表在mysql5.7中被标记为过时，在mysql8.0中被移除</p><hr><br><h1 id="使用SHOW-ENGINE-INNODB-STATUS获取锁信息"><a href="#使用SHOW-ENGINE-INNODB-STATUS获取锁信息" class="headerlink" title="使用SHOW ENGINE INNODB STATUS获取锁信息"></a>使用SHOW ENGINE INNODB STATUS获取锁信息</h1><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_status_output_locks<span class="operator">=</span><span class="keyword">on</span>; <span class="comment">-- 可以查看到更完整的信息</span></span><br><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br></pre></td></tr></table></figure><p>执行该语句，得到以下内容：</p><br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">=====================================</span><br><span class="line"><span class="meta">2022-11-30</span> <span class="string">23:02:49 0x5484 INNODB MONITOR OUTPUT</span></span><br><span class="line">=====================================</span><br><span class="line"><span class="attr">Per</span> <span class="string">second averages calculated from the last 60 seconds</span></span><br><span class="line"><span class="attr">-----------------</span></span><br><span class="line"><span class="attr">BACKGROUND</span> <span class="string">THREAD</span></span><br><span class="line"><span class="attr">-----------------</span></span><br><span class="line"><span class="attr">srv_master_thread</span> <span class="string">loops: 295 srv_active, 0 srv_shutdown, 465878 srv_idle</span></span><br><span class="line"><span class="attr">srv_master_thread</span> <span class="string">log flush and writes: 466173</span></span><br><span class="line"><span class="attr">----------</span></span><br><span class="line"><span class="attr">SEMAPHORES</span></span><br><span class="line"><span class="attr">----------</span></span><br><span class="line"><span class="attr">OS</span> <span class="string">WAIT ARRAY INFO: reservation count 172</span></span><br><span class="line"><span class="attr">OS</span> <span class="string">WAIT ARRAY INFO: signal count 167</span></span><br><span class="line"><span class="meta">RW-shared</span> <span class="string">spins 0, rounds 310, OS waits 156</span></span><br><span class="line"><span class="meta">RW-excl</span> <span class="string">spins 0, rounds 397, OS waits 1</span></span><br><span class="line"><span class="meta">RW-sx</span> <span class="string">spins 0, rounds 0, OS waits 0</span></span><br><span class="line"><span class="attr">Spin</span> <span class="string">rounds per wait: 310.00 RW-shared, 397.00 RW-excl, 0.00 RW-sx</span></span><br><span class="line"><span class="attr">------------</span></span><br><span class="line"><span class="attr">TRANSACTIONS</span></span><br><span class="line"><span class="attr">------------</span></span><br><span class="line"><span class="comment"># 下一个待分配的事务id信息</span></span><br><span class="line"><span class="attr">Trx</span> <span class="string">id counter 44852 </span></span><br><span class="line"><span class="comment"># 一些关于purge的信息</span></span><br><span class="line"><span class="attr">Purge</span> <span class="string">done for trx&#x27;s n:o &lt; 44848 undo n:o &lt; 0 state: running but idle</span></span><br><span class="line"><span class="comment"># 每个回滚段中都有一个history链表，这些链表的总长度</span></span><br><span class="line"><span class="attr">History</span> <span class="string">list length 38</span></span><br><span class="line"><span class="comment"># 各个事务的具体信息</span></span><br><span class="line"><span class="attr">LIST</span> <span class="string">OF TRANSACTIONS FOR EACH SESSION:</span></span><br><span class="line"><span class="meta">---TRANSACTION</span> <span class="string">284597729996288, not started</span></span><br><span class="line"><span class="attr">0</span> <span class="string">lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="meta">---TRANSACTION</span> <span class="string">284597729997160, not started</span></span><br><span class="line"><span class="attr">0</span> <span class="string">lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="comment"># 事务id 44851的具体信息，活跃11秒</span></span><br><span class="line"><span class="meta">---TRANSACTION</span> <span class="string">44851, ACTIVE 11 sec starting index read</span></span><br><span class="line"><span class="attr">mysql</span> <span class="string">tables in use 1, locked 1</span></span><br><span class="line"><span class="comment"># 该事务由2个锁结构，1个行锁</span></span><br><span class="line"><span class="attr">LOCK</span> <span class="string">WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)</span></span><br><span class="line"><span class="attr">MySQL</span> <span class="string">thread id 59, OS thread handle 52760, query id 63263 localhost ::1 root statistics</span></span><br><span class="line"><span class="comment"># 该事务对某个库下的某个表加了IX独占意向锁</span></span><br><span class="line"><span class="attr">TABLE</span> <span class="string">LOCK table `tmp`.`single_table` trx id 44855 lock mode IX</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM single_table WHEREid = 20 FOR UPDATE</span></span><br><span class="line"><span class="meta">-------</span> <span class="string">TRX HAS BEEN WAITING 11 SEC FOR THIS LOCK TO BE GRANTED:</span></span><br><span class="line"><span class="comment"># 以下表示一个表结构，Space id 为290，page no 为9， n_bits属性为264 index对应的索引是primary， 锁结构中存放的所类型是X行记录锁</span></span><br><span class="line"><span class="comment"># lock_mode X locks rec but not gap 行记录锁</span></span><br><span class="line"><span class="comment"># lock_mode X locks gap before rec X型gap锁</span></span><br><span class="line"><span class="comment"># lock_mode X X型next-key锁</span></span><br><span class="line"><span class="attr">RECORD</span> <span class="string">LOCKS space id 290 page no 8 n bits 264 index PRIMARY of table `tmp`.`single_table` trx id 44851 lock_mode X locks rec but not gap waiting</span></span><br><span class="line"><span class="comment"># 记录锁</span></span><br><span class="line"><span class="attr">Record</span> <span class="string">lock, heap no 21 PHYSICAL RECORD: n_fields 10; compact format; info bits 0</span></span><br><span class="line"><span class="comment"># hex 80000014； 主键值，20(16进制)</span></span><br><span class="line"> <span class="attr">0</span>: <span class="string">len 4; hex 80000014; asc     ;;</span></span><br><span class="line"> <span class="attr">1</span>: <span class="string">len 6; hex 000000005ff4; asc     _ ;;</span></span><br><span class="line"> <span class="attr">2</span>: <span class="string">len 7; hex eb000001a80110; asc        ;;</span></span><br><span class="line"> <span class="attr">3</span>: <span class="string">len 5; hex 3164316136; asc 1d1a6;;</span></span><br><span class="line"> <span class="attr">4</span>: <span class="string">len 4; hex 80000014; asc     ;;</span></span><br><span class="line"> <span class="attr">5</span>: <span class="string">len 5; hex 6338323337; asc c8237;;</span></span><br><span class="line"> <span class="attr">6</span>: <span class="string">len 8; hex 3664376636366161; asc 6d7f66aa;;</span></span><br><span class="line"> <span class="attr">7</span>: <span class="string">len 8; hex 6634613534376666; asc f4a547ff;;</span></span><br><span class="line"> <span class="attr">8</span>: <span class="string">len 8; hex 3566306137646365; asc 5f0a7dce;;</span></span><br><span class="line"> <span class="attr">9</span>: <span class="string">len 10; hex 33616634373037666566; asc 3af4707fef;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">------------------</span></span><br><span class="line"><span class="meta">---TRANSACTION</span> <span class="string">44848, ACTIVE 2220 sec</span></span><br><span class="line"><span class="attr">2</span> <span class="string">lock struct(s), heap size 1136, 1 row lock(s)</span></span><br><span class="line"><span class="attr">MySQL</span> <span class="string">thread id 56, OS thread handle 21628, query id 63220 localhost ::1 root</span></span><br><span class="line"><span class="attr">--------</span></span><br><span class="line"><span class="attr">FILE</span> <span class="string">I/O</span></span><br><span class="line"><span class="attr">--------</span></span><br><span class="line"><span class="attr">.....省略.....</span></span><br><span class="line"><span class="attr">END</span> <span class="string">OF INNODB MONITOR OUTPUT</span></span><br><span class="line">============================</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SHOW ENGINE INNODB STATUS;还可以用来查看死锁</p><p>LATEST DETECTED DEADLOCK 开始的内容，即表示最近一次发生的死锁信息；</p><p>注意的是，此语句默认只会显示最近一次发生的死锁信息，可以将全局系统变量innodb_print_all_deadlocks设置为ON，这样可以将每个死锁发生时的信息都记录在Mysql的错误日志中了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;code&gt;information_schema&lt;/code&gt;数据库中，有几个与事务和锁紧密相关的表。&lt;/p&gt;
&lt;h1 id=&quot;INNODB-TRX&quot;&gt;&lt;a href=&quot;#INNODB-TRX&quot; class=&quot;headerlink&quot; title=&quot;INNODB_TRX&quot;&gt;</summary>
      
    
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>explain详解</title>
    <link href="http://c89757.gitee.io/colinstar/2022/11/15/explain%E8%AF%A6%E8%A7%A3/"/>
    <id>http://c89757.gitee.io/colinstar/2022/11/15/explain%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-11-15T14:35:26.000Z</published>
    <updated>2023-02-19T14:59:28.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>该条记录代表该表的表名</p><br><h1 id="id"><a href="#id" class="headerlink" title="id"></a>id</h1><br><p>查询语句中每出现一个select关键字，mysql就会为它分配一个唯一的id;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">INNER</span> <span class="keyword">JOIN</span> single_table2</span><br></pre></td></tr></table></figure><br><img src="/colinstar/2022/11/15/explain%E8%AF%A6%E8%A7%A3/image-20221115224706076.png" class><br><p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id值时相同的：出现在前面的表表示驱动表，出现在后面的表表示被驱动表。</p><br><p>对于union子句来说，会有点不同；如下</p><img src="/colinstar/2022/11/15/explain%E8%AF%A6%E8%A7%A3/image-20221115224946326.png" class><br><p>union：会把多个查询的结果集合并起来并对结果集中的记录去重。会使用临时表</p><p>所以表名是 &lt;union1,2&gt; ，即在内部创建了一个名为 &lt;union1,2&gt;的临时表；id为null表明这个临时表是为了合并两个查询的结果集而创建的。</p><br><h1 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h1><br><h2 id="simple"><a href="#simple" class="headerlink" title="simple"></a>simple</h2><br><p>查询语句中不包含UNION或者子查询的查询都算作SIMPLE类型。</p><br><h2 id="primary"><a href="#primary" class="headerlink" title="primary"></a>primary</h2><br><p>对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的：其中最左边的那个查询的select_type值就是primary;<br><br></p><img src="/colinstar/2022/11/15/explain%E8%AF%A6%E8%A7%A3/image-20221115225446771.png" class><br><br><h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><br><p>对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的：其中除了最左边的那个小查询以外，其余小查询的select_type值就是UNION。</p><br><h2 id="union-result"><a href="#union-result" class="headerlink" title="union result"></a>union result</h2><br><p>Mysql选择使用临时表的来完成UNION查询的去重工作，针对该临时表的查询就是UNION RESULT</p><br><h2 id="subquery"><a href="#subquery" class="headerlink" title="subquery"></a>subquery</h2><br><p>如果包含子查询的查询语句不能够被转换为对应的半连接形式，并且该子查询是不相关子查询，而且查询优化器决定采用将该子查询物化的方案来执行子查询时，该子查询的第一个select 关键字代表的那个查询的select type就是subquery</p><br><img src="/colinstar/2022/11/15/explain%E8%AF%A6%E8%A7%A3/image-20221115225854475.png" class><br><p>由于select type为subquery的子查询会被物化，所以该子查询只会被查询一次</p><br><h2 id="dependent-subquery"><a href="#dependent-subquery" class="headerlink" title="dependent subquery"></a>dependent subquery</h2><br><p>如果包含子查询的查询语句不能够被转换为对应的半连接形式，并且该子查询被查询优化器转换为相应相关子查询的形式，则该子查询的第一个select关键字代表的那个查询的select_type就是dependent subquery。</p><br><p>select type为dependent subquery的子查询可能会被执行多次</p><br><h2 id="dependent-union"><a href="#dependent-union" class="headerlink" title="dependent union"></a>dependent union</h2><br><p>在包含union或者union all的大查询中，如果各个小查询都依赖于外层查询，则除了最左边的那个小查询以外，其余小查询的select_type的值就是dependent union</p><br><h2 id="derived"><a href="#derived" class="headerlink" title="derived"></a>derived</h2><br><p>在包含派生表的查询中，如果是以物化派生表的方式执行查询，则派生表对应的子查询就的select_type就是derived;</p><hr><p>tips：在from后面的子查询称为派生表</p><hr><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> key1, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1) <span class="keyword">AS</span> derived_s1 <span class="keyword">where</span> c <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><br><img src="/colinstar/2022/11/15/explain%E8%AF%A6%E8%A7%A3/image-20221115231019210.png" class><br><p>id为2的记录就是代表子查询的查询方式，select_type为derived，说明该子查询是以物化的方式执行的；</p><p>id为1的记录的table显示的是&lt;derived2&gt;，表示该查询是针对将派生表物化后的表进行查询的</p><br><h2 id="materialized"><a href="#materialized" class="headerlink" title="materialized"></a>materialized</h2><br><p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询。</p><br><p><img src="/colinstar/colinstar/2022/11/15/explain%E8%AF%A6%E8%A7%A3/typora-user-images\explain详解\image-20221115231724513.png" alt="image-20221115231724513"></p><br><p>执行计划的第三条记录的select_type值为materialized，查询优化器是将子查询先转换为物化表。</p><p>执行计划的前两条记录的id值都是1，说明这两条记录对应的表进行的是连接查询，第二条记录的table列的值是&lt;subquery2&gt;，说明该表其实就是执行计划中id为2对应的子查询物化之后产生的物化表；然后再将s1和该物化表进行连接查询，</p><br><h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><br><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><br><p>当表中只有一条记录并且该表使用的存储引擎（如Myisam、Memory）的统计数据都是精确的，那么对该表的访问方式就是system</p><br><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><br><p>当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方式就是const</p><br><h2 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h2><br><p>执行连接查询时， 如果被驱动表是通过主键或者不允许存储null值的唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一不为空索引都是联合索引，则所有的索引列都必须是等值比较），则对该被驱动表的访问方式就是eq_ref</p><br><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><br><p>当通过普通的二级索引列与常量进行等值匹配的方式来查询某个表时，对该表的访问方法就可能是ref</p><p>如果是连接查询，被动表中的某个普通二级索引列与驱动表中的某个列进行等值匹配，那么被驱动表也可能使用ref的访问方式</p><br><h2 id="fulltxt"><a href="#fulltxt" class="headerlink" title="fulltxt"></a>fulltxt</h2><br><p>全文检索</p><h2 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h2><br><p>当对普通二级索引列进行等值匹配，且该索引列的值也可以是null值时</p><br><h2 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h2><br><p>一般只会为单个索引生成扫描区间，特殊情况下可以使用索引合并</p><br><h2 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h2><br><p>​    类似于两表连接中被驱动表的<code>eq_ref</code>访问方法，<code>unique_subquery</code>是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的<code>type</code>列的值就是<code>unique_subquery</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">where</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><br><img src="/colinstar/2022/11/15/explain%E8%AF%A6%E8%A7%A3/image-20221115233702041.png" class><br><p>会被改写成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> s1 , s2 <span class="keyword">where</span> s1.key2 <span class="operator">=</span> s2.id <span class="keyword">and</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">or</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><br><h2 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h2><br><p>与unique_subquey类似，只不过在访问子查询中的表时使用的是普通索引</p><br><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><br><p>如果使用索引获取某些<code>范围区间</code>的记录，那么就可能使用到<code>range</code>访问方法，比如下边的这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure><br><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><br><p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是<code>index</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> key_part2 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上述查询中的搜索列表中只有<code>key_part2</code>一个列，而且搜索条件中也只有<code>key_part3</code>一个列，这两个列又恰好包含在<code>idx_key_part</code>这个联合索引中，可是搜索条件<code>key_part3</code>不能直接使用该索引进行<code>ref</code>或者<code>range</code>方式的访问，只能扫描整个<code>idx_key_part</code>索引的记录，所以查询计划的<code>type</code>列的值就是<code>index</code>。</p><br><p>另外，对于Innodb来说，当我们需要执行全表扫描，并且需要对主键排序时，此时的type列也是index</p><h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p><br>全表扫描</p><br><h1 id="possible-keys-与-key"><a href="#possible-keys-与-key" class="headerlink" title="possible_keys 与 key"></a>possible_keys 与 key</h1><p>possible_keys：对某个表执行单表查询可能使用到的索引有哪些</p><p>key：表示实际用到的索引有哪些</p><br><hr><p>tips：possible_keys列的值并不是越多越好，可以使用的索引越多，查询优化器在计算查询成本时花费的时间也越长</p><hr><br><p>在使用index访问方式查询某个表时，possible_keys列时空的，而key列展示实际用到的索引</p><br><h1 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;table&quot;&gt;&lt;a href=&quot;#table&quot; class=&quot;headerlink&quot; title=&quot;table&quot;&gt;&lt;/a&gt;table&lt;/h1&gt;&lt;p&gt;该条记录代表该表的表名&lt;/p&gt;
&lt;br&gt;

&lt;h1 id=&quot;id&quot;&gt;&lt;a href=&quot;#id&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql子查询</title>
    <link href="http://c89757.gitee.io/colinstar/2022/11/13/Mysql%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    <id>http://c89757.gitee.io/colinstar/2022/11/13/Mysql%E5%AD%90%E6%9F%A5%E8%AF%A2/</id>
    <published>2022-11-13T10:07:59.000Z</published>
    <updated>2022-11-13T14:34:16.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子查询的分类"><a href="#子查询的分类" class="headerlink" title="子查询的分类"></a>子查询的分类</h1><h2 id="按照出现位置区分"><a href="#按照出现位置区分" class="headerlink" title="按照出现位置区分"></a>按照出现位置区分</h2><p>1、在select子句中</p><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> m1 <span class="keyword">from</span> t1 limit <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>2、在From子句中</p><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m,n <span class="keyword">from</span> (<span class="keyword">select</span> m2 <span class="keyword">as</span> m , n2 <span class="keyword">as</span> n <span class="keyword">from</span> t2 <span class="keyword">where</span>  m <span class="operator">&gt;</span> <span class="number">2</span> ) <span class="keyword">as</span> t ;</span><br></pre></td></tr></table></figure><p>3、在where或on子句的表达式中</p><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> m1 <span class="keyword">in</span> ( <span class="keyword">select</span> m2 <span class="keyword">from</span> t2 );</span><br></pre></td></tr></table></figure><h2 id="按返回的结果集区分"><a href="#按返回的结果集区分" class="headerlink" title="按返回的结果集区分"></a>按返回的结果集区分</h2><ul><li>标量子查询</li></ul><p>只返回一个单一列值的子查询</p><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> m1 <span class="operator">=</span> ( <span class="keyword">select</span> <span class="built_in">MIN</span>(m2) <span class="keyword">from</span> t2);</span><br></pre></td></tr></table></figure><ul><li>行子查询</li></ul><p>返回一条记录的（一行的）子查询。不过这条记录需要包含多个列（如果只包含一个列，就是标量子查询）</p><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> (m1 ,n1)  <span class="operator">=</span> (<span class="keyword">select</span> m2 ,n2 <span class="keyword">from</span> t2 limit <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>列子查询</li></ul><p>查询出一个列的数据，不过这一列包含很多（其他行的）数据</p><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> m1 <span class="keyword">in</span> (<span class="keyword">select</span> m2 <span class="keyword">from</span> t2);</span><br></pre></td></tr></table></figure><ul><li>表子查询</li></ul><p>即子查询的结果既包含很多条记录，又包含很多个列</p><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> (m1,n1) <span class="keyword">in</span> ( <span class="keyword">select</span> m2 , n2 <span class="keyword">from</span> t2);</span><br></pre></td></tr></table></figure><h2 id="按与外层查询的关系来区分"><a href="#按与外层查询的关系来区分" class="headerlink" title="按与外层查询的关系来区分"></a>按与外层查询的关系来区分</h2><ul><li>不相关子查询</li></ul><p>子查询可以单独运行出结果，不依赖于外层查询的值</p><ul><li>相关子查询</li></ul><p>子查询的执行需要依赖于外层查询的值</p><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> m1 <span class="keyword">in</span> (<span class="keyword">select</span> m2 <span class="keyword">from</span> t2 <span class="keyword">where</span> n1 <span class="operator">=</span> n2);</span><br></pre></td></tr></table></figure><h1 id="子查询的执行过程"><a href="#子查询的执行过程" class="headerlink" title="子查询的执行过程"></a>子查询的执行过程</h1><h2 id="标量子查询、行子查询的执行过程"><a href="#标量子查询、行子查询的执行过程" class="headerlink" title="标量子查询、行子查询的执行过程"></a>标量子查询、行子查询的执行过程</h2><h3 id="不相关查询"><a href="#不相关查询" class="headerlink" title="不相关查询"></a>不相关查询</h3><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> key1 <span class="operator">=</span> (<span class="keyword">select</span> common_field <span class="keyword">from</span> s2 <span class="keyword">where</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> limit <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>1、先单独执行子查询</p><p>2、然后将子查询得到的结果作为外层查询的参数，再执行外层的 <code>select * from s1 where key1 =  xxx</code></p><h3 id="相关查询"><a href="#相关查询" class="headerlink" title="相关查询"></a>相关查询</h3><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> key1 <span class="operator">=</span> (<span class="keyword">select</span> common_field <span class="keyword">from</span> s2 <span class="keyword">where</span> s1.key3 <span class="operator">=</span> s2.key3 limit <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>1、先从外层查询获取一条记录。即先从s1表中获取一条记录</p><p>2、然后从这条记录中找出子查询涉及的列。即key3 ，然后执行子查询</p><p>3、根据子查询的查询结果，来检测是否与外层查询的where条件相符合。如果条件成立符合，加入结果集。反之丢弃</p><p>4、跳到步骤1，重复此过程，直到外层查询获取不到记录为止</p><h2 id="IN子查询的优化"><a href="#IN子查询的优化" class="headerlink" title="IN子查询的优化"></a>IN子查询的优化</h2><p> 例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> key1 <span class="keyword">in</span> (<span class="keyword">select</span> common_field <span class="keyword">from</span> s2 <span class="keyword">where</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>我们是否可以将子查询转换为连接呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s1.<span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">inner</span> <span class="keyword">join</span> s2 <span class="keyword">on</span> s1.key1 <span class="operator">=</span> s2.common_field <span class="keyword">where</span> s2.key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其实效果是很像的，但是区别在于，我们并不知道子查询的结果有多少条。如果有多条，那查询出来的结果可能会重复加入结果集</p><p>我们可以分为三种情况讨论</p><p>1、对于s1表中的某条记录来说，s2表中没有任何记录满足s1.key1 = s2.common_field，那么该结果不会加入结果集</p><p>2、对于s1表中的某条记录来说，s2表中有且只有一条记录满足s1.key1 = s2.common_field，那么该结果会被加入结果集</p><p>3、对于s1表中的某条记录来说，s2表中至少有两条记录满足s1.key1 = s2.common_field，那么该结果会被多次加入最终的结果集</p><p>对于s1表中的某条记录来说，我们只关心s2表中是否存在记满足key1 = s2.common_field条件，并不关心具体有多少条记录与之匹配；</p><p>半连接(semi-join)：将s1表和s2表进行半连接的意思就是，对于s1表中的某条记录来说，我们只关心在s2表中是否存在与之匹配的记录，而不关心具体有多少条记录匹配，最终的结果集中只保留s1表中的记录。</p><h3 id="Table-pullout（子查询中的表上拉）"><a href="#Table-pullout（子查询中的表上拉）" class="headerlink" title="Table pullout（子查询中的表上拉）"></a>Table pullout（子查询中的表上拉）</h3><p>当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表上拉到外层查询的from子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中。</p><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> key2 <span class="keyword">in</span> (<span class="keyword">select</span> key2 <span class="keyword">from</span> s2 <span class="keyword">where</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>key2是唯一二级索引列，我们可以直接进行table pullout。上拉后的查询就是下面这样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s1.<span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">inner</span> <span class="keyword">join</span> s2 <span class="keyword">on</span> s1.key2 <span class="operator">=</span> s2.key2 <span class="keyword">where</span> s2.key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="Duplicate-Weedout（重复值消除）"><a href="#Duplicate-Weedout（重复值消除）" class="headerlink" title="Duplicate Weedout（重复值消除）"></a>Duplicate Weedout（重复值消除）</h3><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> key1 <span class="keyword">in</span> ( <span class="keyword">select</span> common_field <span class="keyword">from</span> s2 <span class="keyword">where</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> )</span><br></pre></td></tr></table></figure><p>在转换为半连接查询后，s1表中的某条记录可能在s2表中有多条匹配的记录，所以该条记录可能多次被添加到最后的结果集中。</p><p>我们可以建立一个临时表，比如这个临时表如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tmp (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这样在执行连接查询的过程中，每当某条s1表中的记录要加入到结果集时，就首先把这条记录的id值加入到这个临时表中。</p><p>如果添加成功，则说明之前这条s1表中的记录并没有加入最终的结果集，现在把该记录添加到最终的结果集；如果添加失败，则说明这条s1表中的记录之前已经加入到最终的结果集。这种使用临时表消除半连接结果集中重复值的方式Duplicate Weebout。</p><h3 id="LooseScan（松散扫描）"><a href="#LooseScan（松散扫描）" class="headerlink" title="LooseScan（松散扫描）"></a>LooseScan（松散扫描）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> key3 <span class="keyword">in</span> ( <span class="keyword">select</span> key1 <span class="keyword">from</span> s2 <span class="keyword">where</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在子查询中，对于s2表的访问可以使用到key1列的索引，而子查询的查询列表处恰好就是在key1列。</p><p>可以将子查询后的s2作为驱动表，然后从查询出来的结果集中，只取键值相同的第一条记录去执行匹配操作</p><h3 id="Semi-join-Materialization-半连接物化"><a href="#Semi-join-Materialization-半连接物化" class="headerlink" title="Semi-join Materialization (半连接物化)"></a>Semi-join Materialization (半连接物化)</h3><p>如不相关的in子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> key1 <span class="keyword">in</span> (<span class="keyword">select</span> common_field <span class="keyword">from</span> s2 <span class="keyword">where</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> );</span><br></pre></td></tr></table></figure><p>对于不相关的in子查询来说，如果子查询结果集中的记录条数很少，那么把子查询和外层查询分别看成两个单独的单表查询，效率还是蛮高的，但是，如果单独执行子查询后的结果集太多，就会导致结果集太多，可能内存都放不下。</p><p>于是mysql不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果写入一个临时表中。</p><ul><li>该临时表的列就是子查询结果集中的列</li><li>写入临时表的记录会被去重</li></ul><p>一般情况下，子查询结果集不会太大，所以会为它建立基于内存的使用MEMORY存储引擎的临时表，而且还会为该表建立哈希索引。</p><p>（IN语句的本质就是判断某个操作数是否存在于某个集合中，建立哈希索引，判断匹配的过程会非常快）</p><p>如果子查询的结果集非常大，超过了系统变量<code>tmp_table_size</code>或者<code>max_heap_table_size</code>的值，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也相应地转换为B+树索引</p><p>将子查询结果集中的记录保存到临时表的过程称为物化（materialize)</p><p>当我们把上述sql的子查询物化后，假设物化后的表名称为materialize_table，该物化表存储的子查询结果集的列为m_val。那么这个子查询就相当于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s1.<span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">inner</span> <span class="keyword">join</span> materialize_table <span class="keyword">on</span> key1 <span class="operator">=</span> m_val;</span><br></pre></td></tr></table></figure><p>因为物化表中没有重复的记录，所以可以直接将子查询转换为连接查询。</p><p>（针对不相关子查询，相关子查询并不是一个独立的查询，不能转换为物化表）</p><h3 id="FirstMatch-首次匹配"><a href="#FirstMatch-首次匹配" class="headerlink" title="FirstMatch(首次匹配)"></a>FirstMatch(首次匹配)</h3><p>先取一条外层查询中的记录，然后到子查询的表中寻找符合匹配条件的记录。如果能找到一条，则将该外层查询的记录放入最终的结果集，并且停止查找更多匹配的记录。如果找不到，则把该外层查询的记录丢弃掉。然后取下一条外层查询中的记录。不断重复此过程，直到外层查询获取不到记录为止。</p><h3 id="半连接适用条件"><a href="#半连接适用条件" class="headerlink" title="半连接适用条件"></a>半连接适用条件</h3><p>并不是所有的IN子查询的查询语句都可以转换为半连接</p><p>1、该子查询必须是与IN操作符组成的布尔表达式，并且在外层的where 或者 on 子句中出现</p><p>2、外层查询也可以有其他的搜索条件，只不过必须使用AND操作符与IN子查询的搜索条件</p><p>3、该子查询必须是一个单一的查询，不能是由UNION连接起来的若干查询</p><p>4、该子查询不能包含GROUP BY 、HAVING语句或者聚合函数</p><p>不适用于半连接的情况</p><p>1、在外层查询的WHERE子句中，存在其他搜索条件使用OR操作符与IN子查询组成的布尔表达式连接起来的情况</p><p>2、使用NOT IN 而不是IN</p><p>3、位于select子句中的IN子查询</p><p>4、子查询包含GROUP BY 、HAVING语句或者聚合函数</p><p>5、子查询中包含UNION的情况</p><p>但是，mysql仍然可以优化不能转为半连接查询的子查询。</p><ul><li>对于不相关的子查询，可以尝试把它们物化之后再参与查询</li></ul><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> key1 <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> common_field <span class="keyword">from</span> s2 <span class="keyword">where</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><p>先将子查询物化，然后再判断key1是否在物化表中的结果集中。这样可以加快查询的执行速度</p><p>注意：这里子查询物化之后，不能转为与外层表连接查询。</p><ul><li>无论子查询是相关的还是不相关的，都可以把IN子查询尝试转为EXISTS子查询</li></ul><p>outer_expr IN (select inner_expr from … where subquery_where)</p><p>可以被转换为：</p><p>EXISTS （select inner_expr from …. where subquery_where AND outer_expr=inner_expr)</p><p>某些情况，不转换的话可能用不到索引。</p><p>如果IN子查询符合转换半连接的条件，查询优化器会优先把该子查询转换为半连接，然后再考虑上述五种半连接的策略中，选取成本最低的策略来执行子查询</p><p>如果IN子查询不符合转换为半连接的条件，那么查询优化器会从下面两种策略中找出一种成本最低的方式来执行子查询。</p><p>先将子查询物化，再执行查询</p><p>执行IN到EXISTS的转化</p><h2 id="NOT-EXISTS子查询的执行"><a href="#NOT-EXISTS子查询的执行" class="headerlink" title="[NOT] EXISTS子查询的执行"></a>[NOT] EXISTS子查询的执行</h2><p>如果[NOT] EXISTS子查询是不相关子查询。可以先执行子查询，得出该子查询的结果是true还是false，然后重写原先的查询语句</p><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> s2 <span class="keyword">where</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>) <span class="keyword">or</span> key2 <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>因为该子查询是不相关子查询，所以查询优化器会首先执行该子查询。最后查询优化器会重写查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> <span class="literal">TRUE</span><span class="operator">|</span><span class="literal">FALSE</span> <span class="keyword">or</span> key2 <span class="operator">&gt;</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>对于相关的[NOT] EXISTS子查询来说，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> s2 <span class="keyword">where</span> s1.common_field <span class="operator">=</span> s2.common_field)</span><br></pre></td></tr></table></figure><p>那么只能最原始的执行方式来执行。先从外层取一条数据，然后作为内层查询的参数，判断条件是否匹配。</p><p>不过我们可以使用索引，加快查询速度。如给s2.common_field加上索引</p><h2 id="派生表的优化"><a href="#派生表的优化" class="headerlink" title="派生表的优化"></a>派生表的优化</h2><p>把子查询放在外层查询的FROM子句后，这个子查询相当于一个派生表。</p><p>对于含有派生表的查询，Mysql提供了两种执行策略</p><ul><li>把派生表物化</li></ul><p>我们可以将派生表的结果集写到一个内部的临时表中，然后把这个物化表当作普通表一样来参与查询。</p><p>再对派生表物化时，mysql使用了一种称为延迟物化的策略，也就是查询过程中，真正使用到派生表时，才会去尝试物化派生表，而不是查询之前就先把派生表物化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> ) <span class="keyword">as</span> drived_s1 <span class="keyword">inner</span> <span class="keyword">join</span> s2 <span class="keyword">on</span> drived_s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">where</span> s2.key2 <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果采用物化表的方式执行这个查询，在执行时首先会到s2表中找出满足s2.key2=1的记录，如果压根儿找不到，说明参与连接的s2表记录为空，结果集为空，没必要去物化表了。</p><ul><li>将派生表和外层查询合并</li></ul><p>即：将查询重写为没有派生表的形式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> ) <span class="keyword">as</span> drived_s1 <span class="keyword">inner</span> <span class="keyword">join</span> s2 <span class="keyword">on</span> drived_s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">where</span> s2.key2 <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>我们可以将派生表与外层查询合并</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">inner</span> <span class="keyword">join</span> s2 <span class="keyword">on</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">where</span> s1.key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">where</span> s2.key2 <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这样改写后，成功的消除了派生表，也就意味着我们没必要付出创建和访问临时表的成本了。</p><p>并不是所有带有派生表的查询都能成功的与外层查询合并。当派生表中有下面这些函数或语句时，就不可以与外层查询合并</p><ul><li><p>聚合函数，比如MAX()，MIN()，SUM()等</p></li><li><p>DISTINCT</p></li><li><p>GROUP BY</p></li><li><p>HAVING</p></li><li><p>LIMIT</p></li><li><p>UNION 或者 UNION ALL</p></li><li><p>派生表对应的子查询的select 子句中含有另一个子查询</p></li><li><p>……</p></li></ul><p>所以，mysql在执行带有派生表的查询时，会优先尝试把派生表和外层查询进行合并；如果不行，再采用物化表执行查询</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;子查询的分类&quot;&gt;&lt;a href=&quot;#子查询的分类&quot; class=&quot;headerlink&quot; title=&quot;子查询的分类&quot;&gt;&lt;/a&gt;子查询的分类&lt;/h1&gt;&lt;h2 id=&quot;按照出现位置区分&quot;&gt;&lt;a href=&quot;#按照出现位置区分&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>查询的成本</title>
    <link href="http://c89757.gitee.io/colinstar/2022/11/07/%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC/"/>
    <id>http://c89757.gitee.io/colinstar/2022/11/07/%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC/</id>
    <published>2022-11-07T15:15:38.000Z</published>
    <updated>2022-11-30T15:43:24.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单表查询的成本"><a href="#单表查询的成本" class="headerlink" title="单表查询的成本"></a>单表查询的成本</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>IO成本</strong>：我们的表经常使用的<code>MyISAM</code>、<code>InnoDB</code>存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为<code>I/O</code>成本。</p><p><strong>CPU成本</strong>：读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为<code>CPU</code>成本。</p><p>对于InnoDB来说，页是磁盘和内存之间进行交互的基本单位。Mysql规定，读取一个页面花费的成本默认是1.0；读取以及检测一条记录是否符合搜索条件的成本默认是0.2。</p><hr><p>tips：在读取记录时，即使不需要检测记录是否符合搜索条件，其成本也算作0.2</p><hr><br><ul><li>准备工作</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> single_table (</span><br><span class="line">id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">key1 <span class="type">VARCHAR</span> ( <span class="number">100</span> ),</span><br><span class="line">key2 <span class="type">INT</span>,</span><br><span class="line">key3 <span class="type">VARCHAR</span> ( <span class="number">100</span> ),</span><br><span class="line">key_part1 <span class="type">VARCHAR</span> ( <span class="number">100</span> ),</span><br><span class="line">key_part2 <span class="type">VARCHAR</span> ( <span class="number">100</span> ),</span><br><span class="line">key_part3 <span class="type">VARCHAR</span> ( <span class="number">100</span> ),</span><br><span class="line">common_field <span class="type">VARCHAR</span> ( <span class="number">100</span> ),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY ( id ),</span><br><span class="line">KEY idx_key1 ( key1 ),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY uk_key2 ( key2 ),</span><br><span class="line">KEY idx_ke3 ( key3 ),</span><br><span class="line">KEY idx_key_part ( key_part1, key_part2, key_part3 ) </span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure><br><ul><li>存储过程脚本插入1w数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">PROCEDURE</span> `genData`()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">DECLARE</span> n <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line"> WHILE n <span class="operator">&lt;=</span> <span class="number">10000</span></span><br><span class="line">   DO</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> single_table(key1,key2,key3,key_part1,key_part2,key_part3,common_field) <span class="keyword">values</span>(</span><br><span class="line"> <span class="built_in">substring</span>(md5(rand()), <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line"> n,</span><br><span class="line"> <span class="built_in">substring</span>(md5(rand()), <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line"> <span class="built_in">substring</span>(md5(rand()), <span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line"> <span class="built_in">substring</span>(md5(rand()), <span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line"> <span class="built_in">substring</span>(md5(rand()), <span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line"> <span class="built_in">substring</span>(md5(rand()), <span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">   <span class="keyword">SET</span> n <span class="operator">=</span> n <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="基于成本的优化步骤"><a href="#基于成本的优化步骤" class="headerlink" title="基于成本的优化步骤"></a>基于成本的优化步骤</h2><p>​    在一条单表查询语句真正执行之前，<code>MySQL</code>的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的<code>执行计划</code>，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：</p><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算全表扫描的代价</li><li>计算使用不同索引执行查询的代价</li><li>对比各种执行方案的代价，找出成本最低的那一个</li></ol><br><p>如下面的查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">single_table </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">key1 <span class="keyword">IN</span> ( <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ) </span><br><span class="line"><span class="keyword">AND</span> key2 <span class="operator">&gt;</span> <span class="number">10</span> </span><br><span class="line"><span class="keyword">AND</span> key2 <span class="operator">&lt;</span> <span class="number">1000</span> <span class="keyword">AND</span> key3 <span class="operator">&gt;</span> key2 </span><br><span class="line"><span class="keyword">AND</span> key_part1 <span class="keyword">LIKE</span> <span class="string">&#x27;%hello%&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="根据搜索条件，找出所有可能使用的索引"><a href="#根据搜索条件，找出所有可能使用的索引" class="headerlink" title="根据搜索条件，找出所有可能使用的索引"></a>根据搜索条件，找出所有可能使用的索引</h3><p>​    很显然，上面的查询语句，可能用到的索引有 idx_key1( key1) 、uk_key2(key2)</p><h3 id="计算全表扫描的代价"><a href="#计算全表扫描的代价" class="headerlink" title="计算全表扫描的代价"></a>计算全表扫描的代价</h3><p>​    全表扫描即：把聚簇索引中的记录都依次与给定的搜索条件进行比较，并把符合条件的记录加入结果集中。所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。</p><p>​    由于查询成本 = I/O成本 + CPU成本。所以计算全表扫描的代价需要两个信息：</p><ul><li>聚簇索引占用的页面数</li><li>该表中的记录数</li></ul><p>Mysql为每个表维护了一系列的统计信息。我们可以通过如下sql进行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;single_table&#x27;</span></span><br></pre></td></tr></table></figure><p>结果大致如下：</p><img src="/colinstar/2022/11/07/%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC/image-20221107233713733.png" class><p>其中：</p><p>Rows：表示表中记录条数。对于Myisam存储引擎来说，该值是准确的；对于Innodb来说，该值是估计值</p><p>Data_length：表示表占用的存储空间字节数。对于Myisam来说，该值就是数据文件的大小；对于Innodb引擎来说，该值就相当于聚簇索引占用的存储空间大小。</p><p>对于Innodb的存储引擎来说，Data_length = 聚簇索引的页面数量 * 每个页面大小</p><p>由于默认页面大小为16kb，上面查询出来的Data_length = 1589248，所以可以求出聚簇索引的页面数量</p><p>​                    聚簇索引的页面数量 = 1589248 / 16 / 1024 = 97</p><p>所以I/O成本 = 97 * 1.0 = 97 （97页，每页成本1.0）</p><p>CPU成本 = 9317 * 0.2 = 1863.4 （Rows = 9317行，每行检索成本0.2）</p><br><p>总成本  = 97 + 1863.4 = 1960.4</p><br><p>所以对该表的全表扫描成本即为 1960.4</p><br><h3 id="计算使用不同索引执行查询的代价"><a href="#计算使用不同索引执行查询的代价" class="headerlink" title="计算使用不同索引执行查询的代价"></a>计算使用不同索引执行查询的代价</h3><p>Mysql查询优化器会优先分析使用唯一二级索引的成本，再分析普通索引的成本。所以先分析uk_key2的成本</p><br><p>uk_key2的对应的搜索条件为 key2 &gt; 10 and key2 &lt; 1000，即对应扫描区间为（10，1000）</p><br><ul><li>扫描区间数量</li></ul><p>无论某个扫描区间的二级索引到底占用了多少页面，查询优化器粗暴的认为读取索引的一个扫描区间的I/O成本与读取一个页面的I/O成本相同；</p><p>此处的扫描区间数量只有一个: （10，1000），所以加载页面的I/O成本为1.0</p><br><ul><li>需要回表的记录数</li></ul><p>查询优化器需要先计算二级索引的某个扫描区间到底包含多少记录，对于本例来说，就是计算uk_key2在扫描区间（10，1000）中包含多少二级索引记录。</p><p>计算过程如下：</p><p>1、先根据key2 &gt; 10条件访问uk_key2对应的B+树索引，找到满足key2 &gt; 10 的第一条记录，称为最左记录。（此过程性能消耗可以忽略不计）</p><p>2、然后再根据key2 &lt; 1000条件访问uk_key2对应的B+树索引，找到最后一条满足key2 &lt; 1000的记录，称为最右记录。</p><p>3、如果最左记录和最右记录相隔不太远（Mysql5.7.22版本中，只要不大于10个页面即可），就可以精确统计出满足key2 &gt; 10 and key2 &lt; 1000条件的二级索引记录条数</p><hr><p>tips：数据页中有个Page Header部分。Page Header中有一个PAGE_N_RECS属性，记录了该页面中目前有多少条记录。所以如果最左记录和最右记录相隔不太远，直接遍历这些页面，拿到这个属性相加即可</p><hr><p>如果最左记录和最右记录相隔比较远，则沿着最左记录向右读10个页面，计算每个页面平均包含多少记录，然后用这个平均值乘以最左记录和最右记录之前的页面数量即可。</p><br><p>假设根据上述方法，测得uk_key2再区间（10，1000）中大约有95条记录。读取这95条二级索引记录需要付出的CPU成本为 95 * 0.2 = 19</p><br><ul><li>根据这些记录的主键值到聚簇索引中执行回表操作</li></ul><p>Mysql在评估回标操作的I/O成本时，粗暴的认为每次回表操作都相当于访问一个页面；</p><p>所以I/O成本就是 95 * 1.0 = 95</p><br><ul><li>回表得到完整记录后，再检测其他搜索条件是否成立</li></ul><p>我们通过扫描区间获取到的二级索引记录有95条，对应着聚簇索引中的95条完整用户记录。读取并检测这些完整的用户记录是否符合其余的搜索条件，所以CPU成本为：95 * 0.2 = 19</p><br><p>所以综上所述，使用uk_key2执行查询的总成本为：1.0 + 95 * 0.2 + 95 * 1.0 + 95 * 0.2  = 134</p><br><h3 id="使用普通二级索引执行查询的成本"><a href="#使用普通二级索引执行查询的成本" class="headerlink" title="使用普通二级索引执行查询的成本"></a>使用普通二级索引执行查询的成本</h3><p>略</p><br><h2 id="基于索引统计数据的成本计算"><a href="#基于索引统计数据的成本计算" class="headerlink" title="基于索引统计数据的成本计算"></a>基于索引统计数据的成本计算</h2><p>有时候，在使用索引执行查询时，会有很多个单点扫描区间，比如in语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key1 <span class="keyword">in</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> , .... <span class="string">&#x27;zzz&#x27;</span>);</span><br></pre></td></tr></table></figure><p>很显然这个查询语句可能使用到的索引就是idx_key1。由于这个索引并不是唯一二级索引，所以并不能确定一个单点扫描区间内对应的二级索引记录的条数有多少（唯一二级索引不重复，所以有多少个in就有多少个等值比较；但普通索引，一个in值里可能包含许多重复的值）。所以我们要去计算一下，计算方式就是先获取索引对应的B+树的区间最左记录和最右记录，然后再计算这两条记录之间有多少记录。</p><p>这种通过直接访问索引对应的B+树来计算某个扫面区间内对应的索引记录条数的方式称为**<code>index dive</code>**</p><br><p>如果只是零星几个单点扫描区间的话，使用index dive来计算这些单点扫描区间对应的记录数没什么问题。但是当扫描区间很多时，使用这种方法带来的性能损耗太大了，可能计算这些扫描区间对应的索引记录条数的成本比直接全表扫描的成本都大。</p><br><p>mysql中提供了一个系统变量<code>eq_range_index_limit</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%dive%&#x27;</span></span><br></pre></td></tr></table></figure><br><img src="/colinstar/2022/11/07/%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC/image-20221108001427511.png" class><br><p>也就是说，如果in语句生成的单点扫描区间的数量小于200个，将使用index dive来计算各个单点扫描区间对应的记录条数。</p><p>如果大于等于200个，将使用索引统计数据（index statistics）来进行估算。具体如何估算如下：</p><p>Mysql会为表中每个索引维护一份统计数据。可以通过如下sql查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> single_table;</span><br></pre></td></tr></table></figure><br><img src="/colinstar/2022/11/07/%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC/image-20221108001727200.png" class><br><p>Non_uniqe：该列所属索引是否是唯一索引。</p><p>Seq_in_index：该列在索引包含的列中位置。对于联合索引idx_key_part来说，key_part1的位置是1，key_part2的位置是2</p><p>Cardinality：该列中不重复值的数量。（是一个估算值，并不精确）比如对于一个有10000行记录的表来说，如果Cardinality = 10000，表明表中没有重复的值；如果Cardinality = 1，表示该列的值全部都是重复值；</p><br><p>索引统计数据（index statistics)</p><p>1、使用show table status语句显示出来的rows值，表示表中有多少记录</p><p>2、使用show index from语句显示出来的Cardinality值，</p><p>我们可以计算出，某一个列中一个值平均重复多少次。即 rows / Cardinality</p><br><br><p>假设Rows值为9693，key1列Cardinality值为968，计算出来单个列的平均重复次数为：9693 / 968 ≈ 10条</p><p>假设in语句包含着2000个单点扫描区间。每个扫描区间大约对应10条记录。所以总共需要回表的成本就是 2000 * 10 * 1.0</p><hr><p>tips：索引统计数据致命弱点是不准确！算出来的查询成本与实际执行时的成本可能相差较大。如果eq_range_index_limit值太小，则很容易采用索引统计数据来计算查询成本，可能导致计算出来的查询成本太大而导致不走索引。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单表查询的成本&quot;&gt;&lt;a href=&quot;#单表查询的成本&quot; class=&quot;headerlink&quot; title=&quot;单表查询的成本&quot;&gt;&lt;/a&gt;单表查询的成本&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概</summary>
      
    
    
    
    <category term="Mysql" scheme="http://c89757.gitee.io/colinstar/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://c89757.gitee.io/colinstar/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>表空间</title>
    <link href="http://c89757.gitee.io/colinstar/2022/11/05/%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
    <id>http://c89757.gitee.io/colinstar/2022/11/05/%E8%A1%A8%E7%A9%BA%E9%97%B4/</id>
    <published>2022-11-05T05:29:02.000Z</published>
    <updated>2022-11-05T05:40:51.456Z</updated>
    
    <content type="html"><![CDATA[<img src="/colinstar/2022/11/05/%E8%A1%A8%E7%A9%BA%E9%97%B4/%E8%A1%A8%E7%A9%BA%E9%97%B4.jpg" class>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/colinstar/2022/11/05/%E8%A1%A8%E7%A9%BA%E9%97%B4/%E8%A1%A8%E7%A9%BA%E9%97%B4.jpg&quot; class&gt;

</summary>
      
    
    
    
    <category term="Mysql" scheme="http://c89757.gitee.io/colinstar/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://c89757.gitee.io/colinstar/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Springboot自动装配</title>
    <link href="http://c89757.gitee.io/colinstar/2022/06/18/Springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
    <id>http://c89757.gitee.io/colinstar/2022/06/18/Springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</id>
    <published>2022-06-18T14:23:15.000Z</published>
    <updated>2022-06-19T11:14:26.761Z</updated>
    
    <content type="html"><![CDATA[<p>​    启动Springboot代码很简单，直接一行代码<code>SpringApplication.run(class,args)</code>搞定，其实这一步可以拆解成两步，SpringApplication.run方法里面，其实也是先new SpringApplication，然后调用它的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// SpringApplication.run(TestApplication.class,args);</span></span><br><span class="line">        SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(TestApplication.class);</span><br><span class="line">        springApplication.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="new-SpringApplication"><a href="#new-SpringApplication" class="headerlink" title="new SpringApplication()"></a>new SpringApplication()</h1><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(<span class="keyword">null</span>, primarySources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.resourceLoader = resourceLoader; </span><br><span class="line">   Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">   <span class="comment">// 1、将启动类存入primarySources中</span></span><br><span class="line">   <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">   <span class="comment">// 2、根据classpath下的类，推算当前web应用类型（webFlux,servlet)</span></span><br><span class="line">   <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">   <span class="comment">// 3、去spring.factoryies中获取所有key为`org.springframework.context.ApplicationContextInitializer`的值 ,设置容器的初始化器</span></span><br><span class="line">   setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">   <span class="comment">// 4、同3获取所有key为`org.springframework.context.ApplicationListener`的值,设置容器的监听器</span></span><br><span class="line">   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">   <span class="comment">// 5、根据调用栈推断出main方法所在类，获取其class对象</span></span><br><span class="line">   <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">   ClassLoader classLoader = getClassLoader();</span><br><span class="line">   Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">   List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">   AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">   <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看<code>SpringFactoriesLoader.loadFactoryNames(type, classLoader)</code>这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryTypeName = factoryType.getName();</span><br><span class="line">    <span class="keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>这里又可以分为两步，先是loadSpringFactories(classLoader)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态常量cache，用于缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache = <span class="keyword">new</span> ConcurrentReferenceHashMap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="comment">// 先从缓存中取</span></span><br><span class="line">MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取资源定位</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>) :</span><br><span class="line">ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            <span class="comment">// 遍历元素，添加到集合中</span></span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line"><span class="keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 以classloader为key,放入cache</span></span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <br></p><p>​    就是加载类路径下中所有的spring.factories，把他们放入一个map中，然后getOrDefault(factoryTypeName, Collections.emptyList()); 获取以org.springframework.context.ApplicationContextInitializer为key的所有值.然后放入Set&lt;String&gt; names  = new LinkedHashSet&lt;&gt;(..）中</p><p>​    紧接着是这一行</p><p>  List<T> instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</T></p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">createSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="params"><span class="function">      ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">   List&lt;T&gt; instances = <span class="keyword">new</span> ArrayList&lt;&gt;(names.size());</span><br><span class="line">   <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">         Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);</span><br><span class="line">         T instance = (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">         instances.add(instance);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot instantiate &quot;</span> + type + <span class="string">&quot; : &quot;</span> + name, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>循环遍历刚刚拿到的集合，然后反射去创建实例</p><h1 id="applcaiton-run-args"><a href="#applcaiton-run-args" class="headerlink" title="applcaiton.run(args)"></a>applcaiton.run(args)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// stopwatch记录开始</span></span><br><span class="line">   StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">   stopWatch.start();</span><br><span class="line">   ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   configureHeadlessProperty();</span><br><span class="line">   <span class="comment">//1、 获取org.springframework.boot.SpringApplicationRunListener监听器</span></span><br><span class="line">   SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">   <span class="comment">// 事件ApplicationStartingEvent发布 </span></span><br><span class="line">   listeners.starting();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">      <span class="comment">// 2、读取配置文件appcaiton.yml...</span></span><br><span class="line">      ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">      configureIgnoreBeanInfo(environment);</span><br><span class="line">      <span class="comment">// 打印banner</span></span><br><span class="line">      Banner printedBanner = printBanner(environment);</span><br><span class="line">      <span class="comment">// 3、创建spring上下文</span></span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">            <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">      <span class="comment">// 4、初始化上下文</span></span><br><span class="line">      prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">      <span class="comment">// 5、refresh方法</span></span><br><span class="line">      refreshContext(context);</span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line">      listeners.started(context);</span><br><span class="line">      callRunners(context, applicationArguments);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      listeners.running(context);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1、-获取SpringApplicationRunListener监听器与事件发布"><a href="#1、-获取SpringApplicationRunListener监听器与事件发布" class="headerlink" title="1、 获取SpringApplicationRunListener监听器与事件发布*"></a>1、 获取SpringApplicationRunListener监听器与事件发布*</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title">getRunListeners</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有参构造方法所需参数</span></span><br><span class="line">   Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationRunListeners(logger,</span><br><span class="line">         getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class="keyword">this</span>, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>1.1 getSpringFactoriesInstances</strong></li></ul><p><code>getSpringFactoriesInstances</code>就是new SpringApplication()里面所看到的，这次会从缓存cache中直接获取key为<code>org.springframework.boot.SpringApplicationRunListeners</code>所有的值，并反射创建其实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">   ClassLoader classLoader = getClassLoader();</span><br><span class="line">   Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">   List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">   AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">   <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认有一个 <code>org.springframework.boot.context.event.EventPublishingRunListener</code>；在Springboot的官方包里有配置</p><p><img src="/colinstar/colinstar/2022/06/18/Springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/git_repository\hexo_workspace\blog\source_posts\Springboot自动装配\image-20220619142930921.png" alt="image-20220619142930921"></p><p>值得注意的是，在反射创建SpringApplicationRunListeners实例时，会调用其有参构造方法，将application，和args传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventPublishingRunListener</span><span class="params">(SpringApplication application, String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.application = application;</span><br><span class="line">   <span class="keyword">this</span>.args = args;</span><br><span class="line">   <span class="comment">// 创建事件多播器</span></span><br><span class="line">   <span class="keyword">this</span>.initialMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster();</span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</span><br><span class="line">      <span class="comment">// 将监听器添加到事件多播器中</span></span><br><span class="line">      <span class="keyword">this</span>.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意此处 application.getListeners()中，其值就是在new Applicaiton()中添加的；代码如下一行所示</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br></pre></td></tr></table></figure><ul><li><strong>1.2</strong> <strong>new SpringApplicationRunListeners()</strong></li></ul><p>再看看new SpringApplicationRunListeners()；构造器里只是做了赋值；将反射创建的实例EventPublishingRunListener赋值进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationRunListeners(Log log, Collection&lt;? extends SpringApplicationRunListener&gt; listeners) &#123;</span><br><span class="line">   this.log = log;</span><br><span class="line">   this.listeners = new ArrayList&lt;&gt;(listeners);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>1.3 listeners.starting()</strong></li></ul><p>调用SpringApplicationRunListeners的starting方法,里面就是循环listeners，然后调用其实现的starting()方法；此时此处的listeners里面就一个刚刚反射创建的EventPublishingRunListener。又会去调用它的starting方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="keyword">this</span>.listeners) &#123;</span><br><span class="line">      listener.starting();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>EventPublishingRunListener.starting();</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// initialMulticaster多播器里面，装的都是初始化SpringApplicaiton时，从Spring.factories中加载、并反射创建的实例</span></span><br><span class="line">   <span class="comment">// 注意此处的是将类型为:ApplicationStartingEvent</span></span><br><span class="line">   <span class="keyword">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> ApplicationStartingEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>multicastEvent方法会去调用实现了ApplicationListener&lt;ApplicationStartingEvent&gt;的实现类；(一开始会发布一个ApplicationStartingEvent事件)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">   multicastEvent(event, resolveDefaultEventType(event));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">   ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">   Executor executor = getTaskExecutor();</span><br><span class="line">   <span class="comment">// getApplicationListeners(event, type)获取对应事件类型的listeners</span></span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">         executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         invokeListener(listener, event);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、读取配置文件"><a href="#2、读取配置文件" class="headerlink" title="2、读取配置文件"></a>2、读取配置文件</h2><p><strong>ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class="line">   ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">   configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">   ConfigurationPropertySources.attach(environment);</span><br><span class="line">   <span class="comment">// 发布ApplicationEnvironmentPreparedEvent事件</span></span><br><span class="line">   listeners.environmentPrepared(environment);</span><br><span class="line">   bindToSpringApplication(environment);</span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.isCustomEnvironment) &#123;</span><br><span class="line">      environment = <span class="keyword">new</span> EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">            deduceEnvironmentClass());</span><br><span class="line">   &#125;</span><br><span class="line">   ConfigurationPropertySources.attach(environment);</span><br><span class="line">   <span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springboot里面配置文件的加载，也是通过事件监听器完成的，此处会发布ApplicationEnvironmentPreparedEvent事件，在<code>ConfigFileApplicationListener</code> 类中。会去完成配置文件的加载</p><p><code>public class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered</code> </p><h2 id="3、创建上下文"><a href="#3、创建上下文" class="headerlink" title="3、创建上下文"></a>3、创建上下文</h2><p><strong>context = createApplicationContext();</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">   <span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line">         <span class="keyword">case</span> SERVLET:</span><br><span class="line">            <span class="comment">// 根据web类型，如果是SERVLET，创建AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">            contextClass = Class.forName(<span class="string">&quot;org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> REACTIVE:</span><br><span class="line">            contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">               <span class="string">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AnnotationConfigServletWebServerApplicationContext</code>继承自<code>ServletWebServerApplicationContext</code></p><h2 id="4、初始化上下文"><a href="#4、初始化上下文" class="headerlink" title="4、初始化上下文"></a>4、初始化上下文</h2><p> <strong>prepareContext(context, environment, listeners, applicationArguments, printedBanner);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="params"><span class="function">      SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">   context.setEnvironment(environment);</span><br><span class="line">   postProcessApplicationContext(context);</span><br><span class="line">   applyInitializers(context);</span><br><span class="line">   listeners.contextPrepared(context);</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">      logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">      logStartupProfileInfo(context);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">   beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line">   <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">      ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">            .setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.lazyInitialization) &#123;</span><br><span class="line">      context.addBeanFactoryPostProcessor(<span class="keyword">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">   &#125;</span><br><span class="line">   Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">   Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">   <span class="comment">// 读取配置类</span></span><br><span class="line">   load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">   <span class="comment">// 发布ConfigurableApplicationContext事件</span></span><br><span class="line">   listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Class&lt;?&gt; source)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (isGroovyPresent() &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) &#123;</span><br><span class="line">      <span class="comment">// Any GroovyLoaders added in beans&#123;&#125; DSL can contribute beans here</span></span><br><span class="line">      GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);</span><br><span class="line">      load(loader);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (isEligible(source)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.annotatedReader.register(source);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">        registerBean(componentClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、refresh"><a href="#5、refresh" class="headerlink" title="5、refresh"></a>5、refresh</h2><p>  <strong>refreshContext(context);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">   applicationContext.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 解析配置类，@Bean/@Import/@ImportSource/@ComponentScan等;将他们创建成beanDefinition</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 这里会去创建内嵌tomcat</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化bean</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h1><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>通过@Import( {类名.class,类名.classs…} )，直接导入某个类的方式，将类加入到spring的IOC容器中</p><p><strong>ImportSelector</strong></p><p>@Import({类名.class})，其中类实现ImportSelector接口，重写selectImports方法，返回值就是要导入bean的全类名</p><p>参数AnnotationMetadata 就是被import注解的类的所有注解信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Import(User.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        </span><br><span class="line">        Set&lt;String&gt; annotationTypes = annotationMetadata.getAnnotationTypes();</span><br><span class="line">        <span class="keyword">for</span> (String annotationType : annotationTypes) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---&gt;&quot;</span>+ annotationType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印内容</span></span><br><span class="line">       <span class="comment">// ---&gt;org.springframework.stereotype.Component</span></span><br><span class="line"><span class="comment">// ---&gt;org.springframework.context.annotation.Import</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;com.example.Colin&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ImportBeanDefinitionRegistrar</strong></p><p>自定义类实现ImportBeanDefinitionRegistrar接口，重写其registerBeanDefinitions方法；最后通过@Import将这个类导入进来</p><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><p>springboot启动类上通常会加上@SpringBootApplicaiton注解，而在此注解上又有@EnableAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration </span><br></pre></td></tr></table></figure><p>可以看到里面有用到@Import导入了AutoConfigurationImportSelector类，其实现了<code>DeferredImportSelector</code>接口；继承该接口的 ImportSelector会在所有@Configuration配置类处理完后运行</p><p><code>DeferredImportSelector</code>继承了<code>ImportSelector</code>，<code>AutoConfigurationImportSelector</code>重写了<code>selectImports</code>方法</p><p>并且！还重写了<code>DeferredImportSelector</code>中的<code>getImportGroup</code>方法.springboot加载的时候会去判断，如果重写了此方法，返回一个class，就会去调用class对饮的process方法，在这个方法里，会去分组，主要为了保证加载的顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;? extends Group&gt; getImportGroup() &#123;</span><br><span class="line">   <span class="keyword">return</span> AutoConfigurationGroup.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> </span>&#123;</span><br><span class="line">   Assert.state(deferredImportSelector <span class="keyword">instanceof</span> AutoConfigurationImportSelector,</span><br><span class="line">         () -&gt; String.format(<span class="string">&quot;Only %s implementations are supported, got %s&quot;</span>,</span><br><span class="line">               AutoConfigurationImportSelector.class.getSimpleName(),</span><br><span class="line">               deferredImportSelector.getClass().getName()));</span><br><span class="line">   AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">         .getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">   <span class="keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);</span><br><span class="line">   <span class="keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内嵌tomcat"><a href="#内嵌tomcat" class="headerlink" title="内嵌tomcat"></a>内嵌tomcat</h1><p>导入tomcat依赖，然后可以通过如下代码创建tomcat，并可以添加servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String contextPath = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">        tomcat.setPort(<span class="number">8099</span>);</span><br><span class="line">        String baseDir = Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;&quot;</span>).getPath();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Context context = tomcat.addContext(contextPath, baseDir);</span><br><span class="line">            context.addServletContainerInitializer( (c,servletContext) -&gt; &#123;</span><br><span class="line">                ServletRegistration.Dynamic testServlet = servletContext.addServlet(<span class="string">&quot;testServlet&quot;</span>, <span class="keyword">new</span> TestServlet());</span><br><span class="line">                testServlet.addMapping(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line">            &#125;,<span class="keyword">null</span>);</span><br><span class="line">            tomcat.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        tomcat.getServer().await();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    启动Springboot代码很简单，直接一行代码&lt;code&gt;SpringApplication.run(class,args)&lt;/code&gt;搞定，其实这一步可以拆解成两步，SpringApplication.run方法里面，其实也是先new SpringAppli</summary>
      
    
    
    
    <category term="springboot" scheme="http://c89757.gitee.io/colinstar/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://c89757.gitee.io/colinstar/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>maven打包报错:Malformed \uxxx encoding</title>
    <link href="http://c89757.gitee.io/colinstar/2022/06/09/maven%E6%89%93%E5%8C%85%E6%8A%A5%E9%94%99-Malformed-uxxx-encoding/"/>
    <id>http://c89757.gitee.io/colinstar/2022/06/09/maven%E6%89%93%E5%8C%85%E6%8A%A5%E9%94%99-Malformed-uxxx-encoding/</id>
    <published>2022-06-09T14:27:51.000Z</published>
    <updated>2022-06-09T15:16:01.862Z</updated>
    
    <content type="html"><![CDATA[<br><p>​    在最近一次项目构建中，执行<code>mvn clean package</code>却报出<code>Malformed \uxxx encoding</code>的错误。查阅资料后，给出了以下几种解决方式：</p><ul><li>删除~/.m2/repository/path-to-the-library的包</li><li>将项目中的<code>/</code>更改为<code>\</code></li></ul><br><p>对我来说都不得行，最后查阅到有人说是<code>resolver-status.properties</code>损坏，里面包含了\u0000，</p><p>然后我就根据Maven提示，带上参数 -e - X 执行命令：Maven -e - X clean package，日志打印出是哪个包报错，</p><p>最后来到仓库中，删除对应的<code>resolver-status.properties</code>文件，再次构建成功！</p><hr><p>那<code>resolver-status.properties</code>文件是干嘛的呢？</p><hr><br><p>Maven更新本地仓库的步骤是：先更新元文件，再根据元文件去更新本地仓库jar包</p><p>而元文件有三个<code>maven-metadata-local.xml</code>，<code>maven-metadata-snapshot-nexus.xml</code>，<code>resolver-status.properties</code></p><br><ul><li>maven-metadata-local.xml</li></ul><p>在本地install代码后会生成该文件，记录的是本地项目编译的时间戳</p><br><ul><li>maven-metadata-snapshot-nexus.xml</li></ul><p>从远程仓库拉取jar包后，会同时从仓库下载该元文件，该文件记录的是远程仓库上项目最新版本的时间</p><br><ul><li>resolver-status.properties</li></ul><p>从远程仓库拉取jar包的时候，也会生成该文件，并且每次拉取都会更新。该文件主要作用是记录maven-metadata–nexus.xml 文件的上次更新时间戳，并结合标签完成更新策略的一部分</p><br><p><strong>更新本地jar包</strong>：依赖于 maven-metadata-local.xml 和 maven-metadata-snapshot-nexus.xml 两个文件</p><ul><li>如果只有 maven-metadata-local.xml 文件，一般来说是配置有错，或者并没有从远程仓库中拉取过jar包</li><li>如果两个文件都有，每次都需要比较一下两个文件的时间戳，即标签上的时间戳。<ul><li>如果local.xml的时间戳比snapshot.xml的时间戳要新，就不会从远程仓库下载；</li><li>如果local.xml的时间戳比snapshot.xml的时间戳要旧，就会去检查一下本地maven仓库的该项目文件夹路径下是否有snapshot.xml对应版本的jar包</li><li>如果没有该版本的jar包，就会从远程仓库拉取该版本的jar包</li><li>如果有该版本的jar包，就不会做任何行为</li></ul></li></ul><br><p><strong>更新本地元文件</strong>：更新本地仓库jar包决定于本地元文件 maven-metadata-snapshot-nexus.xml，该文件的更新取决于resolver-status.properties文件</p><ul><li>先去远程仓库获取maven-metadata-snapshot-nexus.xml文件，远程仓库中不存在此文件，那么会走下载流程</li><li>如果存在，读取resolver-status.properties中的lastUpdated参数，然后与当前的时间做比较，根据跟新策略是否需要下载（always/never/daily…)</li></ul><br><br><p>附上stackOverflow上的回答：<a href="https://stackoverflow.com/questions/68003423/java-lang-illegalargumentexception-malformed-uxxxx-encoding-while-mvn-install">https://stackoverflow.com/questions/68003423/java-lang-illegalargumentexception-malformed-uxxxx-encoding-while-mvn-install</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;p&gt;​    在最近一次项目构建中，执行&lt;code&gt;mvn clean package&lt;/code&gt;却报出&lt;code&gt;Malformed \uxxx encoding&lt;/code&gt;的错误。查阅资料后，给出了以下几种解决方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除~/.m2</summary>
      
    
    
    
    
    <category term="maven" scheme="http://c89757.gitee.io/colinstar/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>restTemplate</title>
    <link href="http://c89757.gitee.io/colinstar/2022/06/01/restTemplate/"/>
    <id>http://c89757.gitee.io/colinstar/2022/06/01/restTemplate/</id>
    <published>2022-06-01T12:26:08.000Z</published>
    <updated>2022-06-09T15:25:23.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><br><p>最近项目有个新需求，需要将原来的接口支持https，虽然之前也有用过restTemplate，但一直未对其进行过深入了解，今天便来看一看</p><p>官方文档：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#rest-client-accessRestTemplate">https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#rest-client-accessRestTemplate</a></p><br><img src="/colinstar/2022/06/01/restTemplate/image-20220601203121291.png" class><p>有两种方法可以创建restTemplate实例，一种是直接new，另一种是通过构建者构建出来</p><ul><li>new</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接new</span></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以调用有参构造，传入一个ClientHttpRequestFactory的实现类</span></span><br><span class="line">SimpleClientHttpRequestFactory factory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br><span class="line">factory.setConnectTimeout(<span class="number">3000</span>);</span><br><span class="line">factory.setReadTimeout(<span class="number">3000</span>);</span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate(factory);</span><br></pre></td></tr></table></figure><ul><li>build</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplateBuilder()</span><br><span class="line">    .basicAuthentication(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .setConnectTimeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">                .setReadTimeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">                .rootUri(<span class="string">&quot;http://example/base/&quot;</span>)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><ul><li>postForEntity</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line">HttpHeaders header = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">header.add(<span class="string">&quot;auth&quot;</span>,<span class="string">&quot;bearer ****&quot;</span>);</span><br><span class="line">HttpEntity&lt;UserReqInfo&gt; httpEntity = <span class="keyword">new</span> HttpEntity&lt;&gt;(<span class="keyword">new</span> UserReqInfo(),header);</span><br><span class="line">ResponseEntity&lt;UserRespInfo&gt; orderResponseEntity = restTemplate.postForEntity(url, httpEntity, UserRespInfo.class);</span><br></pre></td></tr></table></figure><p>对于基本类型和实体传参，必须使用MultiValueMap传参    </p><p>​    什么是基本类型和实体传参呢？类似于form表单，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(UserDTO userDTO,Integer requestId)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>而对于@Requestbody传参，需要使用HttpEntity传参</p><ul><li>exhange</li></ul><p>exchange有以下几种重载方法</p><br><img src="/colinstar/2022/06/01/restTemplate/image-20220601211450632.png" class><br><p>url：请求路径</p><p>method：请求方法</p><p>requestEntity：封装请求头和请求体</p><p>responseType：返回数据类型</p><p>uriVariables：支持PathVariable类型的数据</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line"><span class="comment">// 创建http的header</span></span><br><span class="line">HttpHeaders header = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">header.add(<span class="string">&quot;auth&quot;</span>,<span class="string">&quot;bearer ****&quot;</span>);</span><br><span class="line">header.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">String json = gson.toJson(<span class="keyword">new</span> UserReqInfo()); <span class="comment">// UserReqInfo自定义实体类</span></span><br><span class="line"><span class="comment">// 设置请求体和请求头</span></span><br><span class="line">HttpEntity&lt;String&gt; httpEntity = <span class="keyword">new</span> HttpEntity&lt;&gt;(json,header);</span><br><span class="line">ResponseEntity&lt;UserRespInfo&gt; exchange = restTemplate.exchange(url, HttpMethod.POST, httpEntity, UserRespInfo.class); <span class="comment">// UserRespInfo自定义实体类 </span></span><br></pre></td></tr></table></figure><ul><li>execute</li></ul><p>restTemplate的所有get,post等等方法，最终都是调用的execute方法。</p><br><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>初始化</p><br><p>默认使用HttpUrlConnection，可以通过构造方法传入一个ClientHttpRequestFactory的实现类，以此来替换底层的执行引擎，常见的执行引擎包括HttpClient、Netty、OKHttp。</p><img src="/colinstar/2022/06/01/restTemplate/image-20220601232938164.png" class><br><br><p>无参构造</p><p>调用RestTemplate无参构造初始化时，会去调用父类<code>InterceptingHttpAccessor</code>的无参构造，其又会去调用顶级父类<code>HttpAccessor</code>的无参构造，虽然无参构造啥也没做，但是可以看到，默认的ClientHttpRequestFactory在类加载时已经初始化为<code>SimpleClientHttpRequestFactory</code>了</p><img src="/colinstar/2022/06/01/restTemplate/image-20220601233400136.png" class><br><br><p>有参构造</p><p>我们可以先创建一个<code>HttpComponentsClientHttpRequestFactory</code>的实例，该类的执行引擎用的是HttpClient</p><img src="/colinstar/2022/06/01/restTemplate/image-20220602002129124.png" class><br><p>exchange（）方法</p><br><img src="/colinstar/2022/06/01/restTemplate/image-20220602002305195.png" class>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;br&gt;

&lt;p&gt;最近项目有个新需求，需要将原来的接口支持https，虽然之前也有用过restTemplate，但一直未对其进行过深入了解，今天便</summary>
      
    
    
    
    
    <category term="spring" scheme="http://c89757.gitee.io/colinstar/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://c89757.gitee.io/colinstar/2022/03/24/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://c89757.gitee.io/colinstar/2022/03/24/%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2022-03-24T11:44:57.000Z</published>
    <updated>2022-03-25T09:00:20.941Z</updated>
    
    <content type="html"><![CDATA[<br><p>​        堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最好，最坏，平均时间复杂度均为<strong>O（nlogn）</strong>,它也是不稳定的排序</p><p>堆是具有以下性质的完全二叉树：    </p><ol><li><p>每个结点的值都大于或等于其左右孩子节点的值，称为大顶堆</p><p>注意：没有要求结点的左孩子的值和右孩子的值的大小关系</p></li><li><p>每个结点的值都小于或等于其左右孩子的结点，称为小顶堆</p></li></ol><br><p>大顶堆举例说明:</p><br><img src="/colinstar/2022/03/24/%E5%A0%86%E6%8E%92%E5%BA%8F/image-20220322182946818.png" class><br><br><p>我们对堆中的结点按照层次进行编号，映射到数组中就是下面这个样子：</p><br><p>[ 50 , 45 , 40 , 20 , 25 , 35 , 30 , 10 ,15]</p><br><p>大顶堆特点: arr[ i ] &gt;= arr [ 2 * i + 1 ] &amp;&amp; arr[ i ] &gt;= arr [ 2 * i + 2] // i对应第几个结点，i从0开始编号</p><br><p>小顶堆：</p><br><img src="/colinstar/2022/03/24/%E5%A0%86%E6%8E%92%E5%BA%8F/image-20220322183446701.png" class><br><br><p>小顶堆：arr [ i ] &lt; = arr [ 2 * i  + 1]   &amp;&amp;  arr [ i ] &lt;= arr [ 2 * i + 2] </p><br><blockquote><p>一般升序采用大顶堆，降序采用小顶堆</p></blockquote><br><p>堆排序基本思想：</p><p>1、将待排序序列构造成一个大顶堆</p><p>2、此时，整个序列的最大值就是顶堆的根节点</p><p>3、将其与末尾元素进行交换，此时末尾就为最大值</p><p>4、然后将剩余 n - 1个元素重新构造成一个堆，这样会得到 第n 个元素的次小值，如此反复执行，便能得到一个有序序列了</p><br><br><blockquote><p>例题：给定一个数组 { 4， 6 ，8 ，5 ，9 }，要求使用堆排序法，将数组升序排序</p></blockquote><br><p>图解：</p><br><p>step1：构造初始堆。将给定无序序列构造成一个大顶堆 （ 一般升序采用大顶堆，降序采用小顶堆）</p><br><p>1、假设给定无序序列结构如下：</p><img src="/colinstar/2022/03/24/%E5%A0%86%E6%8E%92%E5%BA%8F/image-20220322192151985.png" class><br><br><p>2、此时我们从最后一个非叶子结点开始（叶子结点不用调整，最后一个非叶子结点 arr.length / 2 -1 = 5 /2 - 1 = 1 , 也就是下面的6结点），从左至右，从下至上进行调整</p><p> <code>arr.length / 2 -1 怎么来的？</code> </p><p>最后一个结点对应的数组下标为 arr.lenth - 1 ; 而 父结点 为 i 的左孩子下标为：2 * i + 1 ; 右结点为 2 * i + 2; </p><img src="/colinstar/2022/03/24/%E5%A0%86%E6%8E%92%E5%BA%8F/image-20220322192231523.png" class><br><br><p>3、找到第二个非叶子节点4，先比较左右两边，9最大，4和9交换</p><img src="/colinstar/2022/03/24/%E5%A0%86%E6%8E%92%E5%BA%8F/image-20220322192258352.png" class><br><br><p>4、这时，交换导致了子根 【 4， 5， 6】结构混乱，继续调整， 【 4，5 ，6 】中 6 最大 ，交换 4 和 6</p><img src="/colinstar/2022/03/24/%E5%A0%86%E6%8E%92%E5%BA%8F/image-20220322192316002.png" class><br><br><blockquote><p><strong>此时，我们就将一个无序序列构造成了一个大顶堆</strong></p></blockquote><br><p>Step2：将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行</p><p>堆顶元素 9 和 末尾元素 4 进行交换</p><img src="/colinstar/2022/03/24/%E5%A0%86%E6%8E%92%E5%BA%8F/image-20220322192353585.png" class><br><br><p>交换后重新调整结构，使其满足堆定义</p><img src="/colinstar/2022/03/24/%E5%A0%86%E6%8E%92%E5%BA%8F/image-20220322192439126.png" class><br><br><p>再将堆顶元素8与末尾元素5进行交换，得到第二大元素8 </p><p>（ 9 已经搞完了，相当于把它剔除了，所以这里末尾元素是5）</p><img src="/colinstar/2022/03/24/%E5%A0%86%E6%8E%92%E5%BA%8F/image-20220322192527089.png" class><br><br><p>后续依次反复进行调整</p><br><p>总结：</p><ul><li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</li><li>将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端</li><li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行</li></ul><br><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将数组升序排列</span></span><br><span class="line">        <span class="keyword">int</span> array[] = &#123; <span class="number">4</span> ,<span class="number">6</span> ,<span class="number">8</span> ,<span class="number">5</span> ,<span class="number">9</span> &#125;;</span><br><span class="line">        heapSort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  0  1  2  3  4</span></span><br><span class="line"><span class="comment">     * [4 ,6 ,8 ,5 ,9 ]</span></span><br><span class="line"><span class="comment">     *            4</span></span><br><span class="line"><span class="comment">     *          /  \</span></span><br><span class="line"><span class="comment">     *         6    8</span></span><br><span class="line"><span class="comment">     *        / \</span></span><br><span class="line"><span class="comment">     *       8   9</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * step1 : 构造初始堆。将给定无序序列构造成一个大顶堆</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 最后一个非叶子节点 的下标为 array.length / 2 - 1;</span></span><br><span class="line">        <span class="comment">// 最后第二个非叶子节点 的下标为 最后一个非叶子结点的下标 - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i -- ) &#123;</span><br><span class="line">            adjustBigHeap(array,i, array.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * step2 : 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> root = array[<span class="number">0</span>]; <span class="comment">// 堆顶元素</span></span><br><span class="line">            <span class="comment">// 交换位置</span></span><br><span class="line">            array[<span class="number">0</span>] = array[length - <span class="number">1</span>];</span><br><span class="line">            array[length - <span class="number">1</span>] = root;</span><br><span class="line">            length -- ;</span><br><span class="line">            <span class="comment">// 重新调整堆</span></span><br><span class="line">            adjustBigHeap(array,<span class="number">0</span>,length); <span class="comment">// 0 ——&gt; 从堆顶开始调整</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个数组 (把数组当成二叉树的层次排序) 调整成一个大顶堆</span></span><br><span class="line"><span class="comment">     * 【以 index 为对应的非叶子节点的树进行调整 成大顶堆】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 待调整的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 非叶子结点在数组中的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 表示对多少个元素进行调整</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustBigHeap</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = array[index]; <span class="comment">// 先取出当前元素的值,存入临时变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始调整</span></span><br><span class="line">        <span class="comment">// 【 index * 2 + 1 】  左孩子的下标</span></span><br><span class="line">        <span class="comment">// 【 i = i * 2 + 1 】  继续往下调整，也就是左孩子的左孩子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index * <span class="number">2</span> + <span class="number">1</span>; i &lt; length; i = i * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( i + <span class="number">1</span> &lt; length &amp;&amp; array [ i ] &lt; array [ i + <span class="number">1</span> ])&#123; <span class="comment">// 左子结点 小于 右子结点</span></span><br><span class="line">                i = i + <span class="number">1</span>; <span class="comment">// i 指向右子节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( array [ i ] &gt; temp)&#123; <span class="comment">// 子节点 大于当前节点</span></span><br><span class="line">                <span class="comment">// 进行调换</span></span><br><span class="line">                array[ index ] = array[i]; <span class="comment">// 把较大得值赋给当前节点</span></span><br><span class="line">                <span class="comment">// array[i] = temp;</span></span><br><span class="line">                index = i; <span class="comment">// index 指向 与之调换的下标  逻辑上交换，物理上不交换</span></span><br><span class="line">                <span class="comment">// 继续循环比较</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for 循环结束后，已经将 以index为顶点 的树调整为大顶堆</span></span><br><span class="line">        array[index] = temp; <span class="comment">// 将temp放到调整后的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;p&gt;​        堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最好，最坏，平均时间复杂度均为&lt;strong&gt;O（nlogn）&lt;/strong&gt;,它也是不稳定的排序&lt;/p&gt;
&lt;p&gt;堆是具有以下性质的完全二叉树：    &lt;/p&gt;
&lt;ol</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://c89757.gitee.io/colinstar/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="堆" scheme="http://c89757.gitee.io/colinstar/tags/%E5%A0%86/"/>
    
    <category term="排序算法" scheme="http://c89757.gitee.io/colinstar/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized详解</title>
    <link href="http://c89757.gitee.io/colinstar/2022/01/15/Synchronized%E8%AF%A6%E8%A7%A3/"/>
    <id>http://c89757.gitee.io/colinstar/2022/01/15/Synchronized%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-01-15T14:11:43.000Z</published>
    <updated>2022-03-25T08:58:33.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计同步器的意义"><a href="#设计同步器的意义" class="headerlink" title="设计同步器的意义"></a>设计同步器的意义</h1><br><p>多线程编程中，有可能会出现多个线程同时访问同一个共享，可变资源的情况下，这个资源我们称之为临界资源；这种资源可能是：对象、变量、文件等</p><p>​    共享：资源可以由多个线程同时访问</p><p>​    可变：资源可以在其生命周期内被修改</p><p>由于线程执行的过程是不可控的，所以需要采用同步机制来协同对对象可变状态的访问</p><p>如何解决线程并发安全问题？</p><p>实际上，所有的并发模式在执行线程安全问题时，采用的方案都是序列化访问临界资源。即在同一时刻，只能有一个线程访问临界资源，也称作同步互斥访问</p><p>Java中，提供了两种方式来实现同步互斥访问：synchronized和lock同步器的本质就是加锁目的：序列化访问临界资源，即同一时刻只能有一个线程访问临界资源（同步互斥访问）</p><br><hr><p>synchronized内置锁是一种对象锁（锁的是对象而非引用），作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的</p><hr><br><h1 id="Synchronized底层原理"><a href="#Synchronized底层原理" class="headerlink" title="Synchronized底层原理"></a><strong>Synchronized底层原理</strong></h1><p>​    synchronized是基于JVM内置锁实现，通过内部对象Monitor(监视器锁），基于进入与退出Monitor对象实现方法与代码块同步，监视器锁的实现依赖底层操作系统的Mutex lock(互斥锁）实现，它是一个重量级锁，性能较低。当然，JVM内置锁在1.5之后版本做了重大的优化，如锁粗化(Lock Coarsening),锁消除（Lock Elimination）,轻量级锁（Lightweight Locking)、偏向锁（Biased Locking)、适应性自旋（Adaptive Spinning)等技术来减少锁操作的开销，内置锁的并发性能已经基本与Lock持平。Synchronized关键字被编译成字节码后会被翻译成 monitorenter 和monitorexit 两条指令分别在同步块逻辑代码的起始位置与结束位置</p><br><img src="/colinstar/2022/01/15/Synchronized%E8%AF%A6%E8%A7%A3/1.png" class><br><br><p>每个对象都有一个自己的monitor(监视器锁)，加锁过程如下</p><br><img src="/colinstar/2022/01/15/Synchronized%E8%AF%A6%E8%A7%A3/2.png" class><br><br><h2 id="Monitor监视器锁"><a href="#Monitor监视器锁" class="headerlink" title="Monitor监视器锁"></a>Monitor监视器锁</h2><p>​    <br></p><p>​    任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p><p><strong>monitorenter</strong>：每个对象都是一个监视器锁（Monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><ul><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者<ul><li>如果该线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1</li><li>如果其他线程占有该monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权</li></ul></li></ul><p><strong>monitorexit：</strong>执行monitorexit的线程必须是object ref对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor,步再是这个monitor的所有者，其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权</p><br><p>​    Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>经过javap解析后如下</p><br><img src="/colinstar/2022/01/15/Synchronized%E8%AF%A6%E8%A7%A3/3.png" class><br><br><p>​    方法的同步并没有通过指令 monitorenter 和 monitorexit 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED 标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个 monitor对象。</p><br><h2 id="什么是monitor"><a href="#什么是monitor" class="headerlink" title="什么是monitor?"></a><strong>什么是monitor?</strong></h2><p>​    <br></p><p>​    可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的java对象是天生的Monitor，每一个Java对象都有称为Monitor的潜质，因为在java的设计中，每一个Java对象自生成就带了把看不见的锁，它叫做内置锁或者Monitor锁；也就是通常说的Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始位置；在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）</p><p>​    <br></p><p>​    我们知道synchronized加锁加在对象上，对象是如何记录锁状态的呢？答案是锁状态是被记录在每个对象的对象头（Mark Word）中，下面我们一起认识一下对象的内存布局</p><br><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>​    <br></p><p>​    HotSpot虚拟机中，对象在内存中存储的布局分为三块区域：对象头（Header)、示例数据（Instance Data）和对齐填充（Padding）</p><br><img src="/colinstar/2022/01/15/Synchronized%E8%AF%A6%E8%A7%A3/4.png" class><br><br><ul><li><p>对象头：保存对象的Hash码，GC年龄，对象锁，锁状态标致，偏向锁（线程）ID，偏向时间等，如果是数组对象，还会保存数组的长度。Java对象头一般占有2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit)；但是如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确定数组的大小，所以用一块来记录数组的长度</p></li><li><p>实例数据：存放类的属性数据信息，包括父类的属性信息</p></li><li><p>对齐填充：由于虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐</p></li></ul><br><p>​        HotSpot虚拟机的对象头包括两部分信息，第一部分是”Mark Word”，用于存储对象自身的运行时数据，如哈希码（HashCode），GC分代年龄、锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等等，它是实现轻量级锁和偏向锁的关键。这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别位32个和64个Bits，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如：在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示</p><br><p>32位虚拟机</p><br><img src="/colinstar/2022/01/15/Synchronized%E8%AF%A6%E8%A7%A3/5.png" class><br><br><p>64位虚拟机</p><br><img src="/colinstar/2022/01/15/Synchronized%E8%AF%A6%E8%A7%A3/6.png" class><br><br><p>现在的虚拟机基本上是64位的，而64位的对象头有点浪费空间，JVM默认会开启指针压缩，所以基本上也是按32位的形式记录对象头的。</p><p>手动设置: -XX:+UseCompressedOops</p><br><p><strong>哪些信息会被压缩？</strong></p><p>1.对象的全局静态变量(即类属性)</p><p>2.对象头信息：64位平台下，原生对象头大小为16字节，压缩后为12字节</p><p>3.对象的引用类型：64位平台下，引用类型本身大小为8字节，压缩后为4字节</p><p>4.对象数组类型：64位平台下，数组类型本身大小为24字节，压缩后16字节</p><h2 id="对象头分析工具"><a href="#对象头分析工具" class="headerlink" title="对象头分析工具"></a>对象头分析工具</h2><br><p>OpenJDK开源工具包，JOL，maven坐标如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 打印markword</span></span><br><span class="line">    System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>打印出来的对象内存信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)<span class="comment">//Mark Word</span></span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure><br><p>第一行为Mark Word </p><p>00000001 00000000 00000000 00000000</p><p>对象此时是无锁状态，前25位表示hashcode值，<strong>为什么hashcode是0？</strong></p><p>因为这个hashcode是jvm内置函数，类似于懒加载，此时还没有计算</p><br><p><strong>此时将代码修改为如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>打印的Mark Word为  00011000 11110111 00000010 00000010</p><p>即    00000010 00000010 11110111 00011000</p><p>发现对象头从无锁——&gt;轻量级锁</p><br><p><strong>为什么不是偏向锁？</strong></p><p>​    因为JVM会延迟去启动偏向锁，JVM启动时依赖大量的hashMap class对象等，这些对象里面也存在大量的同步块，JVM启动时内部也会去启动十几个线程，这些线程内部也会存在竞争，JVM为了避免造成 偏向锁 到 轻量级锁 到重量级锁 这种锁升级过程，减少锁升级的开销，所以把偏向锁推迟启动了</p><br><p>将代码睡眠几秒钟</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           a8 f7 <span class="number">06</span> <span class="number">03</span> (<span class="number">10101000</span> <span class="number">11110111</span> <span class="number">00000110</span> <span class="number">00000011</span>) (<span class="number">50788264</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure><br><p>第一次打印的：00000101 00000000 00000000 00000000  就已经是偏向锁状态了，但是偏向锁的前23bit位会记录线程ID，此处并没有，这种 称之为匿名偏向，可偏向状态</p><br><p>如果一直处于偏向状态，无法重偏向的话，那么MarkWord会一直记录最后一个偏向线程的状态</p><br><h2 id="锁的膨胀升级过程"><a href="#锁的膨胀升级过程" class="headerlink" title="锁的膨胀升级过程"></a>锁的膨胀升级过程</h2><p>​        <br></p><p>​        锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁，但是锁的升级是单向的，也就是只能从低到高升级，不会出现锁的降级。从JDK1.6中默认是开启偏向锁和轻量级的，可以通过-XX:-UseBiasedLocking来禁用偏向锁</p><br><h3 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a><strong>偏向锁：</strong></h3><p>​    偏向锁是Java6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁（会涉及到一些CAS操作，耗时）的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提高了程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p><p>默认开启偏向锁</p><p>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 </p><p>关闭偏向锁：-XX:-UseBiasedLocking</p><br><h3 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a><strong>轻量级锁：</strong></h3><p>​        倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时，Mark Word的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁</p><br><p><strong>自旋锁：</strong></p><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程就可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环（这也是称为自旋的原因），一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。后没办法也就只能升级为重量级锁</p><br><p><strong>锁消除:</strong></p><p>​        消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。锁消除的依据是逃逸分析的数据支持</p><p>锁消除，前提是Java必须运行在server模式，（server模式会比client模式作更多的优化），同时必须开启逃逸分析</p><p>-XX:+DoEscapeAnalysis 开启逃逸分析</p><p>-XX:+EliminateLocks  表示开启锁消除</p><br><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ol><li>同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li><li>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li><li>分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计同步器的意义&quot;&gt;&lt;a href=&quot;#设计同步器的意义&quot; class=&quot;headerlink&quot; title=&quot;设计同步器的意义&quot;&gt;&lt;/a&gt;设计同步器的意义&lt;/h1&gt;&lt;br&gt;

&lt;p&gt;多线程编程中，有可能会出现多个线程同时访问同一个共享，可变资源的情况下，这个资源</summary>
      
    
    
    
    <category term="JUC" scheme="http://c89757.gitee.io/colinstar/categories/JUC/"/>
    
    
    <category term="JUC" scheme="http://c89757.gitee.io/colinstar/tags/JUC/"/>
    
    <category term="多线程" scheme="http://c89757.gitee.io/colinstar/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Netty</title>
    <link href="http://c89757.gitee.io/colinstar/2022/01/06/Netty/"/>
    <id>http://c89757.gitee.io/colinstar/2022/01/06/Netty/</id>
    <published>2022-01-06T12:58:22.000Z</published>
    <updated>2022-03-25T08:55:54.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BIO-amp-NIO-amp-AIO"><a href="#BIO-amp-NIO-amp-AIO" class="headerlink" title="BIO&amp;NIO&amp;AIO"></a>BIO&amp;NIO&amp;AIO</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><br><img src="/colinstar/2022/01/06/Netty/BIO%E6%A8%A1%E5%9E%8B.jpg" class><br><br><p>​    blocking  I/O , 即阻塞IO，同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）</p><br><p>先看单线程的版本</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            log.info(<span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">            <span class="keyword">if</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">                log.info(<span class="string">&quot;收到消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">            &#125;</span><br><span class="line">            socket.getOutputStream().write(<span class="string">&quot;已成功接收到消息&quot;</span>.getBytes());</span><br><span class="line">            socket.getOutputStream().flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><p>Debug启动程序，在serverSocket.accept()处打上断点，同时再下一行处也打上断点，然后我们点击idea调试的Resume Program按钮，让程序直接走完；我们会发现断点没有到达下一行，程序也没有停止，而是阻塞在了accept()里。</p><br><img src="/colinstar/2022/01/06/Netty/image-20211228135209446.png" class><br><br><p>我们试着用telnet工具去连接程序</p><br><img src="/colinstar/2022/01/06/Netty/image-20211228135657845.png" class><br><br><p>按下回车连接的同时，我们也会发现程序的断点跑到了下一行</p><br><img src="/colinstar/2022/01/06/Netty/image-20211228135818793.png" class><br><br><p>我们再在 int read = inputStream.read(bytes);这一行及其下一行也打上断点；</p><br><img src="/colinstar/2022/01/06/Netty/image-20211228140749246.png" class><br><br><p>程序来到inputStream.read(bytes)这一行，我们再次选择放掉这一个断点，发现此处程序也并没有来到下一行，也是在此处进行了阻塞</p><br><img src="/colinstar/2022/01/06/Netty/image-20211228140830135.png" class><br><br><p>我们用telnet工具给服务端发送消息</p><br><img src="/colinstar/2022/01/06/Netty/image-20211228141003312.png" class><br><br><p>回到程序，发现程序执行到了下一行</p><br><img src="/colinstar/2022/01/06/Netty/image-20211228141032475.png" class><br><br><p>接下来我们重新开始，重新启动服务端，开启一个telnet（客户端1）去连接，但是不发送消息，让程序阻塞在int read = inputStream.read(bytes)这一行；与此同时，我们再另外开启一个telnet客户端（客户端2）去进行连接，然后发送消息给服务端</p><br><img src="/colinstar/2022/01/06/Netty/image-20211228141938073.png" class><br><br><p>但是我们发现，控制台并没有任何消息打印；</p><p>我们此时在用客户端1去发送消息</p><br><img src="/colinstar/2022/01/06/Netty/image-20211228142756229.png" class><br><br><p>发现客户端打印消息，但是打印hello2之前，输出了”建立连接“；说明此时我们其实客户端2并没有真正的连接上，而是阻塞在了serverSocket.accept()处</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">log.info(<span class="string">&quot;建立连接&quot;</span>);</span><br></pre></td></tr></table></figure><br><img src="/colinstar/2022/01/06/Netty/image-20211228143047146.png" class><br><br><blockquote><p><strong>在同一时刻，服务端只能响应一个客户端</strong></p></blockquote><br><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们可以在将代码改成多线程版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBIO</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestBIO</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">        log.info(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            log.info(<span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">            threadPoolExecutor.execute(<span class="keyword">new</span> TestBIO(socket));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>)&#123; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">        <span class="keyword">if</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;收到消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">        &#125;</span><br><span class="line">        socket.getOutputStream().write(<span class="string">&quot;已成功接收到消息&quot;</span>.getBytes());</span><br><span class="line">        socket.getOutputStream().flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler(<span class="keyword">this</span>.socket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>我们再实验以上步骤</p><p>先开启telnet客户端1去连接阻塞，但是不发送消息</p><p>再开启telnet客户端2去连接，并发送消息</p><p>结果此次控制台能正确接收到消息</p><br><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a><strong>存在的问题</strong></h3><p>​    如果开辟大量线程，比较消耗资源，且如果我们用了线程池，如果我们线程池数量是500，某一瞬间并发量有1w，那后面的请求就只能阻塞等待。又或者500线程池，其中400个线程只是和你建立连接，并不立马发送消息给服务端，那这个线程会一直被这个连接给占用，其他人无法获取; 又或者用完线程给别人用时，线程的切换也是比较消耗资源的</p><ul><li>IO代码里read操作是阻塞操作，如果连接不做数据读写会导致线程阻塞，浪费资源</li><li>如果线程很多，会导致服务器线程太大，压力太大</li></ul><p>应用场景：BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高</p><br><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>​    Non Blocking IO,或者读为New IO,同步非阻塞，服务器实现模式为<strong>一个线程可以处理多个请求（连接）</strong>，客户端发送的连接请求都会注册到<strong>多路复用器selector</strong>上，多路复用器轮询到连接有IO请求就进行处理，JDK1.4开始引入</p><br><img src="/colinstar/2022/01/06/Netty/image-20211229140326931.png" class><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;SocketChannel&gt; channelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 非阻塞模式accept方法不会阻塞，否则会阻塞</span></span><br><span class="line">            <span class="comment">// NIO的非阻塞是由操作系统内部实现的，底层调用了linux内核的accept函数</span></span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123; <span class="comment">// 如果有客户端进行连接</span></span><br><span class="line">                log.info(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                <span class="comment">// 设置SocketChannel为非阻塞</span></span><br><span class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 保存客户端连接在list中</span></span><br><span class="line">                channelList.add(socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历连接进行数据读取</span></span><br><span class="line">            Iterator&lt;SocketChannel&gt; iterator = channelList.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SocketChannel next = iterator.next();</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                <span class="comment">// 非阻塞模式read方法不会阻塞</span></span><br><span class="line">                <span class="keyword">int</span> len = next.read(byteBuffer);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;接收到消息: &#123;&#125;&quot;</span>, <span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123; <span class="comment">// 如果客户端断开，把socket从集合中删调</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    log.info(<span class="string">&quot;与客户端断开连接&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>我们先后开启两个telnet客户端去连接服务端，发送消息，服务端都能接收到;</p><p>会一直循环去判断是否有新的连接请求，是否有连接发送消息</p><br><p><strong>上述代码存在的问题：</strong></p><p>如果连接数太多的话，会有大量的无效遍历</p><p>比如如果我现在有10万个连接，但是经常给服务端发消息的就那个几百个，但是每次都要去遍历所有的连接</p><br><p>我们可以将那些有数据交互的连接，存储在另外一个数据结构中，每次遍历只需要遍历那些有数据交互的连接</p><br><p>NIO引入多路复用器代码示例：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSelectorServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 打开selector处理Channel，即创建epoll</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 把ServerSocketChannel注册到selector上，并且selector监听客户端accept连接事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待需要处理的事件发生</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">// 获取selector中注册的全部事件的SelectionKey实例</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="comment">// 遍历SelectionKey对事件进行处理</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">// 如果是OP_ACCEPT事件，则进行连接获取和事件注册</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    ServerSocketChannel channel =(ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="keyword">final</span> SocketChannel socketChannel = channel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 这里只注册了读事件，如果需要给客户端发送数据可以注册写事件</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                    log.info(<span class="string">&quot;客户端连接成功&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123; <span class="comment">// 如果是OP_READ事件，则进行读取和打印</span></span><br><span class="line">                    SocketChannel channel =(SocketChannel)key.channel();</span><br><span class="line">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">int</span> len = channel.read(byteBuffer);</span><br><span class="line">                    <span class="keyword">if</span> (len &gt;<span class="number">0</span> )&#123;</span><br><span class="line">                        log.info(<span class="string">&quot;接收到消息:&#123;&#125;&quot;</span>,<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == -<span class="number">1</span>)&#123;</span><br><span class="line">                        log.info(<span class="string">&quot;客户端断开连接&quot;</span>);</span><br><span class="line">                        channel.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从事件集合里删除本次处理的key,防止下次select重复处理</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><p>NIO有三大核心组件：<strong>Channel(通道)，Buffer(缓冲区)，Selector(多路复用器)</strong></p><p>1、channel类似于流，每个channel对应一个buffer缓冲区，buffer底层就是个数组</p><p>2、channel会注册到selector上，由selector根据channel独写事件的发生将其交由某个空闲的线程处理</p><p>3、NIO的Buffer和channe都是既可以读也可以写</p><br><p>先看一幅图</p><br><img src="/colinstar/2022/01/06/Netty/image-20211229142929435.png" class><br><br><p>​    我们代码最开始处，创建了一个ServerSocketChannel，并绑定9000端口,并将ServerSocketChannel注册到selector上，并且selector监听客户端accept连接事件，注册上后会返回一个key,通过这个selectionKey可以找到与之绑定的ServerSocketChannel;</p><br><p>​    我们在selector.select()处及其下一行打上断点，启动项目。</p><img src="/colinstar/2022/01/06/Netty/image-20211229145434837.png" class><br><br><p>​    放掉断点让其走完，发现程序阻塞在了这一行；</p><p>​    同样的，打开cmd，用telnet连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 9000</span><br></pre></td></tr></table></figure><p>​    </p><p>​    连接上后，发现程序走到了下一行</p><br><img src="/colinstar/2022/01/06/Netty/image-20211229145749365.png" class><br><br><p>​    继续往下走一行，获取到所有的selectionKey; 因为此时我们只有一个客户端进行连接，所以此处size是1</p><br><img src="/colinstar/2022/01/06/Netty/image-20211229150505122.png" class><br><br><p>​    很显然我们此处是OP_ACCEPT事件</p><br><img src="/colinstar/2022/01/06/Netty/image-20211229152042072.png" class><br><br><p>​    通过selectionKey可以拿到与之绑定的ServerSocketChannel，并让其与客户端建立连接,并把客户端对应的socketChannel也注册到selector上，并让其监听读事件（读是相当于服务端来的，也就是监听客户端发送过来的消息）</p><p>​    我们一步一步调试，让程序走完，因为是死循环，在select处又会进行阻塞，因为此时既没有新的客户端连接进来，刚刚连接上的客户端也没有发送消息。</p><br><img src="/colinstar/2022/01/06/Netty/image-20211229154555019.png" class><br><br><p>​    我们用telnet再给服务端发送一条消息</p><br><img src="/colinstar/2022/01/06/Netty/image-20211229154651306.png" class><br><br><p>​    此时，程序停止了阻塞，走到了下一行</p><p>​    一步一步调试，很显然这次我们是OP_READ事件，通过key拿到与客户端对应的SocketChannel。也就是下图标识出来的部分，用它来读取客户端的数据</p><br><img src="/colinstar/2022/01/06/Netty/image-20211229155841635.png" class><br><br><img src="/colinstar/2022/01/06/Netty/image-20211229155400979.png" class><br><br><p>​    我们现在再另外开启一个telnet客户端，连接服务端</p><br><img src="/colinstar/2022/01/06/Netty/image-20211229162707964.png" class><br><br><p>​    我们可以看到，现在有两个客户端，但是拿到的selectionKey只有一个，只针对那些发生的事件进行处理</p><br><p>​    NIO底层在JDK1.4版本是用linux的内核函数select()或poll()来实现，跟上面最开始的代码类似，selector每次都会轮询所有的socketChannel看下哪个channel有读写事件，有的话就处理，没有就继续遍历，JDK1.5引入了epoll基于事件响应机制来优化NIO</p><br><br><h3 id="几个核心API"><a href="#几个核心API" class="headerlink" title="几个核心API"></a><strong>几个核心API</strong></h3><h4 id="Selector-open"><a href="#Selector-open" class="headerlink" title="Selector.open();"></a>Selector.open();</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><br><ul><li>provider()方法里最终调用了下面的create()方法，发现其new 了一个WindowsSelectorProvider()。因为我们日常使用的是windows的jdk</li></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectorProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectorProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowsSelectorProvider();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>下载openJdk8u的源码，搜索DefaultSelectorProvider这个类，发现有三个，分别对应unix系统，mac系统，windows系统。我们接下来看unix系统对应的源码</li></ul><br><img src="/colinstar/2022/01/06/Netty/image-20211230144907856.png" class><br><br><ul><li>unix系统create()方法的源码如下，发现和windows的有区别，如果是linux系统，会返回EPollSelectorProvider这个类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String osname = AccessController</span><br><span class="line">        .doPrivileged(<span class="keyword">new</span> GetPropertyAction(<span class="string">&quot;os.name&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (osname.equals(<span class="string">&quot;SunOS&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> createProvider(<span class="string">&quot;sun.nio.ch.DevPollSelectorProvider&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (osname.equals(<span class="string">&quot;Linux&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> createProvider(<span class="string">&quot;sun.nio.ch.EPollSelectorProvider&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> sun.nio.ch.PollSelectorProvider();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>open()方法里会调用openSelector()这个方法，<code>EPollSelectorProvider</code>里的实现如下，直接new 了一个EPollSelectorImpl</li></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EPollSelectorProvider</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">SelectorProviderImpl</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractSelector <span class="title">openSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EPollSelectorImpl(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Channel <span class="title">inheritedChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InheritedChannel.getChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>接着我们去看看<code>EpollSelectorImpl</code>这个类的构造函数，初始化的时候， <code>new EPollArrayWrapper()</code>创建了一个EPollArrayWrapper对象</li></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EPollSelectorImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    <span class="keyword">long</span> pipeFds = IOUtil.makePipe(<span class="keyword">false</span>);</span><br><span class="line">    fd0 = (<span class="keyword">int</span>) (pipeFds &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line">    fd1 = (<span class="keyword">int</span>) pipeFds;</span><br><span class="line">    pollWrapper = <span class="keyword">new</span> EPollArrayWrapper();</span><br><span class="line">    pollWrapper.initInterrupt(fd0, fd1);</span><br><span class="line">    fdToKey = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>紧接着我们看到<code>EPollArrayWrapper</code>的构造函数，里面调用了一个epollCreate（）方法</li></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EPollArrayWrapper() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// creates the epoll file descriptor</span></span><br><span class="line">    epfd = epollCreate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the epoll_event array passed to epoll_wait</span></span><br><span class="line">    <span class="keyword">int</span> allocationSize = NUM_EPOLLEVENTS * SIZE_EPOLLEVENT;</span><br><span class="line">    pollArray = <span class="keyword">new</span> AllocatedNativeObject(allocationSize, <span class="keyword">true</span>);</span><br><span class="line">    pollArrayAddress = pollArray.address();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eventHigh needed when using file descriptors &gt; 64k</span></span><br><span class="line">    <span class="keyword">if</span> (OPEN_MAX &gt; MAX_UPDATE_ARRAY_SIZE)</span><br><span class="line">        eventsHigh = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>​    epollCreate是一个本地方法 （java的native方法是通过JNI，即java native interface来实现的，可以通过它来实现java与其他语言之间的交互）</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">epollCreate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br><ul><li>EPollArrayWrapper.c里找到这个epollCreate方法, epoll_create是linux的一个系统函数</li></ul><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_sun_nio_ch_EPollArrayWrapper_epollCreate</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * epoll_create expects a size as a hint to the kernel about how to</span></span><br><span class="line"><span class="comment">     * dimension internal structures. We can&#x27;t predict the size in advance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       JNU_ThrowIOExceptionWithLastError(env, <span class="string">&quot;epoll_create failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> epfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li><p>我们在linux系统上执行 <code>man epoll_create</code>命令，查看这个函数的文档</p><p>-打开一个文件描述符，相当于创建了一个epoll对象，返回文件描述符的索引 int epfd = epoll_create(256)</p></li></ul><br><img src="/colinstar/2022/01/06/Netty/image-20211230153144948.png" class><br><br><h4 id="serverSocketChannel-register-…"><a href="#serverSocketChannel-register-…" class="headerlink" title="serverSocketChannel.register(…)"></a>serverSocketChannel.register(…)</h4><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><br><ul><li>java.nio.channels.SelectableChannel#register(java.nio.channels.Selector, int)</li></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(sel, ops, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>java.nio.channels.spi.AbstractSelectableChannel#register</li></ul><p>这个方法里面最终又调用了一个register方法，我们再点进去</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   Object att)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">        .....</span><br><span class="line">            <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">                k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att); <span class="comment">// 主要看这个register方法</span></span><br><span class="line">                addKey(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li><p>sun.nio.ch.SelectorImpl#register</p><p>这个里面又调用了一个implRegister（）方法，我们点进去是个抽象方法</p><p><code>protected abstract void implRegister(SelectionKeyImpl var1);</code></p><p>查看他的实现类，来到了WindowsSelectorImpl，这是windows系统的实现，我们去查看linux的implRegister的实现方法</p></li></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel var1, <span class="keyword">int</span> var2, Object var3)</span> </span>&#123;</span><br><span class="line">   ....</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.publicKeys) &#123;</span><br><span class="line">            <span class="keyword">this</span>.implRegister(var4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>sun.nio.ch.EPollSelectorImpl#implRegister</li></ul><p> <code>pollWrapper.add(fd);</code> fd是文件描述符，会根据这个索引找到这个文件（linux一切皆文件），在此处就是linux系统能够根据pd这个文件描述符找到这个创建好的serverSocketChannel；</p><p>这个pollWrapper就是上面Selector.open()里创建的pollWrapper</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">    SelChImpl ch = ski.channel;</span><br><span class="line">    <span class="keyword">int</span> fd = Integer.valueOf(ch.getFDVal());</span><br><span class="line">    fdToKey.put(fd, ski);</span><br><span class="line">    pollWrapper.add(fd);</span><br><span class="line">    keys.add(ski);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="selector-select"><a href="#selector-select" class="headerlink" title="selector.select();"></a>selector.select();</h4><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line"> ....</span><br><span class="line">selector.select();</span><br></pre></td></tr></table></figure><br><ul><li>select是一个抽象方法</li></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><br><p>点进实现类</p><ul><li>sun.nio.ch.SelectorImpl#select()</li></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.select(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>lockAndDoSelect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1 &lt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative timeout&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lockAndDoSelect(var1 == <span class="number">0L</span> ? -<span class="number">1L</span> : var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>sun.nio.ch.SelectorImpl#lockAndDoSelect</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lockAndDoSelect</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     ......</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.publicKeys) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="keyword">this</span>.publicSelectedKeys) &#123;</span><br><span class="line">                    var10000 = <span class="keyword">this</span>.doSelect(var1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>doSelect是一个抽象方法，点进实现类来到了WindowsSelectorImpl。同样的，我们需要看linux的实现<code>EPollSelectorImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><br><ul><li>sun.nio.ch.EPollSelectorImpl#doSelect</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   .......</span><br><span class="line">        pollWrapper.poll(timeout);</span><br><span class="line">   .......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>sun.nio.ch.EPollArrayWrapper#poll</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    updateRegistrations();</span><br><span class="line">    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;updated; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDescriptor(i) == incomingInterruptFD) &#123;</span><br><span class="line">            interruptedIndex = i;</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> updated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>先看updateRegistrations（）方法</p><br><ol><li>updateRegistrations();</li></ol><p>此方法里又调用了一个<code>epollCtl(epfd, opcode, fd, events)</code> ，点进去，这是一个本地方法</p><p><code>private native void epollCtl(int epfd, int opcode, int fd, int events);</code></p><p>内部调用的就是linux函数epoll_ctl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRegistrations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (updateLock) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; updateCount) &#123;</span><br><span class="line">                <span class="keyword">int</span> fd = updateDescriptors[j];</span><br><span class="line">                <span class="keyword">short</span> events = getUpdateEvents(fd);</span><br><span class="line">                <span class="keyword">boolean</span> isRegistered = registered.get(fd);</span><br><span class="line">                <span class="keyword">int</span> opcode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (events != KILLED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isRegistered) &#123;</span><br><span class="line">                        opcode = (events != <span class="number">0</span>) ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        opcode = (events != <span class="number">0</span>) ? EPOLL_CTL_ADD : <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (opcode != <span class="number">0</span>) &#123;</span><br><span class="line">                        epollCtl(epfd, opcode, fd, events);</span><br><span class="line">                        <span class="keyword">if</span> (opcode == EPOLL_CTL_ADD) &#123;</span><br><span class="line">                            registered.set(fd);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == EPOLL_CTL_DEL) &#123;</span><br><span class="line">                            registered.clear(fd);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            updateCount = <span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>在linux系统上执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man epoll_ctl</span><br></pre></td></tr></table></figure><br><p> 查看此函数</p><br><img src="/colinstar/2022/01/06/Netty/image-20220106101739198.png" class><br><br><p><code>epollCtl(epfd, opcode, fd, events);</code></p><p>epfd epoll实例对应的文件描述符</p><p>fd  socketChannel对应的文件描述符<br>events 事件</p><p>参数opcode又以下几个值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EPOLL_CTL_ADD // 注册新的SocketChannel到epoll实例中，并关联事件event</span><br><span class="line">EPOLL_CTL_DEL // 修改已经注册的SocketChannel的监听事件</span><br><span class="line">EPOLL_CTL_MOD // 从epoll中移除SocketChannel，并且忽略掉绑定的event</span><br></pre></td></tr></table></figure><p>epollCtl这个方法把SocketChannel和epoll关联起来</p><br><p>2.updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</p><p>再回到poll方法里，程序继续往下走，接着看epollWait这个方法，点进去也是一个本地方法，也是调用的操作系统内核函数</p><p>epoll_wait</p><blockquote><p>epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor</p></blockquote><br><p>epoll_wait的时候，会去查看sector里面的rdlist就绪列表里是否有数据，有数据就跳出阻塞，没有就阻塞住</p><br><p>利用操作系统回调函数，客户端有响应，把事件放进rdlist</p><br><img src="/colinstar/2022/01/06/Netty/image-20220106113434967.png" class><br><br><h2 id="AIO（NIO-2-0）"><a href="#AIO（NIO-2-0）" class="headerlink" title="AIO（NIO 2.0）"></a>AIO（NIO 2.0）</h2><br>    <p>​    异步非阻塞，由操作系统完成后回调通知服务端程序启动线程去处理，一般适用于连接数较多并且连接时间较长的应用</p><br><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line">        serverSocketChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel socketChannel, Object attachment)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2----&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="comment">// 再此接收客户端连接,如果不写这行代码后面的客户端连接不上服务端</span></span><br><span class="line">                    serverSocketChannel.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line">                    System.out.println(socketChannel.getRemoteAddress());</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel.read(buffer, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;3---&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, result));</span><br><span class="line">                            socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;HelloClient&quot;</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                            exc.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;1---&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="Rector响应式编程模型"><a href="#Rector响应式编程模型" class="headerlink" title="Rector响应式编程模型"></a>Rector响应式编程模型</h2><br><img src="/colinstar/2022/01/06/Netty/image-20220112165624349.png" class><br><br><p>所谓响应式，类似于GUI编程中，给一个Button绑定一个或多个事件，对于点击事件，点击后会触发对应方法</p><ul><li>基础的Reactor设计，单线程版本; 用一个Reactor去处理客户端的连接，以及读写</li></ul><br><img src="/colinstar/2022/01/06/Netty/image-20220112165808528.png" class><br><br><p>存在的问题：类比上面的NioSelectorServer类代码。selector.select()处会阻塞，同一时间如果有大量的读写事件发生，那么循环处理的时候，会耗费大量时间，而此时新进来的连接就会阻塞在selector.select()处。</p><ul><li>我们可以引入线程池，将读写工作交给其他线程去处理</li></ul><br><img src="/colinstar/2022/01/06/Netty/image-20220112170251931.png" class><br><br><p>存在的问题：还是类比上面的NioSelectorServer类的代码；我们现在while (iterator.hasNext()) {….}循环去处理的时候，引入线程池，将读写事件交给线程池去处理；这样分发完后，主线程能很快的回到selector.select()处，阻塞监听新的事件。但是如果一时间的事件很多，那么分发都需要花费大量的时间，同样新进来的事件也得不到处理</p><ul><li>引入两个Reactor，一个mainReactor专门用来处理连接事件。subReactor用来处理独写事件，并且把这些读写事件分发给线程池去完成</li></ul><br><img src="/colinstar/2022/01/06/Netty/image-20220112170736235.png" class><br><br><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><ul><li>NettyServer.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个线程组boss和worker;含有的子线程NioEventLoop的个数默认为cpu核数的两倍</span></span><br><span class="line">        <span class="comment">// boss组只是处理连接请求，真正的和客户端业务处理，会交给worker</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>); <span class="comment">// 相当于主Reactor</span></span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>); <span class="comment">// 相当于从Reactor</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 创建服务端的启动对象</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">// 使用链式编程来配置参数</span></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup) <span class="comment">// 设置两个线程组</span></span><br><span class="line">                    <span class="comment">// 使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 初始化服务器连接队列大小，服务端处理客户端连接请求是顺序处理的，所以同一时间处理一个客户端</span></span><br><span class="line">                    <span class="comment">// 多个客户端同时来连接的时候，服务端将不能处理的客户端连接请求放在队列中等待处理</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            log.info(<span class="string">&quot;------netty server start...------&quot;</span>);</span><br><span class="line">            <span class="comment">// 绑定一个端口并且同步，生成了一个ChannelFuture异步对象，通过isDone()等方法可以判断异步事件的执行情况</span></span><br><span class="line">            <span class="comment">// 启动服务器(并绑定端口),bind是异步操作，sync方法是等待异步操作执行完毕</span></span><br><span class="line">            ChannelFuture sync = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 等待服务端监听端口关闭，closeFuture是异步操作</span></span><br><span class="line">            <span class="comment">// 通过sync方法同步等待通道关闭处理完毕，这里会阻塞等待通道关闭，内部调用的是object.wait()方法</span></span><br><span class="line">            sync.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>NettyServerHandler.Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端发送的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        System.out.println(in.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕处理方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;[来自服务端]:congratulations~连接成功&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> ByteBuf byteBuf = Unpooled.copiedBuffer(msg.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123; <span class="comment">// (4)</span></span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>NettyClient.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端需要一个事件循环组</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建客户端启动对象</span></span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap(); <span class="comment">// (1)</span></span><br><span class="line">            b.group(group); <span class="comment">// (2)</span></span><br><span class="line">            b.channel(NioSocketChannel.class); <span class="comment">// (3)</span></span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (4)</span></span><br><span class="line">            b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> NettyClientChannel());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;netty client start....&quot;</span>);</span><br><span class="line">            <span class="comment">// Start the client.</span></span><br><span class="line">            ChannelFuture f = b.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>).sync(); <span class="comment">// (5)</span></span><br><span class="line">            <span class="comment">// Wait until the connection is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>NettyClientChannel.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientChannel</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时，也就是服务端发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf m = (ByteBuf) msg; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(m.toString(CharsetUtil.UTF_8));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            m.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端连接服务器完成就会触发该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelFuture f = ctx.writeAndFlush(Unpooled.copiedBuffer((<span class="string">&quot;[来自客户端]:hello server&quot;</span> ).getBytes(CharsetUtil.UTF_8))); <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="Netty模块组件"><a href="#Netty模块组件" class="headerlink" title="Netty模块组件"></a>Netty模块组件</h2><br><p>下面部分摘抄自官方文档<a href="https://netty.io/wiki/user-guide-for-4.x.html#wiki-h3-9">https://netty.io/wiki/user-guide-for-4.x.html#wiki-h3-9</a></p><p>1、<a href="https://netty.io/4.1/api/io/netty/channel/nio/NioEventLoopGroup.html"><code>NioEventLoopGroup</code></a>是一个处理 I/O 操作的多线程事件循环，Netty提供各种NioEventLoopGroup为不同类型的传输提供了各种实现；实现一个服务器端应用程序，因此<a href="https://netty.io/4.1/api/io/netty/channel/nio/NioEventLoopGroup.html"><code>NioEventLoopGroup</code></a>将使用两个。第一个，通常称为“boss”，接受传入连接。第二个，通常称为“worker”，一旦boss接受连接并将接受的连接注册到worker;有多少线程使用和它们是如何映射到创建渠道取决于EventLoopGroup通过构造函数实现,甚至可能是可配置的</p><p>2、<a href="https://netty.io/4.1/api/io/netty/bootstrap/ServerBootstrap.html"><code>ServerBootstrap</code></a> is a helper class that sets up a server；ServerBootstrap是一个设置服务器的辅助类。</p><blockquote><ol><li><a href="https://netty.io/4.1/api/io/netty/bootstrap/Bootstrap.html"><code>Bootstrap</code></a>与<a href="https://netty.io/4.1/api/io/netty/bootstrap/ServerBootstrap.html"><code>ServerBootstrap</code></a>类似，除了它是非服务端通道，如客户端或无连接通道。</li><li>如果您只指定一个<a href="https://netty.io/4.1/api/io/netty/channel/EventLoopGroup.html"><code>EventLoopGroup</code></a>，它将同时用作boss组和worker组。但是，boss组不用于客户端。</li><li><a href="https://netty.io/4.1/api/io/netty/channel/socket/nio/NioSocketChannel.html"><code>NioSocketChannel</code></a>被用来创建客户端<a href="https://netty.io/4.1/api/io/netty/channel/Channel.html"><code>Channel</code></a>，而不是<a href="https://netty.io/4.1/api/io/netty/channel/socket/nio/NioServerSocketChannel.html"><code>NioServerSocketChannel</code></a>；</li><li>注意我们不像ServerBootstrap处，使用childOption(),因为客户端SocketChannel没有父级</li><li>我们应该调用<code>connect()</code>方法而不是<code>bind()</code>方法。</li></ol></blockquote><p>3、 Netty 抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接收客户端的连接, WorkerGroup专 门负责网络的</p><p>4 、BossGroup和WorkerGroup类型都是NioEventLoopGroup </p><p>5、NioEventLoopGroup 相当于一个事件循环线程组, 这个组中含有多个事件循环线程 ， 每一个事件循环线程是 NioEventLoop</p><p>6、每个NioEventLoop都有一个selector , 用于监听注册在其上的socketChannel的网络通讯 </p><p>7、每个Boss NioEventLoop线程内部循环执行的步骤有 3 步 </p><p>   ​    处理accept事件，与client建立连接，生成NioSocketChannle</p><p>   ​    将NioSocketChannel注册到某个worker NIOEventLoop上的selector</p><p>   ​    处理任务队列的任务，即runAllTasks</p><p>8、每个worker NIOEventLoop线程循环执行的步骤</p><p>   ​     轮询注册到自己selector上的所有NioSocketChannel 的read, write事件 </p><p>   ​     处理 I/O 事件， 即read , write 事件， 在对应    NioSocketChannel 处理业务 </p><p>   ​     runAllTasks处理任务队列TaskQueue的任务 ，一些耗时的业务处理一般可以放入TaskQueue中慢慢处 理，这样不影响数据在 pipeline 中的流动处理</p><p>9、每个worker NIOEventLoop处理NioSocketChannel业务时，会使用 pipeline (管道)，管道中维护了很多 handler 处理器用来处理 channel 中的数据</p><br><p><strong>Bootstrap、ServerBootstrap</strong></p><p>一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组 件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p><br><p><strong>Future、ChannelFuture</strong></p><p>在Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理</p><p>但是可以等他执行完成或者直接注册一个监听，具体的实现就是通过Future和CahnnelFutures,他们可以注 册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p><br><p><strong>Channel</strong></p><p>Netty网络通信的组件，能够用于执行网络I/O操作。Channel为用户提供</p><p>1、当前网络连接的通道的状态（例如是否打开？是否已连接）</p><p>2、网络连接的配置参数（例如接收缓冲区大小）</p><p>3、提供异步的网络I/O操作（如建立连接，读写，绑定端口），异步调用意味着任何I/O调用都将立即返回，并且不保证在调用结束时所请求的I/O操作已完成</p><p>4、调用立即返回一个ChannelFuture实例，通过注册监听器到ChannelFuture上，可以I/O操作成功、失败或取消时回调通知调用方</p><p>5、支持关联I/O操作与对应的处理程序。</p><p>不同协议、不通的阻塞类型的连接都有不同的Channel类型与之对应</p><p>下面是一些常用的Channel类型：</p><blockquote><p>NioSocketChannel 异步的客户端TCP Socket连接</p><p>NioServerSocketChannel  异步的服务器端TCP Socket连接</p><p>NioDatagramChannel  异步的UDP连接</p><p>NioSctpChannel  异步的客户端Sctp连接</p><p>NioSctpServerChannel 异步的Sctp服务器端连接</p><p>这些通道涵盖了UDP和TCP网络IO以及文件IO</p></blockquote><br><p><strong>Selector</strong></p><p>Netty基于Selector对象实现I/O多路复用，通过Selector一个线程可以监听多个连接的Channel事件。</p><p>当向一个Selector中注册Channel后，Selector内部的机制就可以自动不断地查询（Select）这些注册的Channel是否有已就绪的I/O事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多 个 Channel 。</p><br><p><strong>NioEventLoop</strong></p><p>NioEventLoop中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用NioEventLoop 的 run 方 法，执行 I/O 任务和非 I/O 任务：</p><p>I/O任务，即selectionKey中ready的事件，如accept、connect、read、write等，由 processSelectedKeys 方 法触发。</p><p>非 IO 任务，添加到 taskQueue 中的任务，如 register0、bind0 等任务，由 runAllTasks 方法触发。</p><br><p><strong>NioEventLoopGroup</strong></p><p>NioEventLoopGroup，主要管理eventLoop的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程（NioEventLoop)负责处理多个Channel上的事件，而一个Channel只对应于一个线程</p><br><p><strong>ChannelHandler</strong></p><p>ChannelHandler是一个接口，处理I/O事件或拦截I/O操作，并将其转发到其ChannelPipeline(业务处理链)中的下一个处理程序</p><p>ChannelHandler本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p><blockquote><p>ChannelInboundHandler 用于处理入站I/O事件</p><p>ChannelOutboundHandler 用于处理出站I/O操作</p></blockquote><p>或者使用以下适配器类</p><blockquote><p>ChannelInboundHandlerAdapter 用于处理入站I/O事件</p><p>ChannlOutboundHandler 用于处理出站I/O操作</p></blockquote><br><p><strong>ChannelHandlerContext</strong></p><p>保存Channel相关的上下文信息，同时关联一个ChannelHandler对象</p><br><p><strong>ChannelPipline</strong></p><p>​    保存ChannelHandler的List,用于处理或拦截Channel的入站事件和出站操作</p><p>ChannelPipeline实现了一中高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，事件的处理方式</p><p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下：</p><br><img src="/colinstar/2022/01/06/Netty/image-20220120102408589.png" class><br><p>​    一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组 成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。 read事件(入站事件)和write事件(出站事件)在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰</p><h2 id="Netty架构图"><a href="#Netty架构图" class="headerlink" title="Netty架构图"></a>Netty架构图</h2><br><img src="/colinstar/2022/01/06/Netty/image-20220112172945020.png" class><br><h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><br><p>​    从结构上来说，ByteBuf 由一串字节数组构成。数组中每个字节用来存放信息。 ByteBuf 提供了两个索引，一个用于读取数据，一个用于写入数据。这两个索引通过在字节数组中移动，来定 位需要读或者写信息的位置。 当从 ByteBuf 读取时，它的 readerIndex（读索引）将会根据读取的字节数递增。 同样，当写 ByteBuf 时，它的 writerIndex 也会根据写入的字节数进行递增。</p><p>​    需要注意的是极限的情况是 readerIndex 刚好读到了 writerIndex 写入的地方。 如果 readerIndex 超过了 writerIndex 的时候，Netty 会抛出 IndexOutOf-BoundsException 异常</p><br><img src="/colinstar/2022/01/06/Netty/image-20220117160915775.png" class><br><br><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建byteBuf对象，该对象内部包含一个字符数组byte[10]</span></span><br><span class="line">        <span class="comment">// 通过readerindex和writeindex和capacity，将buffer分成三个区域，</span></span><br><span class="line">        <span class="comment">// 已经读取的区域: [0,readerindex)  注意开闭区间</span></span><br><span class="line">        <span class="comment">// 可读取的区域: [readerindex,writeindex)</span></span><br><span class="line">        <span class="comment">// 可写的区域: [writerindex,capacity）</span></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">        System.out.println(buffer);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            buffer.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(buffer.getByte(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(buffer.readByte());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">        ByteBuf byteBuf2 = Unpooled.copiedBuffer(<span class="string">&quot;hello world&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">        <span class="keyword">if</span> (byteBuf2.hasArray())&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] array = byteBuf2.array();</span><br><span class="line">            <span class="comment">// 转成字符串</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(array, CharsetUtil.UTF_8));</span><br><span class="line">            System.out.println(byteBuf2);</span><br><span class="line">            System.out.println(byteBuf2.readerIndex());</span><br><span class="line">            System.out.println(byteBuf2.writerIndex());</span><br><span class="line">            System.out.println(byteBuf2.capacity());</span><br><span class="line">            System.out.println(byteBuf2.getByte(<span class="number">0</span>)); <span class="comment">// 获取数组0这个位置的字符h的ascii码，h=104</span></span><br><span class="line">            <span class="keyword">int</span> len = byteBuf2.readableBytes(); <span class="comment">// 可读的字节数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;len = &quot;</span> + len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 范围读取</span></span><br><span class="line">        CharSequence charSequence = byteBuf2.getCharSequence(<span class="number">0</span>, <span class="number">6</span>, CharsetUtil.UTF_8);</span><br><span class="line">        System.out.println(charSequence.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Netty编解码"><a href="#Netty编解码" class="headerlink" title="Netty编解码"></a>Netty编解码</h2><br><p>Netty涉及到编解码的组件有Channel、ChannelHandler、ChannelPipe等</p><br><p><strong>ChannelHandler</strong></p><p>ChannelHandler充当了处理入站和出站数据的应用程序逻辑容器，例如，实现ChannelInboundHandler接口（或 ChannelInboundHandlerAdapter)，你就可以接收入站事件和数据，这些数据随后会被你的应用程序的业务逻辑处理。当你要给连接的客户端发送响应时，也可以从ChannelInboundHandler冲刷数据。你得业务逻辑通常写在一个或者多个ChannelInboundHandler中。ChannelOutboundHandler原理一样，只不过它用来处理出站数据的。</p><br><p><strong>ChannelPipeline</strong></p><p>ChannelPipeline提供了ChannelHandler链的容器。以客户端应用程序为例，如果事件的运动方向时从客户端到服务端的，那么称为这些事件为出战的，即客户端发送给服务端的数据会通过pipeline中的一系列ChannelOutboundHandler(ChannelOutboundHandler)调用是从tail到head方向逐个调用每个handler的逻辑，并被这些handler处理，反之则称为入站的，入站只调用pipeline里的ChannelInboundHandler逻辑（ChannelInboundHandler调用是从head到tail方向逐个调用每个handler的逻辑</p><p>所谓的入站出站，是相当于客户端/服务端来说的，即收到消息为入站，消息发送为出站。入站会从head到tail经过一系列处理调用，但是入站只是会调用继承ChannelInboundHandler的逻辑，出站是从tail到尾进行处理调用，只会调用ChannelOutboundHandler</p><br><img src="/colinstar/2022/01/06/Netty/image-20220120142215255.png" class><br><br><p><strong>编码解码器</strong></p><p>​    当你通过Netty发送或者接收一个消息时，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如java对 象）；如果是出站消息，它会被编码成字节。</p><p>​    Netty提供了一系列的编码解码器，他们都实现了ChannelInboundHadnler或者ChannelOutboundHandler接口。在这些类中，channelRead方法已经被重写了。</p><p>​    以入站为例，对于每个从入站Channel读取的消息，这个方法会被调用。随后，它将调用由已知解码器 所提供的decode()方法进行解码，并将已经解码的字节转发给ChannelPipeline中的下一个ChannelInboundHandler。Netty提供了很多编解码器，比如编解码字符串的StringEncoder和StringDecoder，编解码对象的ObjectEncoder和ObjectDecoder 等。</p><blockquote><p>如果要实现高效的编解码可以用protobuf，但是protobuf需要维护大量的proto文件比较麻烦，现在一般可以使用protostuff。 protostuff是一个基于protobuf实现的序列化方法，它较于protobuf最明显的好处是，在几乎不损耗性能的情况下做到了不用我们 写.proto文件来实现序列化</p></blockquote><p>maven坐标如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyuproject.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff‐api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyuproject.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff‐core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyuproject.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff‐runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Netty粘包拆包"><a href="#Netty粘包拆包" class="headerlink" title="Netty粘包拆包"></a>Netty粘包拆包</h2><pre><code> TCP是一个流协议，就是没有界限的一长串二进制数据。TCP作为传输层协议并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行数据包的划分，所以在业务上认为是一个完整的包，可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。</code></pre><p>​    面向流的通信是无消息保护边界的。</p><p>​    如下图：client发送两个数据包D1和D2，但是server端可能会收到如下几种情况的数据</p><br><img src="/colinstar/2022/01/06/Netty/image-20220124095737022.png" class><br><br><p><strong>解决方案</strong></p><p>1、消息定长度，数据传输的大小固定长度，例如每段长度固定100字节，不够空位补齐</p><p>2、在数据包尾部添加特殊分隔符，比如下划线等。前提是消息本体不能带分隔符</p><p>3、发送长度：发送每条数据的时候，将数据的长度一并发送。比如可以选取每条数据的前四位去记录长度，接受处理时可以根据长度判定开始和结束</p><p>Netty提供了多个解码器，可以进行分包的操作</p><p>LineBasedFrameDecoder (回车换行分包)</p><p>DelimiterBasedFrameDecoder (特殊分隔符分包)</p><p>FixedLengthFrameDecoder (固定长度报文分包)</p><h2 id="Netty心跳检测机制"><a href="#Netty心跳检测机制" class="headerlink" title="Netty心跳检测机制"></a>Netty心跳检测机制</h2><p>​    在Netty中，实现心跳机制的关键是IDleStateHandler。</p><img src="/colinstar/2022/01/06/Netty/image-20220126101511843.png" class><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span></span>&#123;</span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">        <span class="comment">// IdleStateEvent的readerIdleTime参数指定超过3秒还没收到客户端的连接，会触发</span></span><br><span class="line">        <span class="comment">// IdleStateEvent事件并且交给下一个handler处理，下一个handler必须实现userEventTriggered方法处理对应事件</span></span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> HeartBeatServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><p>构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读超时时间；写超时时间；所有的超时时间；时间单位</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>, readerIdleTime, writerIdleTime, allIdleTime, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">boolean</span> observeOutput, <span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.writeListener = <span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           IdleStateHandler.<span class="keyword">this</span>.lastWriteTime = IdleStateHandler.<span class="keyword">this</span>.ticksInNanos();</span><br><span class="line">           IdleStateHandler.<span class="keyword">this</span>.firstWriterIdleEvent = IdleStateHandler.<span class="keyword">this</span>.firstAllIdleEvent=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.firstReaderIdleEvent = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.firstWriterIdleEvent = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.firstAllIdleEvent = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;unit&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.observeOutput = observeOutput;</span><br><span class="line">        <span class="keyword">if</span> (readerIdleTime &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.readerIdleTimeNanos = <span class="number">0L</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 赋值</span></span><br><span class="line">            <span class="keyword">this</span>.readerIdleTimeNanos = Math.max(unit.toNanos(readerIdleTime), MIN_TIMEOUT_NANOS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (writerIdleTime &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writerIdleTimeNanos = <span class="number">0L</span>; <span class="comment">// 赋值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">this</span>.writerIdleTimeNanos = Math.max(unit.toNanos(writerIdleTime), MIN_TIMEOUT_NANOS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allIdleTime &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.allIdleTimeNanos = <span class="number">0L</span>; <span class="comment">// 赋值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">this</span>.allIdleTimeNanos = Math.max(unit.toNanos(allIdleTime), MIN_TIMEOUT_NANOS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><ul><li>channelActive</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.initialize(ctx);</span><br><span class="line">    <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>initialize</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">this</span>.state) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.initOutputChanged(ctx);</span><br><span class="line">        <span class="keyword">this</span>.lastReadTime = <span class="keyword">this</span>.lastWriteTime = <span class="keyword">this</span>.ticksInNanos(); <span class="comment">// lastReadTime,lastWriteTime赋初始值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.readerIdleTimeNanos &gt; <span class="number">0L</span>) &#123; <span class="comment">// readerIdleTimeNanos就是刚构造器里赋的值</span></span><br><span class="line">            <span class="keyword">this</span>.readerIdleTimeout = <span class="keyword">this</span>.schedule(ctx, <span class="keyword">new</span> IdleStateHandler.ReaderIdleTimeoutTask(ctx), <span class="keyword">this</span>.readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.writerIdleTimeNanos &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writerIdleTimeout = <span class="keyword">this</span>.schedule(ctx, <span class="keyword">new</span> IdleStateHandler.WriterIdleTimeoutTask(ctx), <span class="keyword">this</span>.writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.allIdleTimeNanos &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.allIdleTimeout = <span class="keyword">this</span>.schedule(ctx, <span class="keyword">new</span> IdleStateHandler.AllIdleTimeoutTask(ctx), <span class="keyword">this</span>.allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>schedule</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScheduledFuture&lt;?&gt; schedule(ChannelHandlerContext ctx, Runnable task, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.executor().schedule(task, delay, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    <p>ChannelHandlerContext ctx是<code>io.netty.channel.DefaultChannelHandlerContext</code>实例，<code>DefaultChannleHandlerContext</code>又继承了<code>AbstractChannelHandlerContext</code>，在<code>AbstractChannelHandlerContext</code>中找到executor()方法，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventExecutor <span class="title">executor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (EventExecutor)(<span class="keyword">this</span>.executor == <span class="keyword">null</span> ? <span class="keyword">this</span>.channel().eventLoop() : <span class="keyword">this</span>.executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    <p>​    ctx.executor()会返回一个EventExecutor，其类图如下，跟<code>ScheduledThreadPollExecutor</code>定时线程池一样，其都继承或实现自<code>ScheduledExecutorService</code>接口</p><br><img src="/colinstar/2022/01/06/Netty/image-20220126102424203.png" class><br><br><p>接着我们去看new IdleStateHandler.ReaderIdleTimeoutTask(ctx)，这个任务里的run方法</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nextDelay = IdleStateHandler.<span class="keyword">this</span>.readerIdleTimeNanos; </span><br><span class="line">    <span class="keyword">if</span> (!IdleStateHandler.<span class="keyword">this</span>.reading) &#123; <span class="comment">// nextDelay = readerIdleTimeNanos - (当前时间 - lastReadTime)</span></span><br><span class="line">        <span class="comment">// channelReadComplete()方法里，会更新lastReadTime</span></span><br><span class="line">        <span class="comment">// 其实就是在计算 读的时间间隔是否超过设定的时间</span></span><br><span class="line">        nextDelay -= IdleStateHandler.<span class="keyword">this</span>.ticksInNanos() - IdleStateHandler.<span class="keyword">this</span>.lastReadTime; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextDelay &lt;= <span class="number">0L</span>) &#123; <span class="comment">// 小于等于0，即超时了走这里</span></span><br><span class="line">        IdleStateHandler.<span class="keyword">this</span>.readerIdleTimeout = IdleStateHandler.<span class="keyword">this</span>.schedule(ctx, <span class="keyword">this</span>, IdleStateHandler.<span class="keyword">this</span>.readerIdleTimeNanos, TimeUnit.NANOSECONDS); </span><br><span class="line">        <span class="comment">// 还会提交任务，延迟时间为readerIdleTimeNanos</span></span><br><span class="line">        <span class="keyword">boolean</span> first = IdleStateHandler.<span class="keyword">this</span>.firstReaderIdleEvent;<span class="comment">// 构造函数赋初始值为true</span></span><br><span class="line">        IdleStateHandler.<span class="keyword">this</span>.firstReaderIdleEvent = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IdleStateEvent event = IdleStateHandler.<span class="keyword">this</span>.newIdleStateEvent(IdleState.READER_IDLE, first);</span><br><span class="line">            IdleStateHandler.<span class="keyword">this</span>.channelIdle(ctx, event);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            ctx.fireExceptionCaught(var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        IdleStateHandler.<span class="keyword">this</span>.readerIdleTimeout = IdleStateHandler.<span class="keyword">this</span>.schedule(ctx, <span class="keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelIdle</span><span class="params">(ChannelHandlerContext ctx, IdleStateEvent evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.fireUserEventTriggered(evt); <span class="comment">// 会调用到下一个handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><h3 id="NioEventLoopGroup"><a href="#NioEventLoopGroup" class="headerlink" title="NioEventLoopGroup"></a>NioEventLoopGroup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure><p>构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">    <span class="comment">//SelectorProvider.provider()就是前面NIO所说的EPollSelectorProvider,详情看Selector.open()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line"><span class="comment">// 无参构造最终会调用这个有参构造</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, SelectorProvider selectorProvider, SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nThreads, threadFactory, <span class="keyword">new</span> Object[]&#123;selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject()&#125;); <span class="comment">//调用父类MultithreadEventLoopGroup的构造器</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><p><code>io.netty.channel.MultithreadEventLoopGroup</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args); <span class="comment">//继续调用父类构造器，nThreads = 0的话，会传入默认的线程数，cpu核数*2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><code>io.netty.util.concurrent.MultithreadEventExecutorGroup</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>最终会调用<code>MultithreadEventExecutorGroup</code>类的这个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123; <span class="comment">// nThreads = 16，executor = null</span></span><br><span class="line">    <span class="keyword">this</span>.terminatedChildren = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">this</span>.terminationFuture = <span class="keyword">new</span> DefaultPromise(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建一个线程池</span></span><br><span class="line">            executor = <span class="keyword">new</span> ThreadPerTaskExecutor(<span class="keyword">this</span>.newDefaultThreadFactory());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.children = <span class="keyword">new</span> EventExecutor[nThreads]; <span class="comment">// 创建一个EventExecutor数组，长度为nThreads（16）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; ++i) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> var18 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var18 = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 循环遍历，对数组中的每个元素赋值；会去new NioEventLoop(...)</span></span><br><span class="line">                <span class="keyword">this</span>.children[i] = <span class="keyword">this</span>.newChild((Executor)executor, args);</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">                var18 = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var19) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;failed to create a child event loop&quot;</span>, var19);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                .......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>newChild()</li></ul><p>io.netty.channel.nio.NioEventLoopGroup#newChild</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider)args[<span class="number">0</span>], ((SelectStrategyFactory)args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler)args[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>io.netty.channel.nio.NioEventLoop 构造函数</p><blockquote><p>public final class <strong>NioEventLoop</strong> extends <strong>SingleThreadEventLoop</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler); <span class="comment">// 调用父类构造器,里面会创建一个阻塞队列taskQueue</span></span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strategy == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.provider = selectorProvider;</span><br><span class="line">        NioEventLoop.SelectorTuple selectorTuple = <span class="keyword">this</span>.openSelector(); <span class="comment">// 类比前面NIO的代码，创建selector</span></span><br><span class="line">        <span class="keyword">this</span>.selector = selectorTuple.selector;</span><br><span class="line">        <span class="keyword">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">        <span class="keyword">this</span>.selectStrategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>io.netty.channel.SingleThreadEventLoop 构造函数</p><blockquote><p>public abstract class <strong>SingleThreadEventLoop</strong> extends <strong>SingleThreadEventExecutor</strong> implements EventLoop </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventLoop</span><span class="params">(EventLoopGroup parent, Executor executor, <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks, RejectedExecutionHandler rejectedExecutionHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">this</span>.tailTasks = <span class="keyword">this</span>.newTaskQueue(maxPendingTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>io.netty.util.concurrent.SingleThreadEventExecutor 构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor, <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks, RejectedExecutionHandler rejectedHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.threadLock = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.shutdownHooks = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.terminationFuture = <span class="keyword">new</span> DefaultPromise(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    <span class="keyword">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    <span class="keyword">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</span><br><span class="line">    <span class="keyword">this</span>.executor = ThreadExecutorMap.apply(executor, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.taskQueue = <span class="keyword">this</span>.newTaskQueue(<span class="keyword">this</span>.maxPendingTasks); <span class="comment">// 创建阻塞队列</span></span><br><span class="line">    <span class="keyword">this</span>.rejectedExecutionHandler = (RejectedExecutionHandler)ObjectUtil.checkNotNull(rejectedHandler, <span class="string">&quot;rejectedHandler&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Queue&lt;Runnable&gt; <span class="title">newTaskQueue</span><span class="params">(<span class="keyword">int</span> maxPendingTasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedBlockingQueue(maxPendingTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h3><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">serverBootstrap.group(bossGroup,workerGroup).....</span><br></pre></td></tr></table></figure><blockquote><p>ServerBootstrap构造器为空方法，没有做什么逻辑处理</p></blockquote><h4 id="group-bossGroup-workerGroup"><a href="#group-bossGroup-workerGroup" class="headerlink" title="group(bossGroup,workerGroup)"></a>group(bossGroup,workerGroup)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">    <span class="keyword">if</span> (childGroup == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>io.netty.bootstrap.AbstractBootstrap#group</p><blockquote><p>public abstract class AbstractBootstrap&lt;B extends AbstractBootstrap&lt;B, C&gt;, C extends Channel&gt; implements Cloneable {}</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;group&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;group set already&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.group = group; <span class="comment">// 赋值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="channel-NioServerSocketChannel-class"><a href="#channel-NioServerSocketChannel-class" class="headerlink" title="channel(NioServerSocketChannel.class)"></a>channel(NioServerSocketChannel.class)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channelClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;channelClass&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.channelFactory((<span class="keyword">new</span> ReflectiveChannelFactory(channelClass)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>new ReflectiveChannelFactory(channelClass)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Constructor&lt;? extends T&gt; constructor; <span class="comment">// 成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(clazz, <span class="string">&quot;clazz&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.constructor = clazz.getConstructor(); <span class="comment">// 获取传进来class的构造函数，并赋值给成员属性</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Class &quot;</span> + StringUtil.simpleClassName(clazz) + <span class="string">&quot; does not have a public non-arg constructor&quot;</span>, var3);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><p> this.channelFactory((new ReflectiveChannelFactory(channelClass)));</p><p>channelFactory()方法,就是将channelFactory赋值给成员属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">.......</span><br><span class="line">        <span class="keyword">this</span>.channelFactory = channelFactory;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="option-ChannelOption-SO-BACKLOG-1024"><a href="#option-ChannelOption-SO-BACKLOG-1024" class="headerlink" title="option(ChannelOption.SO_BACKLOG,1024)"></a>option(ChannelOption.SO_BACKLOG,1024)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = <span class="keyword">new</span> LinkedHashMap(); <span class="comment">// 成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (option == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;option&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.options) &#123;</span><br><span class="line">                <span class="keyword">this</span>.options.remove(option);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.options) &#123;</span><br><span class="line">                <span class="keyword">this</span>.options.put(option, value); <span class="comment">// 就是把传进来的key,value放进map</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="childHandler-new-ChannelInitializer-…"><a href="#childHandler-new-ChannelInitializer-…" class="headerlink" title="childHandler(new ChannelInitializer() {…}"></a>childHandler(new ChannelInitializer<SocketChannel>() {…}</SocketChannel></h4><p>handler()是发生在初始化的时候，childHandler()是发生在客户端连接之后</p><p>.childHandler(new ChannelInitializer<SocketChannel>() {<br>    @Override<br>    protected void initChannel(SocketChannel socketChannel) throws Exception {<br>        socketChannel.pipeline().addLast(new ….);<br>    }<br>});</SocketChannel></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ChannelHandler childHandler; <span class="comment">// 成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (childHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;childHandler&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.childHandler = childHandler;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><blockquote><p>ChannelFuture cf = serverBootstrap.bind(ip,port);</p></blockquote><p>ServerBootstrap继承AbstractBootstrap，bind是父类AbstractBootstrap的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bind(<span class="keyword">new</span> InetSocketAddress(inetPort));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.validate(); <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;localAddress&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.doBind(localAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>validate方法 校验成员属性是否有值,也就是group()，channel()配置的那些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">validate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.group == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;group not set&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.channelFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;channel or channelFactory not set&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>this.doBind(localAddress)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = <span class="keyword">this</span>.initAndRegister(); <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise); <span class="comment">// ②</span></span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractBootstrap.PendingRegistrationPromise promise = <span class="keyword">new</span> AbstractBootstrap.PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="this-initAndRegister-方法"><a href="#this-initAndRegister-方法" class="headerlink" title="this.initAndRegister()方法"></a>this.initAndRegister()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// channelFactory就是channel方法赋值的 ReflectiveChannelFactory</span></span><br><span class="line">       <span class="comment">//  ReflectiveChannelFactory的newChannel()方法主要是:   return (Channel)this.constructor.newInstance();</span></span><br><span class="line">       <span class="comment">//  如前文所说，constructor也是channel方法赋值的，我们传进来的是NioServerSocketChannel.class</span></span><br><span class="line">        channel = <span class="keyword">this</span>.channelFactory.newChannel(); </span><br><span class="line">        <span class="keyword">this</span>.init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelFuture regFuture = <span class="keyword">this</span>.config().group().register(channel); <span class="comment">// 将NioServerSocketChannel注册</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h6 id="NioServerSocketChannel的无参构造："><a href="#NioServerSocketChannel的无参构造：" class="headerlink" title="NioServerSocketChannel的无参构造："></a>NioServerSocketChannel的无参构造：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider(); <span class="comment">// 成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>先看newSocket()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> java.nio.channels.<span class="function">ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel(); <span class="comment">// 类比文章开头的NIO代码，几乎一模一样 会去创建ServerSocketChannel对象</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Failed to open a server socket.&quot;</span>, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>this(newSocket(DEFAULT_SELECTOR_PROVIDER));调用重载的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(java.nio.channels.ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>((Channel)<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT); <span class="comment">// SelectionKey.OP_ACCEPT 连接事件</span></span><br><span class="line">    <span class="keyword">this</span>.config = <span class="keyword">new</span> NioServerSocketChannel.NioServerSocketChannelConfig(<span class="keyword">this</span>, <span class="keyword">this</span>.javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>父类构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioMessageChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, ch, readInterestOp); <span class="comment">// ① 继续调用父类构造器，如下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent); <span class="comment">// ② 继续往上调用,代码如下</span></span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ch.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 设置ServerSocketChannel为非阻塞</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var7) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123; <span class="comment">// ③</span></span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="keyword">this</span>.newId();</span><br><span class="line">    <span class="keyword">this</span>.unsafe = <span class="keyword">this</span>.newUnsafe();</span><br><span class="line">    <span class="keyword">this</span>.pipeline = <span class="keyword">this</span>.newChannelPipeline(); <span class="comment">// 创造pipeline</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123; <span class="comment">// ④</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123; <span class="comment">// ⑤</span></span><br><span class="line">    <span class="keyword">this</span>.channel = (Channel)ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, (EventExecutor)<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.voidPromise = <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 创建尾部节点，TailContext与HeadContext都间接实现了ChannelHandlerContext，AbstractChannelHandlerContext实现了它</span></span><br><span class="line">    <span class="comment">// class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler </span></span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="keyword">new</span> DefaultChannelPipeline.TailContext(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> DefaultChannelPipeline.HeadContext(<span class="keyword">this</span>); <span class="comment">// 创建头部节点</span></span><br><span class="line">    <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.tail; <span class="comment">// 首尾互指</span></span><br><span class="line">    <span class="keyword">this</span>.tail.prev = <span class="keyword">this</span>.head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>   ch.configureBlocking(false); 即前面NIO代码的如下地方：</p><br><img src="/colinstar/2022/01/06/Netty/image-20220209143331857.png" class><h6 id="this-init-channel"><a href="#this-init-channel" class="headerlink" title="this.init(channel);"></a>this.init(channel);</h6><p>  this.init()是一个抽象方法，ServerBootstrap中对应实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = <span class="keyword">new</span> LinkedHashMap(); <span class="comment">// AbstractBootstrap中的成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">//channel ——&gt; NioServerSocketChannel实例</span></span><br><span class="line">    <span class="comment">// options0（）是父类AbstractBootstrap方法，具体逻辑就是 return this.options; </span></span><br><span class="line">    <span class="comment">// this.options是前文所说的option()方法赋的值</span></span><br><span class="line">    Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = <span class="keyword">this</span>.options0();</span><br><span class="line">    <span class="keyword">synchronized</span>(options) &#123;</span><br><span class="line">        <span class="comment">// 会去遍历options,给nioServerSocketChannel里的成员属性ServerSocketChannelConfig赋值</span></span><br><span class="line">        setChannelOptions(channel, options, logger); ，</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = <span class="keyword">this</span>.attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span>(attrs) &#123;</span><br><span class="line">        Iterator var5 = attrs.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!var5.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e = (Entry)var5.next();</span><br><span class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey)e.getKey();</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline(); <span class="comment">// 拿到NioServerSocketChannel中的pipeline</span></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = <span class="keyword">this</span>.childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = <span class="keyword">this</span>.childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry[] currentChildOptions;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.childOptions) &#123;</span><br><span class="line">        currentChildOptions = (Entry[])<span class="keyword">this</span>.childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Entry[] currentChildAttrs;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = (Entry[])<span class="keyword">this</span>.childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123; <span class="comment">// 往pipeline里添加一个handler</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = ServerBootstrap.<span class="keyword">this</span>.config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;handler&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ServerBootstrap.ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h6 id="this-config-group-register-channel"><a href="#this-config-group-register-channel" class="headerlink" title="this.config().group().register(channel);"></a>this.config().group().register(channel);</h6><br><ul><li>this.config()返回一个ServerBootstrapConfig对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractBootstrapConfig&lt;B, C&gt; <span class="title">config</span><span class="params">()</span></span>; <span class="comment">//抽象方法</span></span><br></pre></td></tr></table></figure><p>ServerBootstarp中的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerBootstrapConfig config = <span class="keyword">new</span> ServerBootstrapConfig(<span class="keyword">this</span>); <span class="comment">// 成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ServerBootstrapConfig <span class="title">config</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>ServerBootstrapConfig的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrapConfig(ServerBootstrap bootstrap) &#123;</span><br><span class="line">    <span class="keyword">super</span>(bootstrap); <span class="comment">// 往上调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrapConfig</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> B bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractBootstrapConfig</span><span class="params">(B bootstrap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将ServerBootstarp赋值给成员属性</span></span><br><span class="line">        <span class="keyword">this</span>.bootstrap = (AbstractBootstrap)ObjectUtil.checkNotNull(bootstrap, <span class="string">&quot;bootstrap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>group()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> EventLoopGroup <span class="title">group</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bootstrap.group(); <span class="comment">// this.bootstrap就是ServerBootstrap实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> EventLoopGroup group; <span class="comment">// 成员属性；具体在前文所说的ServerBootstrap里的group方法里赋的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> EventLoopGroup <span class="title">group</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.group; <span class="comment">// 就是NioEventLoopGroup，准确来说是boss线程组。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>register(channel)方法</li></ul><p>​    前面的this.config().group()会返回NioEventLoopGroup，register是抽象方法；而NioEventLoopGroup继承MultithreadEventLoopGroup，我们看MultithreadEventLoopGroup里的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123; <span class="comment">// channel ——&gt; NioServerSocketChannel</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.next().register(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventLoop <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (EventLoop)<span class="keyword">super</span>.next(); <span class="comment">// 拿一个NioEventLoop线程，前面所说会创建(默认长度为16的)children数组，并循环遍历对每一个赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>​    接着继续跟进返回的nioEventLoop的register方法，NioEventLoop继承SingleThreadEventLoop，所以我们看它里面的实现</p><p>io.netty.channel.SingleThreadEventLoop#register(io.netty.channel.Channel)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.register((ChannelPromise)(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>调用重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise); <span class="comment">// this ————&gt; NioEventLoop</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>io.netty.channel.AbstractChannel.AbstractUnsafe#register</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop; <span class="comment">// 将传进来的NioEventLoop赋值给成员属性</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123; <span class="comment">// 判断当前线程是否是NioEventLoop中的线程</span></span><br><span class="line">            <span class="keyword">this</span>.register0(promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        AbstractUnsafe.<span class="keyword">this</span>.register0(promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">               ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>先看excute方法做了什么</p><p>io.netty.util.concurrent.SingleThreadEventExecutor#execute</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> inEventLoop = <span class="keyword">this</span>.inEventLoop();</span><br><span class="line">        <span class="keyword">this</span>.addTask(task); <span class="comment">// 将任务添加到taskQueue队列</span></span><br><span class="line">        <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">            <span class="keyword">this</span>.startThread();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isShutdown()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> reject = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.removeTask(task)) &#123;</span><br><span class="line">                        reject = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedOperationException var5) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reject) &#123;</span><br><span class="line">                    reject();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.addTaskWakesUp &amp;&amp; <span class="keyword">this</span>.wakesUpForTask(task)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wakeup(inEventLoop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          ....</span><br><span class="line">            label1907: &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var112 = <span class="keyword">true</span>;</span><br><span class="line">                    SingleThreadEventExecutor.<span class="keyword">this</span>.run(); <span class="comment">// 调用NioEventLoop的run方法</span></span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                    var112 = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span> label1907;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var119) &#123;</span><br><span class="line">                    .......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">switch</span>(<span class="keyword">this</span>.selectStrategy.calculateStrategy(<span class="keyword">this</span>.selectNowSupplier, <span class="keyword">this</span>.hasTasks())) &#123;</span><br><span class="line">                        <span class="keyword">case</span> -<span class="number">3</span>:</span><br><span class="line">                        <span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">                            <span class="comment">// select()，类比NIO代码</span></span><br><span class="line">                            <span class="comment">// 方法里面会去调用  selector.select(timeoutMillis);超时等待</span></span><br><span class="line">                            <span class="keyword">this</span>.select(<span class="keyword">this</span>.wakenUp.getAndSet(<span class="keyword">false</span>)); </span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.wakenUp.get()) &#123;</span><br><span class="line">                                <span class="keyword">this</span>.selector.wakeup();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> -<span class="number">2</span>:</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var23) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.rebuildSelector0();</span><br><span class="line">                        handleLoopException(var23);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.cancelledKeys = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">this</span>.needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">                    <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">this</span>.processSelectedKeys(); <span class="comment">// 类比NIO代码,拿到SelectionKey</span></span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">this</span>.runAllTasks(); <span class="comment">// 执行任务</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                        <span class="keyword">boolean</span> var14 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            var14 = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">this</span>.processSelectedKeys();</span><br><span class="line">                            var14 = <span class="keyword">false</span>;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (var14) &#123;</span><br><span class="line">                                <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                                <span class="keyword">this</span>.runAllTasks(ioTime * (<span class="keyword">long</span>)(<span class="number">100</span> - ioRatio) / (<span class="keyword">long</span>)ioRatio);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                        <span class="keyword">this</span>.runAllTasks(ioTime * (<span class="keyword">long</span>)(<span class="number">100</span> - ioRatio) / (<span class="keyword">long</span>)ioRatio);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var24) &#123;</span><br><span class="line">                    handleLoopException(var24);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         .......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">this</span>.inEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> ranAtLeastOne = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> fetchedAll;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        fetchedAll = <span class="keyword">this</span>.fetchFromScheduledTaskQueue();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.runAllTasksFrom(<span class="keyword">this</span>.taskQueue)) &#123; <span class="comment">// 从队列中获取任务并执行</span></span><br><span class="line">            ranAtLeastOne = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(!fetchedAll);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ranAtLeastOne) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.afterRunningAllTasks();</span><br><span class="line">    <span class="keyword">return</span> ranAtLeastOne;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>回过头来看，执行任务的逻辑，即刚刚提交任务的run方法</p><blockquote><p>eventLoop.execute(new Runnable() {<br> public void run() {<br>     AbstractUnsafe.this.<strong>register0</strong>(promise);<br> }<br>});</p></blockquote><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !<span class="keyword">this</span>.ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = <span class="keyword">this</span>.neverRegistered;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.doRegister(); <span class="comment">// 注册</span></span><br><span class="line">        <span class="keyword">this</span>.neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.registered = <span class="keyword">true</span>;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        <span class="keyword">this</span>.safeSetSuccess(promise);</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.pipeline.fireChannelRegistered(); <span class="comment">// 责任链调用pipeline中的handler</span></span><br><span class="line">        <span class="keyword">if</span> (AbstractChannel.<span class="keyword">this</span>.isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                AbstractChannel.<span class="keyword">this</span>.pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AbstractChannel.<span class="keyword">this</span>.config().isAutoRead()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">        <span class="keyword">this</span>.closeForcibly();</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.closeFuture.setClosed();</span><br><span class="line">        <span class="keyword">this</span>.safeSetFailure(promise, var3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.selectionKey = <span class="keyword">this</span>.javaChannel().register(<span class="keyword">this</span>.eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>); <span class="comment">// 将serverSocketChannel注册到selector上，并让其对</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException var3) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selected) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> var3;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRegistered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRegistered(<span class="keyword">this</span>.head); <span class="comment">// 将pipeline中的头节点传进去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRegistered</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRegistered();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 接着执行</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRegistered();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><br><img src="/colinstar/2022/01/06/Netty/Netty%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.jpg" class><h1 id="无锁串行化"><a href="#无锁串行化" class="headerlink" title="无锁串行化"></a>无锁串行化</h1><p>​    大多数场景下，并行多线程处理可以提升系统的并发能力。但是，如果对于共享资源的并发访问处理不当，会带来严重的锁竞争，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗，可以通过串行化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程的切换，这样就避免了多线程竞争和同步锁。NIO的多路复用就是一种无锁串行化的设计思想。为了尽可能提升性能，Netty采用了串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上来看，串行化的设计似乎CPU利用率不高，并发成都不够，但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优</p><p>Netty的NioEventLoop读到消息之后，直接调用ChannelPipeline的fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由NioEventLoop调到用户的handler,期间不进行线程切换</p><h1 id="零拷贝（直接内存的使用）"><a href="#零拷贝（直接内存的使用）" class="headerlink" title="零拷贝（直接内存的使用）"></a>零拷贝（直接内存的使用）</h1><br><img src="/colinstar/2022/01/06/Netty/image-20220303161701778.png" class><br><p><strong>直接内存</strong></p><p>直接内存Direct Memory,并不是虚拟机运行时数据区的一部分，某些情况下这部分内存也会被频繁地使用，而且也可能导致OOM,Java里用DirectByteBuffer可以分配一块直接内存(堆外内存)</p><p>​    直接内存申请较慢，但访问效率高。在java虚拟机实现上，本地IO一般会直接操作直接内存（直接内存-&gt;系统调用 -&gt;硬盘/网卡），而非直接内存则需要二次拷贝（堆内存-&gt;直接内存-&gt;系统调用-&gt;硬盘/网卡）。</p><p>​    Netty的接收和发送ByteBuf采用DIRECT BUFFERS ， 使用堆外内存进行Scoket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的JVM堆内存（HEAP BUFFERS)进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才能写入Socket中，Jvm堆内存的数据是不能写入Socket中的。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p><p>优点：</p><p>不占用堆内存空间，减少GC发生的频率</p><p>java虚拟机实现上，本地IO会直接操作直接内存（直接内存——&gt;系统调用——&gt;硬盘/网卡），而非直接内存则需要二次拷贝（堆内存——&gt;直接内存——&gt;系统调用——&gt;硬盘/网卡）</p><p>缺点：</p><p>初始分配较慢</p><p>没有JVM直接帮助管理内存，容易发生内存溢出，为了避免一直没有FULL GC，最终导致直接内存把物理内存耗完。我们可以指定直接内存的最大值，通过-XX:MaxDirectMemorySize来指定，当达到阈值的时候，调用system.gc来进行一次FULL GC，间接把那些没有被使用的直接内存回收掉</p><p>ByteBuf内存池设计</p><p>​    随着JVM虚拟机和JIT即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区Buffer(相当于一个内存块)，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作，为了尽量重用缓冲区，Netty提供了基于ByteBuffer内存池的缓冲区重用机制。需要的时候直接从池子里获取ByteBuf使用即可，使用完毕之后就重新放回池子里去。</p><h1 id="灵活的TCP参数配置能力"><a href="#灵活的TCP参数配置能力" class="headerlink" title="灵活的TCP参数配置能力"></a>灵活的TCP参数配置能力</h1><p>​    合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如接收缓冲区SO_RCVBUF和发送缓冲区SO_SNDBUF。如果设置不当，对性能的影响是非常大的。通常建议值为128k或者256k</p><p>Netty在启动辅助类ChannelOption中可以灵活的配置TCP参数，满足不同的用户场景</p><h1 id="ByteBuf扩容机制"><a href="#ByteBuf扩容机制" class="headerlink" title="ByteBuf扩容机制"></a>ByteBuf扩容机制</h1><br><img src="/colinstar/2022/01/06/Netty/image-20220303161827343.png" class><br><p>minNewCapacity：表示用户需要写入的值大小</p><p>threshold：阈值，为bytebuf内部设定容量的最大值</p><p>maxCapacity：Netty最大能接受的容量大小，一般为int的最大值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BIO-amp-NIO-amp-AIO&quot;&gt;&lt;a href=&quot;#BIO-amp-NIO-amp-AIO&quot; class=&quot;headerlink&quot; title=&quot;BIO&amp;amp;NIO&amp;amp;AIO&quot;&gt;&lt;/a&gt;BIO&amp;amp;NIO&amp;amp;AIO&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="netty" scheme="http://c89757.gitee.io/colinstar/categories/netty/"/>
    
    
    <category term="nio" scheme="http://c89757.gitee.io/colinstar/tags/nio/"/>
    
    <category term="netty" scheme="http://c89757.gitee.io/colinstar/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>关于count(*)</title>
    <link href="http://c89757.gitee.io/colinstar/2021/12/22/%E5%85%B3%E4%BA%8Ecount()/"/>
    <id>http://c89757.gitee.io/colinstar/2021/12/22/%E5%85%B3%E4%BA%8Ecount()/</id>
    <published>2021-12-22T12:09:37.000Z</published>
    <updated>2021-12-22T13:01:32.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="count-的不同实现方式"><a href="#count-的不同实现方式" class="headerlink" title="count(*)的不同实现方式"></a>count(*)的不同实现方式</h1><hr><p>在 msyql 引擎中，count（*）有不同的实现方式</p><hr><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上,因此执行count(*)的时候会直接返回这个数，效率很高</li><li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累计计数</li></ul><p>当然，这里说的是不加where条件的count(*)，如果加了条件，MyISAM表也不能返回这么快的。</p><p>为什么InnoDB不像MyISAM一样，也把数字存起来呢？</p><p>​    因为即使在同一个时刻的多个子查询，由于多版本并发控制（MVCC）的原因，而InnoDB表 应该返回多少行 也是不确定的。</p><p>比如现在某表中有1000条数据</p><p>会话A去执行select(*)</p><p>会话B开启事务，新增一条数据，再执行select * </p><p>会话A和会话B在同一时刻执行，那么他们返回的总行数是不一样的，A返回1000，而B返回1001</p><p>这和InnoDB的事务有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB会把数据一行一行的读出来依次判断，可见的行才能够计算“基于这个查询”的表的总行数</p><blockquote><p>​    MySQL在执行 count(*)操作的时候还是做了优化的。 InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是 主键值。所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树 得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。在保证逻辑 正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一</p></blockquote><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><hr><p>如果一个页面需要经常查询显示某表的总数，应该如何去做呢？</p><hr><p>我们应该自己去计数</p><h2 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h2><p>​    可以用Redis去记录这个表的总行数。每插入一行Redis计数就加1，每删除一行Redis计数就减1。</p><p>可能存在的问题：</p><p>1、Redis可能会丢失数据，如果我们刚在表里插入了一行数据，Redis中的值也进行了自增，然后Redis宕机了，还没来得及进行持久化，导致数据的丢失；</p><p>（我们可以在Redis宕机后，手动select(*)查询总行数写回Redis)</p><p>2、Redis和MySql存在分布式事务问题；</p><p>比如某个场景下，我们需要查询显示总数，并且还要显示最近操作的100条记录。那我们就需要先从Redis里面取出计数，再去表里取数据记录</p><p>可能存在的问题，查到的100行里面没有新增的数据，但Redis的计数已经加1</p><p>另一种是，查到的100行有新增的数，但是Redis的计数还没加1</p><p>产生的原因就是，无法保证提交数据库事务的同时写入Redis，</p><h2 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h2><p>​    用一张表去记录总数，可以避免上述问题，因此事务的可见性，我们插入数据和修改表中记录的行数都是在方法执行完后统一提交的事务，事务还未提交时，对其他线程是不可见的</p><ul><li>从并发系统性能的角度看，应该先插数据表，还是先更新计数表呢？</li></ul><p>更新计数表会涉及到行锁的竞争，先插入再更新能最大程度的减少了事务之间的锁等待，提高并发度（事务开启后，更新操作放到最后，减少锁等待时间的影响）</p><h1 id="不同count的用法"><a href="#不同count的用法" class="headerlink" title="不同count的用法"></a>不同count的用法</h1><p>count(*)、count(id)、count(字段)、count(1)的用法的性能，有哪些差别呢。</p><hr><p>基于InnoDB引擎</p><hr><p>count（）是一个聚合函数，对于返回的结果集，一行一行的判断，如果count函数的参数不是null,就会累计值加1，否则不加。</p><p>所以count(*),count(id),count(字段),count(1)都返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里，参数“字段”不为null的总个数</p><ul><li><p>对于count(id)来说。InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层，server层拿到id后，判断是不可能为空的，就按行累加</p></li><li><p>对于count(1)来说。InnoDB引擎遍历整张表，但是不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加</p></li></ul><p>count(*)执行的要比count(id)快，因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作</p><ul><li>对于count(字段)来说。 如果这个字段是定义为not null的话，一行行的从记录里面读取出这个字段，判断不能为null,按行累加； 如果这个字段允许为空，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加</li><li>对于count(*)来说。并不会把全部字段取出来，而是专门做了优化，不取值，count(*)肯定不是null,按行累加</li></ul><p>按照效率排序的话，count(字段) &lt; count(id) &lt; count(1) ≈ count(*)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;count-的不同实现方式&quot;&gt;&lt;a href=&quot;#count-的不同实现方式&quot; class=&quot;headerlink&quot; title=&quot;count(*)的不同实现方式&quot;&gt;&lt;/a&gt;count(*)的不同实现方式&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;在 msyql 引擎中，count</summary>
      
    
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Sychronized关键字-monitorenter与monitorexit</title>
    <link href="http://c89757.gitee.io/colinstar/2021/12/17/Sychronized%E5%85%B3%E9%94%AE%E5%AD%97-monitorenter%E4%B8%8Emonitorexit/"/>
    <id>http://c89757.gitee.io/colinstar/2021/12/17/Sychronized%E5%85%B3%E9%94%AE%E5%AD%97-monitorenter%E4%B8%8Emonitorexit/</id>
    <published>2021-12-17T11:19:25.000Z</published>
    <updated>2022-01-15T15:13:50.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每个对象都有一个Monitor与之关联，当Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>经过javap解析后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">   Code:</span><br><span class="line">      <span class="number">0</span>: aload_0</span><br><span class="line">      <span class="number">1</span>: dup</span><br><span class="line">      <span class="number">2</span>: astore_1</span><br><span class="line">      <span class="number">3</span>: monitorenter</span><br><span class="line">      <span class="number">4</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">7</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world</span></span><br><span class="line">      <span class="number">9</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">     <span class="number">12</span>: aload_1</span><br><span class="line">     <span class="number">13</span>: monitorexit</span><br><span class="line">     <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">     <span class="number">17</span>: astore_2</span><br><span class="line">     <span class="number">18</span>: aload_1</span><br><span class="line">     <span class="number">19</span>: monitorexit</span><br><span class="line">     <span class="number">20</span>: aload_2</span><br><span class="line">     <span class="number">21</span>: athrow</span><br><span class="line">     <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">   Exception table:</span><br><span class="line">      from    to  target type</span><br><span class="line">          <span class="number">4</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">         <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   any</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此处会发现有一个monitorenter，却有两个monitorexit；<br>这是JVM的补偿机制，保证你的同步代码块中出现异常，能正常释放锁</p><p>如字节码行号4-13可能会出现异常，则会走17进行异常处理，在此处进行锁的释放</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每个对象都有一个Monitor与之关联，当Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，都可以通过成对的MonitorEnter和MonitorE</summary>
      
    
    
    
    <category term="JUC" scheme="http://c89757.gitee.io/colinstar/categories/JUC/"/>
    
    
    <category term="JUC" scheme="http://c89757.gitee.io/colinstar/tags/JUC/"/>
    
    <category term="多线程" scheme="http://c89757.gitee.io/colinstar/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySql性能调优</title>
    <link href="http://c89757.gitee.io/colinstar/2021/12/16/MySql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://c89757.gitee.io/colinstar/2021/12/16/MySql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</id>
    <published>2021-12-16T15:08:30.000Z</published>
    <updated>2021-12-17T11:47:30.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="啥也没有，只是为了样式展示"><a href="#啥也没有，只是为了样式展示" class="headerlink" title="啥也没有，只是为了样式展示"></a>啥也没有，只是为了样式展示</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;啥也没有，只是为了样式展示&quot;&gt;&lt;a href=&quot;#啥也没有，只是为了样式展示&quot; class=&quot;headerlink&quot; title=&quot;啥也没有，只是为了样式展示&quot;&gt;&lt;/a&gt;啥也没有，只是为了样式展示&lt;/h1&gt;</summary>
      
    
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>gitee+hexo搭建个人博客</title>
    <link href="http://c89757.gitee.io/colinstar/2021/12/16/gitee+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://c89757.gitee.io/colinstar/2021/12/16/gitee+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-12-16T12:42:22.000Z</published>
    <updated>2021-12-17T11:49:04.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h1><p>事前准备：</p><p>先创建一个仓库，同时在仓库根目录下创建index.html (gitee官网这样说的,没试过缺少这个文件会怎样)</p><img src="/colinstar/2021/12/16/gitee+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.png" class title="This is an example image"><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><h2 id="所需环境"><a href="#所需环境" class="headerlink" title="所需环境"></a>所需环境</h2><ul><li><p>node.js</p></li><li><p>git</p><p>自行进行下载与安装</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装hexo</span></span><br><span class="line">npm install -g hexo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建文件夹,用来存储你博客内容</span></span><br><span class="line">hexo init test</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span>到创建的目录,执行</span></span><br><span class="line">npm install</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启hexo服务</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:4000；没有问题的话就会显示他的默认页面">http://localhost:4000；没有问题的话就会显示他的默认页面</a></p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>关联git仓库，在你创建的目录下找到 config.yml文件（例如此处我的是test/_config.yml）</p><p>打开添加如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://gitee.com/xxx/xxxx</span>   <span class="comment"># 你的仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span>   <span class="comment"># 你的仓库分支</span></span><br></pre></td></tr></table></figure><ul><li>生成静态页面</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g    #或者 hexo generate</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时若出现如下报错：</span></span><br><span class="line">ERROR Local hexo not found in ~/blog</span><br><span class="line">ERROR Try runing: &#x27;npm install hexo --save&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 则执行命令：</span></span><br><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><ul><li>将生成的页面提交到仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d  #或者hexo deploy</span><br></pre></td></tr></table></figure><p>若执行命令hexo deploy报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h1 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h1><p>进入到你创建的“text”目录，新建文章，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;blog&quot;</span><br></pre></td></tr></table></figure><p>此时在test/source/_posts下，会新建一个名为“blog.md”的文件，利用相关markdown编辑器就能编写你的博客啦!(我这里用的typore)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 生成静态页面</span><br><span class="line"></span><br><span class="line">hexo d # 部署到gitee</span><br></pre></td></tr></table></figure><p>hexo有许多主题，默认生成的主题都是landscape，你也可以去<a href="http://hexo.io/themes">主题官网</a>寻找自己喜欢的主题</p><p>例如主题pure</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/cofess/hexo-theme-pure.git themes/pure</span><br><span class="line"><span class="meta">#</span><span class="bash">修改<span class="built_in">test</span>目录下_config.yml里theme的名称,将landscape修改为pure即可</span> </span><br><span class="line"></span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta">#</span><span class="bash">清除缓存文件 (db.json) 和静态文件 (public)</span></span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta">#</span><span class="bash">生成缓存和静态文件</span></span><br><span class="line"></span><br><span class="line">hexo d             </span><br><span class="line"><span class="meta">#</span><span class="bash">重新部署到服务器</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;事前准备：&lt;/p&gt;
&lt;p&gt;先创建一个仓库，同时在仓库根目录下创建index.html (gitee官网这样</summary>
      
    
    
    
    <category term="others" scheme="http://c89757.gitee.io/colinstar/categories/others/"/>
    
    
    <category term="others" scheme="http://c89757.gitee.io/colinstar/tags/others/"/>
    
  </entry>
  
</feed>
