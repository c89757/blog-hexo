<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://c89757.gitee.io/colinstar/atom.xml" rel="self"/>
  
  <link href="http://c89757.gitee.io/colinstar/"/>
  <updated>2022-01-06T12:59:19.846Z</updated>
  <id>http://c89757.gitee.io/colinstar/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty</title>
    <link href="http://c89757.gitee.io/colinstar/2022/01/06/Netty/"/>
    <id>http://c89757.gitee.io/colinstar/2022/01/06/Netty/</id>
    <published>2022-01-06T12:58:22.000Z</published>
    <updated>2022-01-06T12:59:19.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BIO-amp-NIO-amp-AIO"><a href="#BIO-amp-NIO-amp-AIO" class="headerlink" title="BIO&amp;NIO&amp;AIO"></a>BIO&amp;NIO&amp;AIO</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><img src="/colinstar/2022/01/06/Netty/BIO%E6%A8%A1%E5%9E%8B.jpg" class><p>blocking  I/O , 即阻塞IO，同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）</p><p>先看单线程的版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            log.info(<span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">            <span class="keyword">if</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">                log.info(<span class="string">&quot;收到消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">            &#125;</span><br><span class="line">            socket.getOutputStream().write(<span class="string">&quot;已成功接收到消息&quot;</span>.getBytes());</span><br><span class="line">            socket.getOutputStream().flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Debug启动程序，在serverSocket.accept()处打上断点，同时再下一行处也打上断点，然后我们点击idea调试的Resume Program按钮，让程序直接走完；我们会发现断点没有到达下一行，程序也没有停止，而是阻塞在了accept()里。</p><img src="/colinstar/2022/01/06/Netty/image-20211228135209446.png" class><p>我们试着用telnet工具去连接程序</p><img src="/colinstar/2022/01/06/Netty/image-20211228135657845.png" class><p>按下回车连接的同时，我们也会发现程序的断点跑到了下一行</p><img src="/colinstar/2022/01/06/Netty/image-20211228135818793.png" class><p>我们再在 int read = inputStream.read(bytes);这一行及其下一行也打上断点；</p><img src="/colinstar/2022/01/06/Netty/image-20211228140749246.png" class><p>程序来到inputStream.read(bytes)这一行，我们再次选择放掉这一个断点，发现此处程序也并没有来到下一行，也是在此处进行了阻塞</p><img src="/colinstar/2022/01/06/Netty/image-20211228140830135.png" class><p>我们用telnet工具给服务端发送消息</p><img src="/colinstar/2022/01/06/Netty/image-20211228141003312.png" class><p>回到程序，发现程序执行到了下一行</p><img src="/colinstar/2022/01/06/Netty/image-20211228141032475.png" class><p>接下来我们重新开始，重新启动服务端，开启一个telnet（客户端1）去连接，但是不发送消息，让程序阻塞在int read = inputStream.read(bytes)这一行；与此同时，我们再另外开启一个telnet客户端（客户端2）去进行连接，然后发送消息给服务端</p><img src="/colinstar/2022/01/06/Netty/image-20211228141938073.png" class><p>但是我们发现，控制台并没有任何消息打印；</p><p>我们此时在用客户端1去发送消息</p><img src="/colinstar/2022/01/06/Netty/image-20211228142756229.png" class><p>发现客户端打印消息，但是打印hello2之前，输出了”建立连接“；说明此时我们其实客户端2并没有真正的连接上，而是阻塞在了serverSocket.accept()处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">log.info(<span class="string">&quot;建立连接&quot;</span>);</span><br></pre></td></tr></table></figure><img src="/colinstar/2022/01/06/Netty/image-20211228143047146.png" class><blockquote><p><strong>在同一时刻，服务端只能响应一个客户端</strong></p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们可以在将代码改成多线程版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBIO</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestBIO</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">        log.info(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            log.info(<span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">            threadPoolExecutor.execute(<span class="keyword">new</span> TestBIO(socket));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>)&#123; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">        <span class="keyword">if</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;收到消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">        &#125;</span><br><span class="line">        socket.getOutputStream().write(<span class="string">&quot;已成功接收到消息&quot;</span>.getBytes());</span><br><span class="line">        socket.getOutputStream().flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler(<span class="keyword">this</span>.socket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再实验以上步骤</p><p>先开启telnet客户端1去连接阻塞，但是不发送消息</p><p>再开启telnet客户端2去连接，并发送消息</p><p>结果此次控制台能正确接收到消息</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a><strong>存在的问题</strong></h3><p>如果开辟大量线程，比较消耗资源，且如果我们用了线程池，如果我们线程池数量是500，某一瞬间并发量有1w，那后面的请求就只能阻塞等待。又或者500线程池，其中400个线程只是和你建立连接，并不立马发送消息给服务端，那这个线程会一直被这个连接给占用，其他人无法获取; 又或者用完线程给别人用时，线程的切换也是比较消耗资源的</p><ul><li>IO代码里read操作是阻塞操作，如果连接不做数据读写会导致线程阻塞，浪费资源</li><li>如果线程很多，会导致服务器线程太大，压力太大</li></ul><p>应用场景：BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高</p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>Non Blocking IO,或者读为New IO,同步非阻塞，服务器实现模式为<strong>一个线程可以处理多个请求（连接）</strong>，客户端发送的连接请求都会注册到<strong>多路复用器selector</strong>上，多路复用器轮询到连接有IO请求就进行处理，JDK1.4开始引入</p><img src="/colinstar/2022/01/06/Netty/image-20211229140326931.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;SocketChannel&gt; channelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 非阻塞模式accept方法不会阻塞，否则会阻塞</span></span><br><span class="line">            <span class="comment">// NIO的非阻塞是由操作系统内部实现的，底层调用了linux内核的accept函数</span></span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123; <span class="comment">// 如果有客户端进行连接</span></span><br><span class="line">                log.info(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                <span class="comment">// 设置SocketChannel为非阻塞</span></span><br><span class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 保存客户端连接在list中</span></span><br><span class="line">                channelList.add(socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历连接进行数据读取</span></span><br><span class="line">            Iterator&lt;SocketChannel&gt; iterator = channelList.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SocketChannel next = iterator.next();</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                <span class="comment">// 非阻塞模式read方法不会阻塞</span></span><br><span class="line">                <span class="keyword">int</span> len = next.read(byteBuffer);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;接收到消息: &#123;&#125;&quot;</span>, <span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123; <span class="comment">// 如果客户端断开，把socket从集合中删调</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    log.info(<span class="string">&quot;与客户端断开连接&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先后开启两个telnet客户端去连接服务端，发送消息，服务端都能接收到;</p><p>会一直循环去判断是否有新的连接请求，是否有连接发送消息</p><p><strong>上述代码存在的问题：</strong></p><p>如果连接数太多的话，会有大量的无效遍历</p><p>比如如果我现在有10万个连接，但是经常给服务端发消息的就那个几百个，但是每次都要去遍历所有的连接</p><p>我们可以将那些有数据交互的连接，存储在另外一个数据结构中，每次遍历只需要遍历那些有数据交互的连接</p><p>NIO引入多路复用器代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSelectorServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 打开selector处理Channel，即创建epoll</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 把ServerSocketChannel注册到selector上，并且selector监听客户端accept连接事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待需要处理的事件发生</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">// 获取selector中注册的全部事件的SelectionKey实例</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="comment">// 遍历SelectionKey对事件进行处理</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">// 如果是OP_ACCEPT事件，则进行连接获取和事件注册</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    ServerSocketChannel channel =(ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="keyword">final</span> SocketChannel socketChannel = channel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 这里只注册了读事件，如果需要给客户端发送数据可以注册写事件</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                    log.info(<span class="string">&quot;客户端连接成功&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123; <span class="comment">// 如果是OP_READ事件，则进行读取和打印</span></span><br><span class="line">                    SocketChannel channel =(SocketChannel)key.channel();</span><br><span class="line">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">int</span> len = channel.read(byteBuffer);</span><br><span class="line">                    <span class="keyword">if</span> (len &gt;<span class="number">0</span> )&#123;</span><br><span class="line">                        log.info(<span class="string">&quot;接收到消息:&#123;&#125;&quot;</span>,<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == -<span class="number">1</span>)&#123;</span><br><span class="line">                        log.info(<span class="string">&quot;客户端断开连接&quot;</span>);</span><br><span class="line">                        channel.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从事件集合里删除本次处理的key,防止下次select重复处理</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先看一幅图</p><p>NIO有三大核心组件：<strong>Channel(通道)，Buffer(缓冲区)，Selector(多路复用器)</strong></p><p>1、channel类似于流，每个channel对应一个buffer缓冲区，buffer底层就是个数组</p><p>2、channel会注册到selector上，由selector根据channel独写事件的发生将其交由某个空闲的线程处理</p><p>3、NIO的Buffer和channe都是既可以读也可以写</p><img src="/colinstar/2022/01/06/Netty/image-20211229142929435.png" class><p>​    我们代码最开始处，创建了一个ServerSocketChannel，并绑定9000端口,并将ServerSocketChannel注册到selector上，并且selector监听客户端accept连接事件，注册上后会返回一个key,通过这个selectionKey可以找到与之绑定的ServerSocketChannel;</p><p>​    我们在selector.select()处及其下一行打上断点，启动项目。</p><img src="/colinstar/2022/01/06/Netty/image-20211229145434837.png" class><p>​    放掉断点让其走完，发现程序阻塞在了这一行；</p><p>​    同样的，打开cmd，用telnet连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 9000</span><br></pre></td></tr></table></figure><p>​    连接上后，发现程序走到了下一行</p><img src="/colinstar/2022/01/06/Netty/image-20211229145749365.png" class><p>​    继续往下走一行，获取到所有的selectionKey; 因为此时我们只有一个客户端进行连接，所以此处size是1</p><img src="/colinstar/2022/01/06/Netty/image-20211229150505122.png" class><p>​    很显然我们此处是OP_ACCEPT事件</p><img src="/colinstar/2022/01/06/Netty/image-20211229152042072.png" class><p>​    通过selectionKey可以拿到与之绑定的ServerSocketChannel，并让其与客户端建立连接,并把客户端对应的socketChannel也注册到selector上，并让其监听读事件（读是相当于服务端来的，也就是监听客户端发送过来的消息）</p><p>​    我们一步一步调试，让程序走完，因为是死循环，在select处又会进行阻塞，因为此时既没有新的客户端连接进来，刚刚连接上的客户端也没有发送消息。</p><img src="/colinstar/2022/01/06/Netty/image-20211229154555019.png" class><p>​    我们用telnet再给服务端发送一条消息</p><img src="/colinstar/2022/01/06/Netty/image-20211229154651306.png" class><p>​    此时，程序停止了阻塞，走到了下一行</p><p>​    一步一步调试，很显然这次我们是OP_READ事件，通过key拿到与客户端对应的SocketChannel。也就是下图标识出来的部分，用它来读取客户端的数据</p><img src="/colinstar/2022/01/06/Netty/image-20211229155841635.png" class><img src="/colinstar/2022/01/06/Netty/image-20211229155400979.png" class><p>​    我们现在再另外开启一个telnet客户端，连接服务端</p><img src="/colinstar/2022/01/06/Netty/image-20211229162707964.png" class><p>​    我们可以看到，现在有两个客户端，但是拿到的selectionKey只有一个，只针对那些发生的事件进行处理</p><p>​    NIO底层在JDK1.4版本是用linux的内核函数select()或poll()来实现，跟上面最开始的代码类似，selector每次都会轮询所有的socketChannel看下哪个channel有读写事件，有的话就处理，没有就继续遍历，JDK1.5引入了epoll基于事件响应机制来优化NIO</p><h3 id="几个核心API"><a href="#几个核心API" class="headerlink" title="几个核心API"></a><strong>几个核心API</strong></h3><h4 id="Selector-open"><a href="#Selector-open" class="headerlink" title="Selector.open();"></a>Selector.open();</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><ul><li>provider()方法里最终调用了下面的create()方法，发现其new 了一个WindowsSelectorProvider()。因为我们日常使用的是windows的jdk</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectorProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectorProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowsSelectorProvider();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下载openJdk8u的源码，搜索DefaultSelectorProvider这个类，发现有三个，分别对应unix系统，mac系统，windows系统。我们接下来看unix系统对应的源码</li></ul><img src="/colinstar/2022/01/06/Netty/image-20211230144907856.png" class><ul><li>unix系统create()方法的源码如下，发现和windows的有区别，如果是linux系统，会返回EPollSelectorProvider这个类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String osname = AccessController</span><br><span class="line">        .doPrivileged(<span class="keyword">new</span> GetPropertyAction(<span class="string">&quot;os.name&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (osname.equals(<span class="string">&quot;SunOS&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> createProvider(<span class="string">&quot;sun.nio.ch.DevPollSelectorProvider&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (osname.equals(<span class="string">&quot;Linux&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> createProvider(<span class="string">&quot;sun.nio.ch.EPollSelectorProvider&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> sun.nio.ch.PollSelectorProvider();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>open()方法里会调用openSelector()这个方法，<code>EPollSelectorProvider</code>里的实现如下，直接new 了一个EPollSelectorImpl</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EPollSelectorProvider</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">SelectorProviderImpl</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractSelector <span class="title">openSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EPollSelectorImpl(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Channel <span class="title">inheritedChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InheritedChannel.getChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接着我们去看看<code>EpollSelectorImpl</code>这个类的构造函数，初始化的时候， <code>new EPollArrayWrapper()</code>创建了一个EPollArrayWrapper对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EPollSelectorImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    <span class="keyword">long</span> pipeFds = IOUtil.makePipe(<span class="keyword">false</span>);</span><br><span class="line">    fd0 = (<span class="keyword">int</span>) (pipeFds &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line">    fd1 = (<span class="keyword">int</span>) pipeFds;</span><br><span class="line">    pollWrapper = <span class="keyword">new</span> EPollArrayWrapper();</span><br><span class="line">    pollWrapper.initInterrupt(fd0, fd1);</span><br><span class="line">    fdToKey = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>紧接着我们看到<code>EPollArrayWrapper</code>的构造函数，里面调用了一个epollCreate（）方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EPollArrayWrapper() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// creates the epoll file descriptor</span></span><br><span class="line">    epfd = epollCreate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the epoll_event array passed to epoll_wait</span></span><br><span class="line">    <span class="keyword">int</span> allocationSize = NUM_EPOLLEVENTS * SIZE_EPOLLEVENT;</span><br><span class="line">    pollArray = <span class="keyword">new</span> AllocatedNativeObject(allocationSize, <span class="keyword">true</span>);</span><br><span class="line">    pollArrayAddress = pollArray.address();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eventHigh needed when using file descriptors &gt; 64k</span></span><br><span class="line">    <span class="keyword">if</span> (OPEN_MAX &gt; MAX_UPDATE_ARRAY_SIZE)</span><br><span class="line">        eventsHigh = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epollCreate是一个本地方法 （java的native方法是通过JNI，即java native interface来实现的，可以通过它来实现java与其他语言之间的交互）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">epollCreate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>EPollArrayWrapper.c里找到这个epollCreate方法, epoll_create是linux的一个系统函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_sun_nio_ch_EPollArrayWrapper_epollCreate</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * epoll_create expects a size as a hint to the kernel about how to</span></span><br><span class="line"><span class="comment">     * dimension internal structures. We can&#x27;t predict the size in advance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       JNU_ThrowIOExceptionWithLastError(env, <span class="string">&quot;epoll_create failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> epfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>我们在linux系统上执行 <code>man epoll_create</code>命令，查看这个函数的文档</p><p>-打开一个文件描述符，相当于创建了一个epoll对象，返回文件描述符的索引 int epfd = epoll_create(256)</p></li></ul><img src="/colinstar/2022/01/06/Netty/image-20211230153144948.png" class><h4 id="serverSocketChannel-register-…"><a href="#serverSocketChannel-register-…" class="headerlink" title="serverSocketChannel.register(…)"></a>serverSocketChannel.register(…)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><ul><li>java.nio.channels.SelectableChannel#register(java.nio.channels.Selector, int)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(sel, ops, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java.nio.channels.spi.AbstractSelectableChannel#register</li></ul><p>这个方法里面最终又调用了一个register方法，我们再点进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   Object att)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">        .....</span><br><span class="line">            <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">                k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att); <span class="comment">// 主要看这个register方法</span></span><br><span class="line">                addKey(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>sun.nio.ch.SelectorImpl#register</p><p>这个里面又调用了一个implRegister（）方法，我们点进去是个抽象方法</p><p><code>protected abstract void implRegister(SelectionKeyImpl var1);</code></p><p>查看他的实现类，来到了WindowsSelectorImpl，这是windows系统的实现，我们去查看linux的implRegister的实现方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel var1, <span class="keyword">int</span> var2, Object var3)</span> </span>&#123;</span><br><span class="line">   ....</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.publicKeys) &#123;</span><br><span class="line">            <span class="keyword">this</span>.implRegister(var4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sun.nio.ch.EPollSelectorImpl#implRegister</li></ul><p> <code>pollWrapper.add(fd);</code> fd是文件描述符，会根据这个索引找到这个文件（linux一切皆文件），在此处就是linux系统能够根据pd这个文件描述符找到这个创建好的serverSocketChannel；</p><p>这个pollWrapper就是上面Selector.open()里创建的pollWrapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">    SelChImpl ch = ski.channel;</span><br><span class="line">    <span class="keyword">int</span> fd = Integer.valueOf(ch.getFDVal());</span><br><span class="line">    fdToKey.put(fd, ski);</span><br><span class="line">    pollWrapper.add(fd);</span><br><span class="line">    keys.add(ski);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="selector-select"><a href="#selector-select" class="headerlink" title="selector.select();"></a>selector.select();</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line"> ....</span><br><span class="line">selector.select();</span><br></pre></td></tr></table></figure><ul><li>select是一个抽象方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>点进实现类</p><ul><li>sun.nio.ch.SelectorImpl#select()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.select(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lockAndDoSelect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1 &lt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative timeout&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lockAndDoSelect(var1 == <span class="number">0L</span> ? -<span class="number">1L</span> : var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sun.nio.ch.SelectorImpl#lockAndDoSelect</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lockAndDoSelect</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     ......</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.publicKeys) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="keyword">this</span>.publicSelectedKeys) &#123;</span><br><span class="line">                    var10000 = <span class="keyword">this</span>.doSelect(var1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doSelect是一个抽象方法，点进实现类来到了WindowsSelectorImpl。同样的，我们需要看linux的实现<code>EPollSelectorImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>sun.nio.ch.EPollSelectorImpl#doSelect</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   .......</span><br><span class="line">        pollWrapper.poll(timeout);</span><br><span class="line">   .......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sun.nio.ch.EPollArrayWrapper#poll</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    updateRegistrations();</span><br><span class="line">    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;updated; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDescriptor(i) == incomingInterruptFD) &#123;</span><br><span class="line">            interruptedIndex = i;</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> updated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看updateRegistrations（）方法</p><ol><li>updateRegistrations();</li></ol><p>此方法里又调用了一个<code>epollCtl(epfd, opcode, fd, events)</code> ，点进去，这是一个本地方法</p><p><code>private native void epollCtl(int epfd, int opcode, int fd, int events);</code></p><p>内部调用的就是linux函数epoll_ctl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRegistrations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (updateLock) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; updateCount) &#123;</span><br><span class="line">                <span class="keyword">int</span> fd = updateDescriptors[j];</span><br><span class="line">                <span class="keyword">short</span> events = getUpdateEvents(fd);</span><br><span class="line">                <span class="keyword">boolean</span> isRegistered = registered.get(fd);</span><br><span class="line">                <span class="keyword">int</span> opcode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (events != KILLED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isRegistered) &#123;</span><br><span class="line">                        opcode = (events != <span class="number">0</span>) ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        opcode = (events != <span class="number">0</span>) ? EPOLL_CTL_ADD : <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (opcode != <span class="number">0</span>) &#123;</span><br><span class="line">                        epollCtl(epfd, opcode, fd, events);</span><br><span class="line">                        <span class="keyword">if</span> (opcode == EPOLL_CTL_ADD) &#123;</span><br><span class="line">                            registered.set(fd);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == EPOLL_CTL_DEL) &#123;</span><br><span class="line">                            registered.clear(fd);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            updateCount = <span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在linux系统上执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man epoll_ctl</span><br></pre></td></tr></table></figure><p> 查看此函数</p><img src="/colinstar/2022/01/06/Netty/image-20220106101739198.png" class><p><code>epollCtl(epfd, opcode, fd, events);</code></p><p>epfd epoll实例对应的文件描述符</p><p>fd  socketChannel对应的文件描述符<br>events 事件</p><p>参数opcode又以下几个值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EPOLL_CTL_ADD // 注册新的SocketChannel到epoll实例中，并关联事件event</span><br><span class="line">EPOLL_CTL_DEL // 修改已经注册的SocketChannel的监听事件</span><br><span class="line">EPOLL_CTL_MOD // 从epoll中移除SocketChannel，并且忽略掉绑定的event</span><br></pre></td></tr></table></figure><p>epollCtl这个方法把SocketChannel和epoll关联起来</p><p>2.updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</p><p>再回到poll方法里，程序继续往下走，接着看epollWait这个方法，点进去也是一个本地方法，也是调用的操作系统内核函数</p><p>epoll_wait</p><blockquote><p>epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor</p></blockquote><p>epoll_wait的时候，会去查看sector里面的rdlist就绪列表里是否有数据，有数据就跳出阻塞，没有就阻塞住</p><p>利用操作系统回调函数，客户端有响应，把事件放进rdlist</p><img src="/colinstar/2022/01/06/Netty/image-20220106113434967.png" class><h2 id="AIO（NIO-2-0）"><a href="#AIO（NIO-2-0）" class="headerlink" title="AIO（NIO 2.0）"></a>AIO（NIO 2.0）</h2><p>异步非阻塞，由操作系统完成后回调通知服务端程序启动线程去处理，一般适用于连接数较多并且连接时间较长的应用</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line">        serverSocketChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel socketChannel, Object attachment)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2----&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="comment">// 再此接收客户端连接,如果不写这行代码后面的客户端连接不上服务端</span></span><br><span class="line">                    serverSocketChannel.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line">                    System.out.println(socketChannel.getRemoteAddress());</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel.read(buffer, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;3---&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, result));</span><br><span class="line">                            socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;HelloClient&quot;</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                            exc.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;1---&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BIO-amp-NIO-amp-AIO&quot;&gt;&lt;a href=&quot;#BIO-amp-NIO-amp-AIO&quot; class=&quot;headerlink&quot; title=&quot;BIO&amp;amp;NIO&amp;amp;AIO&quot;&gt;&lt;/a&gt;BIO&amp;amp;NIO&amp;amp;AIO&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="nio" scheme="http://c89757.gitee.io/colinstar/categories/nio/"/>
    
    
    <category term="nio" scheme="http://c89757.gitee.io/colinstar/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>关于count(*)</title>
    <link href="http://c89757.gitee.io/colinstar/2021/12/22/%E5%85%B3%E4%BA%8Ecount()/"/>
    <id>http://c89757.gitee.io/colinstar/2021/12/22/%E5%85%B3%E4%BA%8Ecount()/</id>
    <published>2021-12-22T12:09:37.000Z</published>
    <updated>2021-12-22T13:01:32.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="count-的不同实现方式"><a href="#count-的不同实现方式" class="headerlink" title="count(*)的不同实现方式"></a>count(*)的不同实现方式</h1><hr><p>在 msyql 引擎中，count（*）有不同的实现方式</p><hr><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上,因此执行count(*)的时候会直接返回这个数，效率很高</li><li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累计计数</li></ul><p>当然，这里说的是不加where条件的count(*)，如果加了条件，MyISAM表也不能返回这么快的。</p><p>为什么InnoDB不像MyISAM一样，也把数字存起来呢？</p><p>​    因为即使在同一个时刻的多个子查询，由于多版本并发控制（MVCC）的原因，而InnoDB表 应该返回多少行 也是不确定的。</p><p>比如现在某表中有1000条数据</p><p>会话A去执行select(*)</p><p>会话B开启事务，新增一条数据，再执行select * </p><p>会话A和会话B在同一时刻执行，那么他们返回的总行数是不一样的，A返回1000，而B返回1001</p><p>这和InnoDB的事务有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB会把数据一行一行的读出来依次判断，可见的行才能够计算“基于这个查询”的表的总行数</p><blockquote><p>​    MySQL在执行 count(*)操作的时候还是做了优化的。 InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是 主键值。所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树 得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。在保证逻辑 正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一</p></blockquote><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><hr><p>如果一个页面需要经常查询显示某表的总数，应该如何去做呢？</p><hr><p>我们应该自己去计数</p><h2 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h2><p>​    可以用Redis去记录这个表的总行数。每插入一行Redis计数就加1，每删除一行Redis计数就减1。</p><p>可能存在的问题：</p><p>1、Redis可能会丢失数据，如果我们刚在表里插入了一行数据，Redis中的值也进行了自增，然后Redis宕机了，还没来得及进行持久化，导致数据的丢失；</p><p>（我们可以在Redis宕机后，手动select(*)查询总行数写回Redis)</p><p>2、Redis和MySql存在分布式事务问题；</p><p>比如某个场景下，我们需要查询显示总数，并且还要显示最近操作的100条记录。那我们就需要先从Redis里面取出计数，再去表里取数据记录</p><p>可能存在的问题，查到的100行里面没有新增的数据，但Redis的计数已经加1</p><p>另一种是，查到的100行有新增的数，但是Redis的计数还没加1</p><p>产生的原因就是，无法保证提交数据库事务的同时写入Redis，</p><h2 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h2><p>​    用一张表去记录总数，可以避免上述问题，因此事务的可见性，我们插入数据和修改表中记录的行数都是在方法执行完后统一提交的事务，事务还未提交时，对其他线程是不可见的</p><ul><li>从并发系统性能的角度看，应该先插数据表，还是先更新计数表呢？</li></ul><p>更新计数表会涉及到行锁的竞争，先插入再更新能最大程度的减少了事务之间的锁等待，提高并发度（事务开启后，更新操作放到最后，减少锁等待时间的影响）</p><h1 id="不同count的用法"><a href="#不同count的用法" class="headerlink" title="不同count的用法"></a>不同count的用法</h1><p>count(*)、count(id)、count(字段)、count(1)的用法的性能，有哪些差别呢。</p><hr><p>基于InnoDB引擎</p><hr><p>count（）是一个聚合函数，对于返回的结果集，一行一行的判断，如果count函数的参数不是null,就会累计值加1，否则不加。</p><p>所以count(*),count(id),count(字段),count(1)都返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里，参数“字段”不为null的总个数</p><ul><li><p>对于count(id)来说。InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层，server层拿到id后，判断是不可能为空的，就按行累加</p></li><li><p>对于count(1)来说。InnoDB引擎遍历整张表，但是不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加</p></li></ul><p>count(*)执行的要比count(id)快，因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作</p><ul><li>对于count(字段)来说。 如果这个字段是定义为not null的话，一行行的从记录里面读取出这个字段，判断不能为null,按行累加； 如果这个字段允许为空，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加</li><li>对于count(*)来说。并不会把全部字段取出来，而是专门做了优化，不取值，count(*)肯定不是null,按行累加</li></ul><p>按照效率排序的话，count(字段) &lt; count(id) &lt; count(1) ≈ count(*)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;count-的不同实现方式&quot;&gt;&lt;a href=&quot;#count-的不同实现方式&quot; class=&quot;headerlink&quot; title=&quot;count(*)的不同实现方式&quot;&gt;&lt;/a&gt;count(*)的不同实现方式&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;在 msyql 引擎中，count</summary>
      
    
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Sychronized关键字-monitorenter与monitorexit</title>
    <link href="http://c89757.gitee.io/colinstar/2021/12/17/Sychronized%E5%85%B3%E9%94%AE%E5%AD%97-monitorenter%E4%B8%8Emonitorexit/"/>
    <id>http://c89757.gitee.io/colinstar/2021/12/17/Sychronized%E5%85%B3%E9%94%AE%E5%AD%97-monitorenter%E4%B8%8Emonitorexit/</id>
    <published>2021-12-17T11:19:25.000Z</published>
    <updated>2021-12-17T11:47:41.031Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每个对象都有一个Monitor与之关联，当Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>经过javap解析后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">   Code:</span><br><span class="line">      <span class="number">0</span>: aload_0</span><br><span class="line">      <span class="number">1</span>: dup</span><br><span class="line">      <span class="number">2</span>: astore_1</span><br><span class="line">      <span class="number">3</span>: monitorenter</span><br><span class="line">      <span class="number">4</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">7</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world</span></span><br><span class="line">      <span class="number">9</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">     <span class="number">12</span>: aload_1</span><br><span class="line">     <span class="number">13</span>: monitorexit</span><br><span class="line">     <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">     <span class="number">17</span>: astore_2</span><br><span class="line">     <span class="number">18</span>: aload_1</span><br><span class="line">     <span class="number">19</span>: monitorexit</span><br><span class="line">     <span class="number">20</span>: aload_2</span><br><span class="line">     <span class="number">21</span>: athrow</span><br><span class="line">     <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">   Exception table:</span><br><span class="line">      from    to  target type</span><br><span class="line">          <span class="number">4</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">         <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   any</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此处会发现有一个monitorenter，却有两个monitorexit；<br>这是JVM的补偿机制，保证你的同步代码块中出现异常，能正常释放锁</p><p>如字节码行号4-13可能会出现异常，则会走17进行异常处理，在此处进行锁的释放</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每个对象都有一个Monitor与之关联，当Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，都可以通过成对的MonitorEnter和MonitorE</summary>
      
    
    
    
    <category term="juc" scheme="http://c89757.gitee.io/colinstar/categories/juc/"/>
    
    
    <category term="JUC" scheme="http://c89757.gitee.io/colinstar/tags/JUC/"/>
    
    <category term="多线程" scheme="http://c89757.gitee.io/colinstar/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySql性能调优</title>
    <link href="http://c89757.gitee.io/colinstar/2021/12/16/MySql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://c89757.gitee.io/colinstar/2021/12/16/MySql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</id>
    <published>2021-12-16T15:08:30.000Z</published>
    <updated>2021-12-17T11:47:30.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="啥也没有，只是为了样式展示"><a href="#啥也没有，只是为了样式展示" class="headerlink" title="啥也没有，只是为了样式展示"></a>啥也没有，只是为了样式展示</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;啥也没有，只是为了样式展示&quot;&gt;&lt;a href=&quot;#啥也没有，只是为了样式展示&quot; class=&quot;headerlink&quot; title=&quot;啥也没有，只是为了样式展示&quot;&gt;&lt;/a&gt;啥也没有，只是为了样式展示&lt;/h1&gt;</summary>
      
    
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://c89757.gitee.io/colinstar/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>gitee+hexo搭建个人博客</title>
    <link href="http://c89757.gitee.io/colinstar/2021/12/16/gitee+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://c89757.gitee.io/colinstar/2021/12/16/gitee+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-12-16T12:42:22.000Z</published>
    <updated>2021-12-17T11:49:04.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h1><p>事前准备：</p><p>先创建一个仓库，同时在仓库根目录下创建index.html (gitee官网这样说的,没试过缺少这个文件会怎样)</p><img src="/colinstar/2021/12/16/gitee+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.png" class title="This is an example image"><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><h2 id="所需环境"><a href="#所需环境" class="headerlink" title="所需环境"></a>所需环境</h2><ul><li><p>node.js</p></li><li><p>git</p><p>自行进行下载与安装</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装hexo</span></span><br><span class="line">npm install -g hexo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建文件夹,用来存储你博客内容</span></span><br><span class="line">hexo init test</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span>到创建的目录,执行</span></span><br><span class="line">npm install</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启hexo服务</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:4000；没有问题的话就会显示他的默认页面">http://localhost:4000；没有问题的话就会显示他的默认页面</a></p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>关联git仓库，在你创建的目录下找到 config.yml文件（例如此处我的是test/_config.yml）</p><p>打开添加如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://gitee.com/xxx/xxxx</span>   <span class="comment"># 你的仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span>   <span class="comment"># 你的仓库分支</span></span><br></pre></td></tr></table></figure><ul><li>生成静态页面</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g    #或者 hexo generate</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时若出现如下报错：</span></span><br><span class="line">ERROR Local hexo not found in ~/blog</span><br><span class="line">ERROR Try runing: &#x27;npm install hexo --save&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 则执行命令：</span></span><br><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><ul><li>将生成的页面提交到仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d  #或者hexo deploy</span><br></pre></td></tr></table></figure><p>若执行命令hexo deploy报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h1 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h1><p>进入到你创建的“text”目录，新建文章，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;blog&quot;</span><br></pre></td></tr></table></figure><p>此时在test/source/_posts下，会新建一个名为“blog.md”的文件，利用相关markdown编辑器就能编写你的博客啦!(我这里用的typore)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 生成静态页面</span><br><span class="line"></span><br><span class="line">hexo d # 部署到gitee</span><br></pre></td></tr></table></figure><p>hexo有许多主题，默认生成的主题都是landscape，你也可以去<a href="http://hexo.io/themes">主题官网</a>寻找自己喜欢的主题</p><p>例如主题pure</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/cofess/hexo-theme-pure.git themes/pure</span><br><span class="line"><span class="meta">#</span><span class="bash">修改<span class="built_in">test</span>目录下_config.yml里theme的名称,将landscape修改为pure即可</span> </span><br><span class="line"></span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta">#</span><span class="bash">清除缓存文件 (db.json) 和静态文件 (public)</span></span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta">#</span><span class="bash">生成缓存和静态文件</span></span><br><span class="line"></span><br><span class="line">hexo d             </span><br><span class="line"><span class="meta">#</span><span class="bash">重新部署到服务器</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;事前准备：&lt;/p&gt;
&lt;p&gt;先创建一个仓库，同时在仓库根目录下创建index.html (gitee官网这样</summary>
      
    
    
    
    <category term="others" scheme="http://c89757.gitee.io/colinstar/categories/others/"/>
    
    
    <category term="others" scheme="http://c89757.gitee.io/colinstar/tags/others/"/>
    
  </entry>
  
</feed>
